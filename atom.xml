<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白大米的笔记</title>
  
  <subtitle>Be evil, Don&#39;t be evil.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wang-zc.github.io/"/>
  <updated>2020-06-07T10:06:10.558Z</updated>
  <id>https://wang-zc.github.io/</id>
  
  <author>
    <name>Tierney Wong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>27岁,站在人生的第一个十字路口</title>
    <link href="https://wang-zc.github.io/2020/06/07/27%E5%B2%81-%E7%AB%99%E5%9C%A8%E4%BA%BA%E7%94%9F%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%81%E5%AD%97%E8%B7%AF%E5%8F%A3/"/>
    <id>https://wang-zc.github.io/2020/06/07/27岁-站在人生的第一个十字路口/</id>
    <published>2020-06-07T10:06:10.000Z</published>
    <updated>2020-06-07T10:06:10.558Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ThinkPHP3.2 -&gt; Laravel 5.8.29 + Vue</title>
    <link href="https://wang-zc.github.io/2019/11/02/ThinkPHP3-2-Laravel-5-8-29-Vue/"/>
    <id>https://wang-zc.github.io/2019/11/02/ThinkPHP3-2-Laravel-5-8-29-Vue/</id>
    <published>2019-11-02T03:42:57.000Z</published>
    <updated>2019-11-02T03:49:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前情提要</p><p>公司从 2014 年的时候进行了项目重构，从原生的 PHP 框架迁移到了 ThinkPHP 3.2 版本，但是经过时间的发展，我们的框架一直没有迭代更新，而且其中的代码质量参差不齐，2018 年我把代码仓库从 SVN 迁移到 GitLab CE 之后，开始对框架进行集中式的推进，终于在今年我们决定，把云掌柜的技术体系换成 Laravel + Vue 的前后分离方式，使用 Yapi 作为接口管理工具，同时也面临着PHP 5.4 -&gt; PHP 7.2 的迁移。</p></blockquote><p><strong>Laravel 的 6.0 LTS 版本就在迁移的过程中刚出来，后续打算从 5.8 升上来，先等扩展到位把，很多第三方的包还没有适配，像Carbon 这种兼容有问题但是影响巨大的包依赖存在问题，先不动了。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前情提要&lt;/p&gt;
&lt;p&gt;公司从 2014 年的时候进行了项目重构，从原生的 PHP 框架迁移到了 ThinkPHP 3.2 版本，但是经过时间的发展，我们的框架一直没有迭代更新，而且其中的代码质量参差不齐，2018 年我把代码仓库从 SVN 迁移到
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>From Apprentice To Artisan</title>
    <link href="https://wang-zc.github.io/2019/04/21/From-Apprentice-To-Artisan/"/>
    <id>https://wang-zc.github.io/2019/04/21/From-Apprentice-To-Artisan/</id>
    <published>2019-04-21T13:30:58.000Z</published>
    <updated>2019-04-21T13:34:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>Laravel框架的基础是一个功能强大的控制反转容器（IoC container）。 为了真正理解本框架，需要好好掌握该容器。但我们要搞清楚，控制反转容器只是一种用于方便实现“依赖注入”的工具。要实现依赖注入并不一定需要控制反转容器，只是用容器会更方便和容易一点儿。</p><p>首先来看看我们为何要使用依赖注入，它能带来什么好处。 考虑下列代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">BaseController</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getIndex</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $users= User::all();</span><br><span class="line">        <span class="keyword">return</span> View::make(<span class="string">'users.index'</span>, compact(<span class="string">'users'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很简短，但我们要想测试这段代码的话就一定会和实际的数据库发生联系。也就是说， Eloquent ORM 和该控制器有着紧耦合。如果不使用Eloquent ORM，不连接到实际数据库，我们就没办法运行或者测试这段代码。这段代码同时也违背了“关注分离”这个软件设计原则。简单讲：这个控制器知道的太多了。 控制器不需要去了解数据是从哪儿来的，只要知道如何访问就行。控制器也不需要知道这数据是从 MySQL 或哪儿来的，只需要知道这数据目前是可用的。</p><blockquote><p><strong>关注分离</strong></p><p>每一个类都应该有单独的职责，并且该职责应完全被这个类封装。</p></blockquote><p>关注分离的好处就是能让Web控制器和数据访问解耦。这会使得实现存储迁移更容易，测试也会更容易。“Web”就仅仅是为你真正的应用做数据的传输了。</p><p>想象一下你有一个类似于监视器的程序，有着很多线缆接口（HDMI，VGA，DVI等等）。 你可以通过不同的接口访问不同的监视器。把Internet想象成另一个插进你程序线缆接口。大部分显示器的功能是与线缆接口互相独立的。线缆接口只是一 种传输机制就像HTTP是你程序的一种传输机制一样。所以我们不想把传输机制（控制器）和业务逻辑混在一起。这样的好处是很多其他的传输机制比如API调 用、移动应用等都可以访问我们的业务逻辑。</p><p>那么我们就别再将控制器和Eloquent ORM耦合在一起了。 咱们注入一个资料库类。</p><h4 id="建立约定"><a href="#建立约定" class="headerlink" title="建立约定"></a>建立约定</h4><p>首先我们定义一个接口，然后实现该接口。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepositoryInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">all</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DbUserRepository</span> <span class="keyword">implements</span> <span class="title">UserRepositoryInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">all</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> User::all()-&gt;toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们将该接口的实现注入我们的控制器。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">BaseController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(UserRepositoryInterface $users)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;users = $users;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getIndex</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $users=<span class="keyword">$this</span>-&gt;users-&gt;all();</span><br><span class="line">        <span class="keyword">return</span> View::make(<span class="string">'users.index'</span>, compact(<span class="string">'users'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们的控制器就完全和数据层面无关了。我们的数据可能来自MySQL，MongoDB 或者 Redis。我们的控制器不知道也不需要知道他们的区别。仅仅做出了这么小小的改变，我们就可以独立于数据层来测试Web层了，将来切换存储实现也会很容易。</p><blockquote><p><strong>严守边界</strong></p><p>记得要保持清晰的责任边界。 控制器和路由是作为HTTP和你的应用程序之间的中间件来用的。当编写大型应用程序时，不要将你的领域逻辑混杂在其中（控制器、路由）。</p></blockquote><p>为了巩固学到的知识，咱们来写一个测试案例。首先，我们要模拟一个资料库然后绑定到应用的IoC容器里。 然后，我们要保证控制器正确的调用了这个资料库：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testIndexActionBindsUsersFromRepository</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="comment">// Arrange...</span></span><br><span class="line">    $repository = Mockery::mock(<span class="string">'UserRepositoryInterface'</span>);</span><br><span class="line">    $repository-&gt;shouldReceive(<span class="string">'all'</span>)-&gt;once()-&gt;andReturn(<span class="keyword">array</span>(<span class="string">'foo'</span>));</span><br><span class="line">    App::instance(<span class="string">'UserRepositoryInterface'</span>, $repository);</span><br><span class="line">    <span class="comment">// Act...</span></span><br><span class="line">    $response  = <span class="keyword">$this</span>-&gt;action(<span class="string">'GET'</span>, <span class="string">'UserController@getIndex'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assert...</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;assertResponseOk();</span><br><span class="line"><span class="keyword">$this</span>-&gt;assertViewHas(<span class="string">'users'</span>, <span class="keyword">array</span>(<span class="string">'foo'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>你在模仿我么？</strong></p><p>在上面的例子里， 我们使用了名为<code>Mockery</code>的模仿库。 这个库提供了一套整洁且富有表达力的方法，用来模仿你写的类。 Mockery可以通过Composer安装。</p></blockquote><h4 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h4><p>让我们考虑另一个例子来巩固理解。 可能我们想要去提醒用户该交钱了。 我们会定义两个接口， 或者约定。这些约定使我们在更改实际实现时更加灵活。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BillerInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">bill</span><span class="params">(array $user, $amount)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BillingNotifierInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">notify</span><span class="params">(array $user, $amount)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们要写一个<code>BillerInterface</code>的实现：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StripeBiller</span> <span class="keyword">implements</span> <span class="title">BillerInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(BillingNotifierInterface $notifier)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;notifier = $notifier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">bill</span><span class="params">(array $user, $amount)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Bill the user via Stripe...</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;notifier-&gt;notify($user, $amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要遵守了每个类的责任划分，我们很容易将不同的提示器（notifier）注入到账单类里面。 比如，我们可以注入一个<code>SmsNotifier</code>或者<code>EmailNotifier</code>。账单类只要遵守了约定，就不用再考虑如何实现提示功能。只要是遵守约定（接口）的类， 账单类都能用。这不仅仅是方便了我们的开发，而且我们还可以通过模拟<code>BillingNotifierInterface</code>来进行无痛测试。</p><blockquote><p><strong>使用接口</strong></p><p>写接口可能看上去挺麻烦，但实际上能加速你的开发。你不用实现任何接口，就能使用模拟库来模拟你的接口，进而测试整个后台逻辑！</p></blockquote><p>那我们如何做依赖注入呢？很简单：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$biller = <span class="keyword">new</span> StripeBiller(<span class="keyword">new</span> SmsNotifier);</span><br></pre></td></tr></table></figure><p>这就是依赖注入。 biller不需再考虑提醒用户的事儿，我们直接传给他一个提示器（notifier）。 这种微小的改动能使你的应用焕然一新。 你的代码马上就变得更容易维护， 因为明确指定了类的职责边界。 并且更容易测试， 你只需使用模拟依赖即可。</p><p>那 IoC 容器呢？ 难道依赖注入不需要 IoC 容器么？当然不需要！在接下来的章节里面你会了解到，容器使得依赖注入更易于管理，但是容器不是依赖注入所必须的。只要遵循本章提出的原则， 你可以在你任何的项目里面实施依赖注入，而不必管该项目是否使用了容器。</p><h4 id="太像Java了"><a href="#太像Java了" class="headerlink" title="太像Java了?"></a>太像Java了?</h4><p>有人会说使用接口让PHP代码看上去太像Java了——即代码太罗嗦了——你必须定义接口然后实现它，要多按好多下键盘。</p><p>对于小而简单的应用来说，以上说法也对。 接口通常是不必要的。将代码耦合到那些你认为不会改变的地方也是可以的。在你确信不会改变的地方就没有必要使用接口了。架构师说“不会改变的地方是不存在的”。不过话说回来，有时候的确不会改。</p><p>在大型应用中接口是很有帮助的。和提升的代码灵活性、可测试性比起来，多敲键盘费的功夫就微不足道了。当你迅速的切换了代码实现的时候，你的经理一定会被你的神速吓一跳的。你也可以写出更适应变化的代码。</p><p>总而言之， 记住本书提倡“简单”架构。如果你在写小程序的时候无法遵守接口原则， 别觉得不好意思。 要记住做码农呢，<strong>最重要就是开心。</strong>如果你不喜欢写接口，那就先简单的写代码吧。日后再精进即可。</p><h2 id="控制反转容器"><a href="#控制反转容器" class="headerlink" title="控制反转容器"></a>控制反转容器</h2><h4 id="基础绑定"><a href="#基础绑定" class="headerlink" title="基础绑定"></a>基础绑定</h4><p>我们已经学习了依赖注入，接下来咱们一起来探索“控制反转容器”（IoC）。 IoC容器可以使你更容易管理依赖注入，Laravel框架拥有一个很强大的IoC容器。Laravel的核心就是这个IoC容器，这个IoC容器使得框架各个组件能很好的在一起工作。事实上Laravel的Application类就是继承自Container类！</p><blockquote><p><strong>控制反转容器</strong></p><p>控制反转容器使得依赖注入更方便。当一个类或接口在容器里定义以后，如何处理它们——如何在应用中管理、注入这些对象？</p></blockquote><p>在Laravel应用里，你可以通过App来访问控制反转容器。容器有很多方法，不过我们从最基础的开始。让我们继续使用上一章写的<code>BillerInterface</code>和<code>BillingNotifierInterface</code>，且假设我们使用了<a href="https://github.com/fabpot/pimple" target="_blank" rel="noopener">Stripe</a>来进行支付操作。我们可以将Stripe的支付实现绑定到容器里，就像这样：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">App::bind(<span class="string">'BillerInterface'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StripeBiller(App::make(<span class="string">'BillingNotifierInterface'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意在我们处理<code>BillingInterface</code>时，我们额外需要一个<code>BillingNotifierInterface</code>的实现，也就是再来一个bind：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">App::bind(<span class="string">'BillingNotifierInterface'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EmailBillingNotifier;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如你所见， 这个容器就是个用来存储各种绑定的地方。一旦一个类在容器里绑定了以后，我们可以很容易的在应用的任何位置调用它。我们甚至可以在bind函数内写另外的bind。</p><blockquote><p><strong>Have Acne?</strong></p><p>Laravel框架的Illuminate容器和另一个名为<a href="https://github.com/fabpot/pimple" target="_blank" rel="noopener">Pimple</a>的IoC容器是可替换的。所以如果你之前用的是Pimple，你尽可以大胆的升级为<a href="https://github.com/jilluminate/container" target="_blank" rel="noopener">Illuminate Container</a>，后者还有更多新功能！</p></blockquote><p>一旦我们使用了容器，切换接口的实现就是一行代码的事儿。 比如考虑以下代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">BaseController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(BillerInterface $biller)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;biller = $biller;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这个控制器通被容器实例化后，包含着<code>EmailBillingNotifier</code>的<code>StripeBiller</code>会被注入到这个控制器中（译者注：见上文的两个bind）。如果我们现在想要换一种提示方式，我们可以简单的将代码改为这样：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">App::bind(<span class="string">'BillingNotifierInterface'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SmsBillingNotifier;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>现在不管在应用的哪里需要一个提示器，我们总会得到<code>SmsBillingNotifier</code>的对象。利用这种结构，我们的应用可以在不同的实现方式之间快速切换。</p><p>只改一行就能切换代码实现，这可是很厉害的能力。比如我们想把短信服务从原来的提供商替换为Twilio。我们可以开发一个新的Twilio的提示器类（译者注：当然要继承自<code>BillingNotifierInterface</code>）然后修改绑定语句。如果Twilio有任何闪失，我们只需修改一行代码就可以快速的切换回原来的短信提供商。看到了吧，依赖注入的好处多得很呢。你能再想出几个使用依赖注入和控制反转容器的好处么？</p><p>想在应用中只实例化某类一次？没问题，使用<code>singleton</code>方法吧：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">App::singleton(<span class="string">'BillingNotifierInterface'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SmsBillingNotifier;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样只要这个容器生成了这个提示器对象一次， 在接下来的生成请求中容器都只会提供这同样的一个对象。</p><p>容器的<code>instance</code>方法和<code>singleton</code>方法很类似，区别是<code>instance</code>可以绑定一个已经存在的对象。然后容器每次返回的都是这个对象了。</p><p>现在我们熟悉了容器的基础用法，让我们深入发掘它更强大的功能：依靠反射来处理类和接口。</p><blockquote><p><strong>容器独立运行</strong></p><p>你的项目没有使用Laravel？但你依然可以使用Laravel的IoC容器！只要用Composer安装了<code>illuminate/container</code>包就可以了。</p></blockquote><h4 id="反射解决方案"><a href="#反射解决方案" class="headerlink" title="反射解决方案"></a>反射解决方案</h4><p>用反射来自动处理依赖是Laravel容器的一个最强大的特性。反射是一种运行时探测类和方法的能力。比如，PHP的<code>ReflectionClass</code>可以探测一个类的方法。<code>method_exists</code>某种意义上说也是一种反射。我们来把玩一下PHP的反射类，试试下面的代码吧（StripeBiller换成你自己定义好的类）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$reflection = <span class="keyword">new</span> ReflectionClass(<span class="string">'StripeBiller'</span>);</span><br><span class="line">var_dump($reflection-&gt;getMethods());</span><br><span class="line">var_dump($reflection-&gt;getConstants());</span><br></pre></td></tr></table></figure><p>依靠这个强大的PHP特性， Laravel的IoC容器可以实现很有趣的功能！考虑接下来这个类：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">BaseController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(StripBiller $biller)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;biller = $biller;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这个控制器的构造函数暗示着有一个<code>StripBiller</code>类型的参数。使用反射就可以检测到这种类型暗示。当Laravel的容器无法解决一个类型的明显绑定时，容器会试着使用反射来解决。程序流程类似于这样的：</p><ol><li>已经有一个<code>StripBiller</code>的绑定了么？</li><li>没绑定？那用反射来探测一下<code>StripBiller</code>吧。看看他都需要什么依赖。</li><li>解决<code>StripBiller</code>需要的所有依赖（递归处理）</li><li>使用<code>ReflectionClass-&gt;newInstanceArgs()</code>来实例化<code>StripBiller</code></li></ol><p>如你所见， 容器替我们做了好多重活，这能帮你省去写大量绑定的麻烦。这就是Laravel容器最强大也是最独特的特性。熟练掌握这种能力对构建大型Laravel应用是十分有益的。</p><p>下面我们修改一下控制器， 改成这样会发生什么事儿呢？</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">BaseController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(BillerInterface $biller)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;biller = $biller;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们没有为<code>BillerInterface</code>做任何绑定， 容器该怎么知道要注入什么类呢？要知道，interface不能被实例化，因为它只是个约定。如果我们不提供更多信息的话，容器是无法实例化这个依赖的。我们需要明确指出哪个类要实现这个接口，这就需要用到<code>bind</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">App::bind(<span class="string">'BillerInterface'</span>,<span class="string">'StripBiller'</span>);</span><br></pre></td></tr></table></figure><p>这里我们只传了一个字符串进去，而不是一个匿名函数。 这个字符串告诉容器总是使用<code>StripBiller</code>来作为<code>BillerInterface</code>的实现类。 此外我们也获得了只改一行代码即可轻松改变实现的能力。比如，假设我们需要切换到Balanced Payments作为我们的支付提供商，我们只需要新写一个<code>BalancedBiller</code>来实现<code>BillerInterface</code>接口，然后这样修改容器代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">App::bind(<span class="string">'BillerInterface'</span>, <span class="string">'BalancedBiller'</span>);</span><br></pre></td></tr></table></figure><p>我们的应用程序就装载上了的新支付实现代码了！</p><p>你也可以使用<code>singleton</code>方法来实现单例模式。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">App::singleton(<span class="string">'BillerInterface'</span>, <span class="string">'StripBiller'</span>);</span><br></pre></td></tr></table></figure><blockquote><p><strong>掌握容器</strong></p><p>想了解更多关于容器的知识？ 去读源码！容器只有一个类<code>Illuminate\Container\Container</code>. 读完了你就对容器有更深的认识了。</p></blockquote><h2 id="接口约定"><a href="#接口约定" class="headerlink" title="接口约定"></a>接口约定</h2><h4 id="强类型和小鸭子"><a href="#强类型和小鸭子" class="headerlink" title="强类型和小鸭子"></a>强类型和小鸭子</h4><p>在之前的章节里，涵盖了依赖注入的基础知识：什么是依赖注入；如何实现依赖注入；依赖注入有什么好处。 之前章节里面的例子也模拟了将 interface 注入到 classes 里面的过程。在我们继续学习之前，有必要深入讲解一下接口，而这正是很多PHP开发者所不熟悉的。</p><p>在我成为PHP程序员之前，我是写.NET的。 你觉得我喜欢受虐么？在.NET里可到处都是接口。 事实上很多接口是定义在.NET框架核心中了，一个好的理由是：很多.NET语言比如C#和VB.NET都是强类型。 也就是说，你在给一个函数传值，要么传原生类型对象，要么就必须给这个对象一个明确的<em>类型</em>定义。比如考虑以下C#方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">BillUser</span>(<span class="params">User user</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.biller.bill(user.GetId(), <span class="keyword">this</span>.amount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在这里， 我们不仅要定义传进去的参数是什么类型的，还要定义这个方法返回值是什么类型的。 C#鼓励类型安全。除了指定的<code>User</code>对象，它不允许我们传递其他类型的对象到<code>BillUser</code>方法中。</p><p>然而PHP是一种鸭子类型的语言。 所谓鸭子类型的语言， 一个对象可用的方法取决于使用方式， 而非这个方法从哪儿继承或实现。来看个例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">billUser</span><span class="params">($user)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;biller-&gt;bill($user-&gt;getId(), <span class="keyword">$this</span>-&gt;amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在PHP里面，我们不必告诉一个方法需要什么类型的参数。 实际上我们传递任何类型的对象都可以，只要这个对象能响应<code>getId</code>的调用。这里有个关于鸭子类型（下文译作：弱类型）的解释：如果一个东西看起来像个鸭子，叫声也像鸭子叫，那他就是个鸭子。 换言之在程序里，一个对象看上去是个User，方法响应也像个User，那他就是个User。</p><p>不过PHP到底有没有任何强类型功能呢？当然有！PHP混合了强类型和弱类型的结构。为了说明这点，咱们来重写一下<code>billUser</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">billUser</span><span class="params">(User $user)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;biller-&gt;bill($user-&gt;getId(), $amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给方法加上了加上了<code>User</code>类型提示后， 我们可以确信的说所有传入<code>billUser</code>方法的参数，都是<code>User</code>类或是继承自<code>User</code>类的一个实例。</p><p>强类型和弱类型各有优劣。 在强类型语言中， 编译器通常能提供编译时错误检查的功能，这功能可是非常有用的。方法的输入和输出也更加明确。</p><p>与此同时，强类型的特性也使得程序僵化。比如Eloquent ORM中，类似<code>whereEmailOrName</code>的动态方法就不可能在C#这样的强类型语言里实现。我们不讨论强类型弱类型哪种更好，而是要记住他们分别的优劣之处。在PHP里面使用强类型标记不是错误，使用弱类型特性也不是错误。但是不加思索，不管实际情况去使用一种模式，这么固执的使用就是错的。</p><h4 id="约定的范例"><a href="#约定的范例" class="headerlink" title="约定的范例"></a>约定的范例</h4><p>接口就是约定。接口不包含任何代码实现，只是定义了一个对象应该实现的一系列方法。如果一个对象实现了一个接口，那么我们就能确信这个接口所定义的一系列方法都能在这个对象上使用。因为有约定保证了特定方法的实现标准，通过<em>多态</em>也能使类型安全的语言变得更灵活。</p><blockquote><h5 id="多什么肽？"><a href="#多什么肽？" class="headerlink" title="多什么肽？"></a>多什么肽？</h5><p>多态含义很广，其本质上是说一个实体拥有多种形式。在本书中，我们讲多态是一个接口有着多种实现。比如<code>UserRepositoryInterface</code>可以有MySQL和Redis两种实现，每一种实现都是<code>UserRepositoryInterface</code>的一个实例。</p></blockquote><p>为了说明在强类型语言中接口的灵活性，咱们来写一个酒店客房预订的代码。考虑以下接口：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ProviderInterface</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getLowestPrice</span><span class="params">($location)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">book</span><span class="params">($location)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用户订房间时，我们需要将此事记录在系统里。所以在<code>User</code>类里面写点方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">bookLocation</span><span class="params">(ProviderInterface $provider, $location)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $amountCharged = $provider-&gt;book($location);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;logBookedLocation($location, $amountCharged);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们写出了<code>ProviderInterface</code>的类型提示，该<code>User</code>类的就可以放心大胆的认为<code>book</code>方法是可以调用的。这使得<code>bookLocation</code>方法有了重用性。当用户想要换一家酒店提供商时也就更灵活。最后咱们来写点代码来强化他的灵活性。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$location = <span class="string">'Hilton, Dallas'</span>;</span><br><span class="line"></span><br><span class="line">$cheapestProvider = <span class="keyword">$this</span>-&gt;findCheapest($location, <span class="keyword">array</span>(</span><br><span class="line">    <span class="keyword">new</span> PricelineProvider,</span><br><span class="line">    <span class="keyword">new</span> OrbitzProvider,</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">$user-&gt;bookLocation($cheapestProvider, $location);</span><br></pre></td></tr></table></figure><p>太棒了！不管哪家是最便宜的，我们都能够将他传入<code>User</code>对象来预订房间了。由于<code>User</code>对象只需要要有一个符合<code>ProviderInterface</code>约定的实例就可以预订房间，所以未来有更多的酒店供应商我们的代码也可以很好的工作。</p><blockquote><h5 id="忘掉细节"><a href="#忘掉细节" class="headerlink" title="忘掉细节"></a>忘掉细节</h5><p>记住，接口实际上不真正做任何事情。它只是简单的定义了类们<strong>必须</strong>实现的一系列方法。</p></blockquote><h4 id="接口与团队开发"><a href="#接口与团队开发" class="headerlink" title="接口与团队开发"></a>接口与团队开发</h4><p>当你的团队在开发大型应用时，不同的部分有着不同的开发速度。比如一个开发人员在制作数据层，另一个开发人员在做前端和网站控制器层。前端开发者想测试他的控制器，不过后端开发较慢没法同步测试。那如果两个开发者能以接口的方式达成协议，后台开发的各种类都遵循这种协议，就像这样：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OrderRepositoryInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getMostRecent</span><span class="params">(User $user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦建立了约定，就算约定还没实现，前端开发者也可以测试他的控制器了！这样应用中的不同组件就可以按不同的速度开发，并且单元测试也可以做。而且这种处理方法还可以使组件内部的改动不会影响到其他不相关组件。要记着无知是福。我们写的那些类们不用知道别的类<em>如何</em>实现的，只要知道它们<em>能</em>实现什么。这下咱们有了定义好的约定，再来写控制器：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(OrderRepositoryInterface $orders)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;orders = $orders;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getRecent</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $recent = <span class="keyword">$this</span>-&gt;orders-&gt;getMostRecent(Auth::user());</span><br><span class="line">        <span class="keyword">return</span> View::make(<span class="string">'orders.recent'</span>, compact(<span class="string">'recent'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端开发者甚至可以为这接口写个“假”实现，然后这个应用的视图就可以用假数据填充了：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DummyOrderRepository</span> <span class="keyword">implements</span> <span class="title">OrderRepositoryInterface</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getMostRecent</span><span class="params">(User $user)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">array</span>(<span class="string">'Order 1'</span>, <span class="string">'Order 2'</span>, <span class="string">'Order 3'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦假实现写好了，就可以被绑定到IoC容器里，然后整个程序都可以调用他了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">App::bind(&apos;OrderRepositoryInterface&apos;, &apos;DummyOrderRepository&apos;);</span><br></pre></td></tr></table></figure><p>接下来一旦后台开发者写完了真正的实现代码，比如叫<code>RedisOrderRepository</code>。那么IoC容器就可以轻易的切换到真正的实现上。整个应用就会使用从Redis读出来的数据。</p><blockquote><h5 id="接口就是大纲"><a href="#接口就是大纲" class="headerlink" title="接口就是大纲"></a>接口就是大纲</h5><p>接口在开发程序的“骨架”时非常有用。 在设计组件时，使用接口进行设计和讨论都是对你的团队有益处的。比如定义一个<code>BillingNotifierInterface</code>然后讨论他有什么方法。在写任何实现代码前先用接口讨论好一套好的API！</p></blockquote><h2 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h2><h4 id="他是引导程序"><a href="#他是引导程序" class="headerlink" title="他是引导程序"></a>他是引导程序</h4><p>一个Laravel服务提供者就是一个用来进行IoC绑定的类。事实上，Laravel有好几十个服务提供者，用于管理框架核心组件的容器绑定。几乎框架里每一个组件的IoC绑定都是靠服务提供者来做的。你可以在<code>app/config/app.php</code>这个文件里查看目前有哪些服务提供者。</p><p>一个服务提供者必须有一个<code>register</code>方法。你可以在这个方法里写IoC绑定。当一个请求发过来，程序框架刚启动时，所有在你配置文件里的服务提供者的<code>register</code>方法就会被调用。这在程序周期的很早的地方就会执行，所以在你自己的引导代码（比如那些在<code>start</code>目录里的文件）里所有的服务已经准备好了。</p><blockquote><h5 id="注册-Vs-引导代码"><a href="#注册-Vs-引导代码" class="headerlink" title="注册 Vs 引导代码"></a>注册 Vs 引导代码</h5><p>永远不要在<code>register</code>方法里面使用任何服务。该方法只是用来进行IoC绑定的地方。所有关于绑定类后续的判断、交互都要在<code>boot</code>方法里进行。</p></blockquote><p>你用Composer安装的一些第三方包也会有服务提供者。在第三方包的安装说明里一般都会告诉你要在<code>providers</code>数组里加上一行。一旦你加上了，那这个服务就算安装好了。</p><blockquote><h5 id="包提供者"><a href="#包提供者" class="headerlink" title="包提供者"></a>包提供者</h5><p>不是所有的第三方包都需要服务提供者。事实上一个包并不需要服务提供者。因为服务提供者只是一个用来自动初始化服务组件的地方，一个方便管理引导代码和容器绑定的地方。</p></blockquote><p><strong>Deferred Providers 延迟加载的服务提供者</strong></p><p>并非在你配置文件中的<code>providers</code>数组里的所有提供者在每次请求都会被实例化。否则会对性能不利，尤其是这个服务的功能用不到的情况下。比如，<code>QueueServiceProvider</code>服务就不是每次都用得到。</p><p>为了达到只实例化需要的服务的提供者，Laravel生成了“服务清单”并且储存在了<code>app/storage/meta</code>目录下。这份清单列出了应用里所有的服务提供者，包括容器绑定的名字也记录了。这样，当应用想让容器取出一个名为<code>queue</code>的绑定时，Laravel知道需要先实例化并运行<code>QueueServiceProvider</code>因为在服务清单里记录着该服务提供者能提供<code>queue</code>的绑定。如此这般框架就能够延迟加载每个请求需要的服务了，性能大大提高。</p><blockquote><h5 id="如何生成服务清单"><a href="#如何生成服务清单" class="headerlink" title="如何生成服务清单"></a>如何生成服务清单</h5><p>当你在<code>providers</code>数组里新增一条，Laravel在下一次请求时就会自动重新生成服务清单。</p></blockquote><p>如果你有时间，去看看服务清单文件里面的内容。理解这个文件的结构有助于你对服务进行排错。</p><h4 id="作为管理工具"><a href="#作为管理工具" class="headerlink" title="作为管理工具"></a>作为管理工具</h4><p>想制作一个结构优美的Laravel应用的话，就要去学习如何用服务提供者来管理代码。当你在注册IoC绑定的时候，所有代码都杂乱的塞进了<code>app/start</code>路径下的文件里。 别再这样做了，使用服务提供者来注册这些吧。</p><blockquote><h5 id="Get-It-Started-万物之初"><a href="#Get-It-Started-万物之初" class="headerlink" title="Get It Started 万物之初"></a>Get It Started 万物之初</h5><p>你应用的“启动”文件都储存在<code>app/start</code>目录下。根据不同的请求入口，系统会载入不同的启动文件。在全局的<code>start.php</code>文件加载后，系统会根据执行环境的不同来加载不同的启动文件。 此外，在执行命令行程序时，<code>artisan.php</code>文件会被载入。</p></blockquote><p>咱们来考虑这个例子。也许我们的应用正在使用<a href="http://pusher.com/" target="_blank" rel="noopener">Pusher</a> 来为客户推送消息。为了将我们的应用和Pusher解耦，我们要定义<code>EventPusherInterface</code>接口和对应的实现类<code>PusherEventPusher</code>。这样在需求变化或应用改进时，我们就可以随时轻松的改变推送服务提供商。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">EventPusherInterface</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">push</span><span class="params">($message, array $data = array<span class="params">()</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PusherEventPusher</span> <span class="keyword">implements</span> <span class="title">EventPusherInterface</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(PusherSdk $pusher)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;pusher = $pusher;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">push</span><span class="params">($message, array $data = array<span class="params">()</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Push message via the Pusher SDK...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们创建一个<code>EventPusherServiceProvider</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">ServiceProvider</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventPusherServiceProvider</span> <span class="keyword">extends</span> <span class="title">ServiceProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;app-&gt;singleton(<span class="string">'PusherSdk'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PusherSdk(<span class="string">'app-key'</span>, <span class="string">'secret-key'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">$this</span>-&gt;app-&gt;singleton(<span class="string">'EventPusherInterface'</span>, <span class="string">'PusherEventPusher'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很好！ 我们对事件推送进行了清晰的抽象，同时我们也有了一个很不错的地方进行注册、绑定其他相关的东西到容器里。最后一步只需要将<code>EventPusherServiceProvider</code>写入<code>app/config/app.php</code>文件内的<code>providers</code>数组里就可以了。现在这个应用里的<code>EventPusherInterface</code>已经被绑定到了正确的实现类上。</p><blockquote><h5 id="要使用单例么？"><a href="#要使用单例么？" class="headerlink" title="要使用单例么？"></a>要使用单例么？</h5><p>用不用单例可以这样来考虑：如果在一次请求周期中该类只需要有一个实例，就使用<code>singleton</code>；否则就使用<code>bind</code>。</p></blockquote><p>Note that a service provider has an <code>$app</code> instance available via the base <code>ServiceProvider</code> class. This is a full <code>Illuminate\Foundation\Application</code> instance, which inherits from the <code>Container</code> class, so we can call all of the IoC container methods we are used to. If you preffer to use the <code>App</code> facade inside the service provider, you may do that as well:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">App::singleton(&apos;EventPusherInterface&apos;, &apos;PusherEventPusher&apos;);</span><br></pre></td></tr></table></figure><p>当然服务提供者的功能不仅仅局限于消息推送。像是云存储、数据库访问、自定义的视图引擎比如Twig等等都可以用这种模式来设置。服务提供者就是你的应用里的启动代码和管理工具，没什么神奇的。</p><p>所以大胆的去创建你自己的服务提供者。并不是你非要发布个什么软件包才需要服务提供者，他们只是非常好的管理代码的工具。使用它们的力量去管理好应用中的各个组件吧。</p><h4 id="服务提供者的启动过程"><a href="#服务提供者的启动过程" class="headerlink" title="服务提供者的启动过程"></a>服务提供者的启动过程</h4><p>在所有服务提供者都注册以后，他们就进入了“启动”过程。该过程会触发每个服务提供者的<code>boot</code>方法。这里会发生一种常见的错误用法：在<code>register</code>方法里面调用其他的服务。由于在<code>register</code>方法里我们不能保证所有其他服务都已经被加载，所以在该方法里调用别的服务有可能会出错。所以如果你想在服务提供者里调用别的服务，请在<code>boot</code>方法里做这种事儿。<code>register</code>方法<strong>只能</strong>进行容器注册。</p><p>在启动方法里面，你想做什么都可以：注册事件监听，引入路由文件，注册过滤器，或者其他你能想象到的事儿。再强调一下，要发挥服务提供者的管理功能。可能你想将相关的多个事件监听归为一组？将他们放到一个服务提供者的<code>boot</code>方法里，这会很管用的！或者你也可以引入单独的“events”、“routes”PHP文件：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">boot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">require_once</span> <span class="keyword">__DIR__</span>.<span class="string">'/events.php'</span>;</span><br><span class="line">    <span class="keyword">require_once</span> <span class="keyword">__DIR__</span>.<span class="string">'/routes.php'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们已经学习了依赖注入以及如何使用服务提供者来组织管理我们的项目。这样我们的Laravel应用就有了一个很好的基础，它结构优美并且易于维护和测试。接下来，我们将探索Laravel框架本身是如何使用服务提供者的，并且深究其原理！</p><blockquote><h5 id="不要让条条框框限制你自己"><a href="#不要让条条框框限制你自己" class="headerlink" title="不要让条条框框限制你自己"></a>不要让条条框框限制你自己</h5><p>记住，服务提供者不仅仅是专业的软件包才能使用。 请大胆的使用它来组织管理你的应用服务吧。</p></blockquote><h4 id="核心也是服务提供者的模式"><a href="#核心也是服务提供者的模式" class="headerlink" title="核心也是服务提供者的模式"></a>核心也是服务提供者的模式</h4><p>你可能已经注意到，在<code>app</code>配置文件里面已经有了很多服务提供者。每一个都负责启动框架核心的一部分。比如<code>MigrationServiceProvider</code>负责启动数据库迁移的类，包括Artisan里面的命令。<code>EventServiceProvide</code>负责启动和注册事件调度机制。不同的服务提供者有着不同的复杂度，但他们都负责启动核心的一部分。</p><blockquote><h5 id="和服务提供者们见见面"><a href="#和服务提供者们见见面" class="headerlink" title="和服务提供者们见见面"></a>和服务提供者们见见面</h5><p>理解Laravel核心的最好方法是去读它的核心服务源码。如果你对这些服务的源码、容器注册等都很熟悉，那么你对Laravel是如何工作的将会有十分深刻的理解。</p></blockquote><p>大部分的服务提供者是延迟加载的，意味着并非所有请求都会调用到他们；然而有一些很基础的服务是每一次请求都会被加载的，比如<code>FilesystemServiceProvide</code>和<code>ExceptionServiceProvider</code>。有人会说核心服务提供者和应用程序容器<em>就是</em>Laravel。Laravel 其实是将这么多不同部分联系起来，形成一个单一的、内聚的整体的这么一个机制。拿建筑来比喻，那些服务提供者就是框架的预制模块。</p><p>正如之前提到的那样，如果你想更深的了解框架是如何运行的，请读 Lravel 的核心服务的源码吧。读过之后，你会对框架如何将各部分组合在一起、每一个服务是如何为你所用这些机制有更坚实的理解。此外，有了这些进一步的理解，你也可以为 Laravel 添砖加瓦！</p><h2 id="应用结构"><a href="#应用结构" class="headerlink" title="应用结构"></a>应用结构</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>这个类要写到哪儿？这是一个在用框架写应用程序时十分常见的问题。大量的开发人员都有这个疑问。他们被灌输“Model”就是“Database”，在控制器里面处理HTTP请求，在模型里操作数据库，视图里包含了要显示的HTML。不过，发送电子邮件的类要写到哪儿？数据验证的类要写到哪儿？调用外部API的类要写到哪儿？在这一章节，我们将学习如何写结构优美的Laravel应用，打破长久以来掣肘开发人员的普遍思维惯性这个拦路虎，最终做出好的设计。</p><h4 id="MVC是慢性谋杀"><a href="#MVC是慢性谋杀" class="headerlink" title="MVC是慢性谋杀"></a>MVC是慢性谋杀</h4><p>为了做出好的程序设计，最大的拦路虎就是一个简单的缩写词：M-V-C。模型、视图、控制器主宰了Web框架的思想已经好多年了。这种思想的流行某种程度上是托了Ruby on Rails愈加流行的福。然而，如果你问一个开发人员“模型”的定义是什么。通常你会听到他嘟哝着什么“数据库”之类的东西。这么说，模型就是数据库了。不管这意味着什么，模型里包含了关于数据库的<em>一切</em>。但是，你很快就会知道，你的应用程序需要的不仅仅是一个简单的数据库访问类。他需要更多的逻辑如：数据验证、调用外部服务、发送电子邮件，等等更多。</p><blockquote><h5 id="模型是啥？"><a href="#模型是啥？" class="headerlink" title="模型是啥？"></a>模型是啥？</h5><p>单词”model”的含义太模糊了，很难说明白准确的含义。更具体来讲，模型是用来将我们的应用划分成更小、更清晰的类，使得各代码部分有着明确的权责。</p></blockquote><p>所以怎么解决这个问题（译者注：上文中“更多的业务逻辑”）呢？很多开发者开始将业务逻辑包装到控制器里面。当控制器庞大到一定规模，他们将会需要重用业务逻辑。大部分开发人员没有将这些业务逻辑提取到别的类里面，而是错误的臆想他们需要在控制器里面调用别的控制器。这种模式通常被称为“HMVC”。不幸的是，这种模式通常也预示着糟糕的程序设计，并且控制器已经太复杂了。</p><blockquote><h5 id="HMVC（通常）预示着糟糕的设计。"><a href="#HMVC（通常）预示着糟糕的设计。" class="headerlink" title="HMVC（通常）预示着糟糕的设计。"></a>HMVC（通常）预示着糟糕的设计。</h5><p>你觉得需要在控制器里面调用其他的控制器？这通常预示着糟糕的程序设计并且你的控制器里面业务逻辑太多了。把业务逻辑抽出来放到一个新的类里面，这样你就可以在其他任何控制器里面调用了。</p></blockquote><p>有一种更好的程序结构。但首先我们要忘掉以往我们被灌输的关于“模型”的一切。干脆点，让我们直接删掉model目录，重新开始吧！</p><h4 id="再见，模型"><a href="#再见，模型" class="headerlink" title="再见，模型"></a>再见，模型</h4><p>删掉你的<code>models</code>目录了么？还没删就赶紧删了！我们将要在<code>app</code>目录下创建个新的目录，目录名就以我们这个应用的名字来命名，这次我们就叫<code>QuickBill</code>吧。在后续的讨论中，我们在前面写的那些接口和类都会出现。</p><blockquote><h5 id="注意使用场景"><a href="#注意使用场景" class="headerlink" title="注意使用场景"></a>注意使用场景</h5><p>记住，如果你在写一个很小的Laravel应用，那在<code>models</code>目录下写几个Eloquent模型其实挺合适的。但在本章节，我们主要关注如何开发更有合适“层次”架构的大型复杂项目。</p></blockquote><p>这样我们现在有了个<code>app/QuickBill</code>目录，它和应用目录下的其他目录如<code>controllers</code>还有<code>views</code>都是平级的。在<code>QuickBill</code>目录下我们还可以创建几个其他的目录。我们来在里面创建个<code>Repositories</code>和<code>Billing</code>目录。目录都创建好以后，别忘了在<code>composer.json</code>文件里加入 PSR-0 的自动载入机制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"autoload"</span>: &#123;</span><br><span class="line">    <span class="string">"psr-0"</span>:    &#123;</span><br><span class="line">        <span class="string">"QuickBill"</span>:    <span class="string">"app/"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>译者注：psr-0 也可以改成 psr-4， “psr-4”: { “QuickBill&quot;: “app/QuickBill” } psr-4 是比较新的建议标准，和 psr-0 具体有什么区别请自行检索。</p></blockquote><p>现在我们把继承自 Eloquent 的模型类都放到<code>QuickBill</code>目录下面。这样我们就能很方便的以<code>QuickBill\User</code>, <code>QuickBill\Payment</code>的方式来使用它们。<code>Repositories</code>目录属于<code>PaymentRepository</code> 和<code>UserRepository</code>这种类，里面包含了所有对数据的访问功能比如<code>getRecentPayments</code>和<code>getRichestUser</code>。<code>Billing</code>目录应当包含调用第三方支付服务（如Stripe和Balanced）的类。整个目录结构应该类似这样：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app</span></span><br><span class="line">    <span class="comment">// QuickBill</span></span><br><span class="line">        <span class="comment">// Repositories</span></span><br><span class="line">            -&gt; UserRepository.php</span><br><span class="line">            -&gt; PaymentRepository.php</span><br><span class="line">        <span class="comment">// Billing</span></span><br><span class="line">            -&gt; BillerInterface.php</span><br><span class="line">            -&gt; StripeBiller.php</span><br><span class="line">        <span class="comment">// Notifications</span></span><br><span class="line">            -&gt; BillingNotifierInterface.php</span><br><span class="line">            -&gt; SmsBillingNotifier.php</span><br><span class="line">        User.php</span><br><span class="line">        Payment.php</span><br></pre></td></tr></table></figure><blockquote><h5 id="数据验证怎么办？"><a href="#数据验证怎么办？" class="headerlink" title="数据验证怎么办？"></a>数据验证怎么办？</h5><p>在哪儿进行数据验证常常困扰着开发人员。可以考虑将数据验证方法写进你的“实体”类里面（好比<code>User.php</code>和<code>Payment.php</code>）。方法名可以设为<code>validForCreation</code>或<code>hasValidDomain</code>。或者你也可以专门创建个验证器类<code>UserValidator</code>，放到<code>Validation</code>命名空间下，然后将这个验证器类注入到你的repository类里面。两种方式你都可以试试，看哪个你更喜欢！</p></blockquote><p>摆脱了<code>models</code>目录后，你通常就能克服心理障碍，实现好的设计。使得你能创建一个更合适的目录结构来为你的应用服务。当然，你建立的每一个应用程序都会有一定的相似之处，因为每个复杂的应用程序都需要一个数据访问（repository）层，一些外部服务层等等。</p><blockquote><h5 id="别害怕目录"><a href="#别害怕目录" class="headerlink" title="别害怕目录"></a>别害怕目录</h5><p>不要惧怕建立目录来管理应用。要常常将你的应用切割成小组件，每一个组件都要有十分专注的职责。跳出“模型”的框框来思考。比如我们之前就说过，你可以创建个<code>Repositories</code>目录来存放你所有的数据访问类。</p></blockquote><h4 id="核心思想就是分层"><a href="#核心思想就是分层" class="headerlink" title="核心思想就是分层"></a>核心思想就是分层</h4><p>你可能注意到，优化应用的设计结构的关键就是责任划分，或者说是创建不同的责任层次。控制器只负责接收和响应HTTP请求然后调用合适的业务逻辑层的类。你的业务逻辑/领域逻辑层才是你真正的程序。你的程序包含了读取数据，验证数据，执行支付，发送电子邮件，还有你程序里任何其他的功能。事实上你的领域逻辑层不需要知道任何关于“网络”的事情！网络仅仅是个访问你程序的传输机制，关于网络和HTTP请求的一切不应该超出路由和控制器层。做出好的设计的确很有挑战性，但好的设计也会带来可持续发展的清晰的好代码。</p><p>举个例子。与其在你业务逻辑类里面直接获取网络请求，不如你直接把网络请求从控制器传给你的业务逻辑类。这个简单的改动将你的业务逻辑类和“网络”分离开了，并且不必担心怎么去模拟网络请求，你的业务逻辑类就可以简单的测试了：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BillingController</span> <span class="keyword">extends</span> <span class="title">BaseController</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(BillerInterface $biller)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;biller = $biller;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">postCharge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;biller-&gt;chargeAccount(Auth::user(), Input::get(<span class="string">'amount'</span>));</span><br><span class="line">        <span class="keyword">return</span> View::make(<span class="string">'charge.success'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在<code>chargeAccount</code> 方法更容易测试了。 我们把<code>Request</code>和<code>Input</code>从<code>BillingInterface</code>里提出来，然后在控制器里把方法需要的支付金额直接传过去。</p><p>编写拥有高可维护性应用程序的关键之一，就是责任分割。要时常检查一个类是否管得太宽。你要常常问自己“这个类需不需要关心XXX呢？”如果答案是否定的，那么把这块逻辑抽出来放到另一个类里面，然后用依赖注入的方式进行处理。（译者注：依赖注入的不同方式还记得么？调用方法传参、构造函数传参、从IoC容器获取等等。）</p><blockquote><p><strong>Single Reason To Change</strong></p><p>如何判断一个类是否管得太宽，有一个有用的方法就是检查你为什么要改这块儿代码。举个例子：当我们想调整通知逻辑的时候，我们需要修改<code>Biller</code>的实现代码么？当然不需要，<code>Biller</code>的实现仅仅需要考虑支付，它与通知逻辑应当仅通过约定来进行交互。使用这种思路过一遍代码，会让你很快找出应用中需要改进的地方。</p></blockquote><h4 id="东西都放哪儿？"><a href="#东西都放哪儿？" class="headerlink" title="东西都放哪儿？"></a>东西都放哪儿？</h4><p>当用 Laravel 开发应用时，你可能迷惑于应该把各种“东西”都放在哪儿。比如，辅助函数要放在哪里？事件监听器要放在哪里？视图组件要放在哪里？答案可能出乎你的意料——“想放哪儿都行！”Laravel 并没有很多在文件系统上的约定。不过这个答案的确不能让人满意，所以下面我们就这个问题展开讨论，一起探索这些“东西”究竟可以放在哪儿。</p><p><strong>Helper Functions 辅助函数</strong></p><p>Laravel 有一个文件(<code>support/helpers.php</code>)里面都是辅助函数。你或许希望创建一个类似的文件来存储你自己的辅助函数。“start”文件是个不错的入口，该文件会在应用的每一次请求时被访问。在<code>start/global.php</code>里，你可以引入你自己写的<code>helpers.php</code>文件，就像这样：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Within app/start/global.php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require_once</span> <span class="keyword">__DIR__</span>.<span class="string">'/../helpers.php'</span>;</span><br><span class="line"><span class="comment">//译者注： 该helpers.php文件位于app目录下，需要你自己创建。你想放到别的地方也可以。</span></span><br></pre></td></tr></table></figure><p><strong>Event Listeners 事件监听器</strong></p><p>事件监听器当然不该放到<code>routes.php</code>文件里面，若直接放到“start”目录下的文件里会比较乱，所以我们要找另外的地方来存放。服务提供者是个好地方。我们之前了解到，服务提供者可不仅仅是用来做依赖注入绑定，还可以干其他事儿。可以将事件监听器用服务提供者来管理起来，让代码更整洁，不至于影响到你应用的主要逻辑代码。视图组件其实和事件差不多，也可以类似的放到服务提供者里面。</p><p>例如使用服务提供者进行事件注册可以这样：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">QuickBill</span>\<span class="title">Providers</span>;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">ServiceProvider</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BillingEventsProvider</span> <span class="keyword">extends</span> <span class="title">ServiceProvider</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">boot</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Event::listen(<span class="string">'billing.failed'</span>, <span class="function"><span class="keyword">function</span><span class="params">($bill)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="comment">// Handle failed billing event...</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>创建好服务提供者后，就可以将它加入到<code>app/config/app.php</code> 配置文件的<code>providers</code>数组里。</p><blockquote><h5 id="注意启动流程"><a href="#注意启动流程" class="headerlink" title="注意启动流程"></a>注意启动流程</h5><p>记住在上面的例子里面，我们在<code>boot</code>方法里进行编写是有原因的。<code>register</code>方法<strong>只能</strong>用来进行依赖注入绑定。</p></blockquote><p><strong>错误处理</strong></p><p>如果你的应用里面有很多自定义的错误处理方法，那你的“启动”文件可能会很臃肿。和刚才的事件监听器一样，错误处理方法也最好放到服务提供者里面。这种服务提供者可以命名为像<code>QuickBillErrorProvider</code>这种。然后你在<code>boot</code>方法里想注册多少错误处理方法都可以了。重申一下精神：让呆板的代码离你应用的业务逻辑越远越好。下方展示了这种服务提供者的一种可能的书写方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">namespace</span> <span class="title">QuickBill</span>\<span class="title">Providers</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>, <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">ServiceProvider</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickBillErrorProvider</span> <span class="keyword">extends</span> <span class="title">ServiceProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">boot</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        App::error(<span class="function"><span class="keyword">function</span><span class="params">(BillingFailedException $e)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// Handle failed billing exceptions ...</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="简便做法"><a href="#简便做法" class="headerlink" title="简便做法"></a>简便做法</h5><p>当然如果你只有一两条简单的错误处理方法，那么都写在“启动”文件里面也是一种又快又好的简便做法。</p></blockquote><p><strong>The Rest 其他</strong></p><p>通常只要遵循 PSR-0（译者注：或 PSR-4）就可以保持类的整洁。命令式的代码比如事件监听器、错误处理器还有其他“注册”性质的操作都可以放在服务提供者里面。对于什么代码要放在什么地方这个问题，结合你目前为止学到的知识，应当可以给出一个有理有据的答案了。但永远不要害怕试验。Laravel 最美妙之处就是你可以做出最适合你自己的风格。去探索和发现最适合你自己应用的结构吧，别忘了和他人分享你的见解！</p><p>例如你可能注意到我们上面的例子，你可以创建个<code>Providers</code>的命名空间来存放你自己写的服务提供者，目录就类似于这样：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app</span></span><br><span class="line">    <span class="comment">// QuickBill</span></span><br><span class="line">        <span class="comment">// Billing</span></span><br><span class="line">        <span class="comment">// Extensions</span></span><br><span class="line">            <span class="comment">//Pagination</span></span><br><span class="line">                -&gt; Environment.php</span><br><span class="line">        <span class="comment">// Providers</span></span><br><span class="line">            -&gt; EventPusherServiceProvider.php</span><br><span class="line">        <span class="comment">// Repositories</span></span><br><span class="line">        User.php</span><br><span class="line">        Payment.php</span><br></pre></td></tr></table></figure><p>看上面的例子我们有<code>Providers</code>和<code>Extensions</code>两个命名空间（译者注：分别对应两个同名目录）。你自己写的服务提供者可以放到<code>Providers</code>命名空间下。那个<code>Extensions</code>命名空间可以用来存放你对框架核心进行扩展的类。</p><h2 id="实用方法：解耦处理函数"><a href="#实用方法：解耦处理函数" class="headerlink" title="实用方法：解耦处理函数"></a>实用方法：解耦处理函数</h2><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>我们已经讨论了用 Laravel 4 制作优美的程序架构的各个方面，让我们再深入一些细节。在本章，我们将讨论如何解耦各种处理函数：队列处理函数、事件处理函数，甚至其他“事件型”的结构如路由过滤器。</p><blockquote><h5 id="不要堵塞传输层"><a href="#不要堵塞传输层" class="headerlink" title="不要堵塞传输层"></a>不要堵塞传输层</h5><p>大部分的“处理函数”可以被当作传输层组件。也就是说，队列触发器、被触发的事件、或者外部发来的请求等都可能调用处理函数。可以把处理函数理解为控制器，避免在里面堆积太多具体业务逻辑实现。</p></blockquote><h4 id="解耦处理函数"><a href="#解耦处理函数" class="headerlink" title="解耦处理函数"></a>解耦处理函数</h4><p>接下来我们看一个例子。考虑有一个队列处理函数用来给用户发送手机短信。信息发送后，处理函数还要记录消息日志来保存给用户发送的消息历史。代码应该看起来是这样：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendSMS</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">fire</span><span class="params">($job, $data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $twilio = <span class="keyword">new</span> Twilio_SMS($apiKey);</span><br><span class="line">        $twilio-&gt;sendTextMessage(<span class="keyword">array</span>(</span><br><span class="line">            <span class="string">'to'</span>=&gt; $data[<span class="string">'user'</span>][<span class="string">'phone_number'</span>],</span><br><span class="line">            <span class="string">'message'</span>=&gt; $data[<span class="string">'message'</span>],</span><br><span class="line">        ));</span><br><span class="line">        $user = User::find($data[<span class="string">'user'</span>][<span class="string">'id'</span>]);</span><br><span class="line">        $user-&gt;messages()-&gt;create(<span class="keyword">array</span>(</span><br><span class="line">            <span class="string">'to'</span>=&gt; $data[<span class="string">'user'</span>][<span class="string">'phone_number'</span>],</span><br><span class="line">            <span class="string">'message'</span>=&gt; $data[<span class="string">'message'</span>],</span><br><span class="line">        ));</span><br><span class="line">        $job-&gt;delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单审查下这个类，你可能会发现一些问题。首先，它难以测试。在<code>fire</code>方法里直接使用了<code>Twilio_SMS</code>类，意味着我们没法注入一个模拟的服务（译者注：即一旦测试则必须发送一条真实的短信）。第二，我们直接使用了Eloquent，导致在测试时肯定会对数据库造成影响。第三，我们没法在队列外面发送短信，想在队列外面发还要重写一遍代码。也就是说我们的短信发送逻辑和Laravel的队列耦合太多了。</p><p>将里面的逻辑抽出成为一个单独的“服务”类，我们即可将短信发送逻辑和Laravel的队列解耦。这样我们就可以在应用的任何位置发送短信了。我们将其解耦的过程，也令其变得更易于测试。</p><p>那么我们来稍微改一改：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Eloquent</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Send the User an SMS message</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * [<span class="doctag">@param</span>](https://my.oschina.net/u/2303379) SmsCourierInterface $courier</span></span><br><span class="line"><span class="comment">     * [<span class="doctag">@param</span>](https://my.oschina.net/u/2303379) string $message</span></span><br><span class="line"><span class="comment">     * [<span class="doctag">@return</span>](https://my.oschina.net/u/556800) SmsMessage</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sendSmsMessage</span><span class="params">(SmsCourierInterface $courier, $message)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $courier-&gt;sendMessage(<span class="keyword">$this</span>-&gt;phone_number, $message);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;sms()-&gt;create(<span class="keyword">array</span>(</span><br><span class="line">            <span class="string">'to'</span>=&gt; <span class="keyword">$this</span>-&gt;phone_number,</span><br><span class="line">            <span class="string">'message'</span>=&gt; $message,</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本重构的例子中，我们将短信发送逻辑抽出到<code>User</code>模型里。同时我们将<code>SmsCourierInterface</code>的实现注入到该方法里，这样我们可以更容易对该方法进行测试。现在我们已经重构了短信发送逻辑，让我们再重写队列处理函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendSMS</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(UserRepository $users, SmsCourierInterface $courier)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;users = $users;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;courier = $courier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">fire</span><span class="params">($job, $data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $user = <span class="keyword">$this</span>-&gt;users-&gt;find($data[<span class="string">'user'</span>][<span class="string">'id'</span>]);</span><br><span class="line">        $user-&gt;sendSmsMessage(<span class="keyword">$this</span>-&gt;courier, $data[<span class="string">'message'</span>]);</span><br><span class="line">        $job-&gt;delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以看到我们重构了代码，使得队列处理函数更轻量化了。它本质上变成了队列系统和你真正的业务逻辑之间的转换层。这可是很了不起！这意味着我们可以很轻松的脱离队列系统来发送短信息。最后，让我们为短信发送逻辑写一些测试代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmsTest</span> <span class="keyword">extends</span> <span class="title">PHPUnit_Framework_TestCase</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testUserCanBeSentSmsMessages</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Arrage ...</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        $user = Mockery::mock(<span class="string">'User[sms]'</span>);</span><br><span class="line">        $relation = Mockery::mock(<span class="string">'StdClass'</span>);</span><br><span class="line">        $courier = Mockery::mock(<span class="string">'SmsCourierInterface'</span>);</span><br><span class="line">    </span><br><span class="line">        $user-&gt;shouldReceive(<span class="string">'sms'</span>)-&gt;once()-&gt;andReturn($relation);</span><br><span class="line"></span><br><span class="line">        $relation-&gt;shouldReceive(<span class="string">'create'</span>)-&gt;once()-&gt;with(<span class="keyword">array</span>(</span><br><span class="line">            <span class="string">'to'</span> =&gt; <span class="string">'555-555-5555'</span>,</span><br><span class="line">            <span class="string">'message'</span> =&gt; <span class="string">'Test'</span>,</span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">        $courier-&gt;shouldReceive(<span class="string">'sendMessage'</span>)-&gt;once()-&gt;with(</span><br><span class="line">            <span class="string">'555-555-5555'</span>, <span class="string">'Test'</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Act ...</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        $user-&gt;sms_number = <span class="string">'555-555-5555'</span>; <span class="comment">//译者注： 应当为 phone_number</span></span><br><span class="line">        $user-&gt;sendMessage($courier, <span class="string">'Test'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他处理函数"><a href="#其他处理函数" class="headerlink" title="其他处理函数"></a>其他处理函数</h4><p>使用类似的方式，我们可以改进和解耦很多其他类型的“处理函数”。将这些处理函数限制在<em>转换层</em>的状态，你可以将你庞大的业务逻辑和框架解耦，并保持整洁的代码结构。为了巩固这种思想，我们来看看一个路由过滤器。该过滤器用来验证当前用户是否是交过钱的<em>高级</em>用户套餐。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Route::filter(<span class="string">'premium'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Auth::user() &amp;&amp; Auth::user()-&gt;plan == <span class="string">'premium'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>猛一看这路由过滤器没什么问题啊。这么简单的过滤器能有什么错误？然而就是是这么小的过滤器，我们却将我们应用实现的细节暴露了出来。要注意我们在该过滤器里是写明了要检查<code>plan</code>变量。这使得将“套餐方案”在我们应用中的代表值（译者注：即<code>plan</code>变量的值）暴露在了路由/传输层里面。现在我们若想调整“高级套餐”在数据库或用户模型的代表值，我们竟然就需要改这个路由过滤器！</p><p>让我们简单改一点儿：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Route::filter(<span class="string">'premium'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Auth::user() &amp;&amp; Auth::user()-&gt;isPremium();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>小小的改变就带来巨大的效果，并且代价也很小。我们将判断用户是否使用高级套餐的逻辑放在了用户模型里，这样就从路由过滤器里去掉了对套餐判断的实现细节。我们的过滤器不再需要知道具体怎么判断用户是不是高级套餐了，它只要简单的把这个问题交给用户模型。现在如果我们想调整高级套餐在数据库里的细节，也不必再去改动路由过滤器了！</p><blockquote><h5 id="谁负责？"><a href="#谁负责？" class="headerlink" title="谁负责？"></a>谁负责？</h5><p>在这里我们又一次讨论了<em>责任</em>的概念。记住，始终保持一个类应该有什么样的责任，应该知道什么。避免在处理函数这种传输层直接编写太多你应用的业务逻辑。</p></blockquote><p>译者注：本文多次出现<em>transport layer</em>, <em>translation layer</em>，分别译作传输层和转换层。其实他们应当指代的同一种东西。</p><h2 id="扩展框架"><a href="#扩展框架" class="headerlink" title="扩展框架"></a>扩展框架</h2><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>为了方便你自定义框架核心组件，Laravel 提供了大量可以扩展的地方。你甚至可以完全替换掉旧组件。例如：哈希器遵守了<code>HasherInterface</code>接口，你可以按照你自己应用的需求来重新实现。你也可以扩展<code>Request</code>对象，添加你自己用的顺手的“helper”方法。你甚至可以添加全新的身份认证、缓存和会话机制！</p><p>Laravel组件通常有两种扩展方式：在IoC容器里面绑定新实现，或者用<code>Manager</code>类注册一个扩展，该扩展采用了工厂模式实现。 在本章中我们将探索不同的扩展方式并检查我们都需要些什么代码。</p><blockquote><h5 id="扩展方式"><a href="#扩展方式" class="headerlink" title="扩展方式"></a>扩展方式</h5><p>要记住 Laravel 通常有以下两种扩展方式：通过IoC绑定和通过<code>Manager</code>类（下文译作“管理类”）。其中管理类实现了工厂设计模式，负责组件的实例化。比如缓存和会话机制。</p></blockquote><h4 id="管理者和工厂"><a href="#管理者和工厂" class="headerlink" title="管理者和工厂"></a>管理者和工厂</h4><p>Laravel有好多<code>Manager</code>类用来管理基于驱动的组件的生成过程。基于驱动的组件包括：缓存、会话、身份认证、队列组件等。管理类负责根据应用程序的配置，来生成特定的驱动实例。比如：<code>CacheManager</code>可以创建APC、Memcached、Native、还有其他不同的缓存驱动的实现。</p><p>每个管理类都包含名为<code>extend</code>的方法，该方法可用于将新功能注入到管理类中。下面我们将逐个介绍管理类，为你展示如何注入自定义的驱动。</p><blockquote><h5 id="如何了解你的管理类"><a href="#如何了解你的管理类" class="headerlink" title="如何了解你的管理类"></a>如何了解你的管理类</h5><p>请花点时间看看Laravel中各个<code>Manager</code>类的代码，比如<code>CacheManager</code>和<code>SessionManager</code>。通过阅读这些代码能让你对Laravel的管理类机制更加清楚透彻。所有的管理类都继承自<code>Illuminate\Support\Manager</code>基类，该基类为每一个管理类提供了一些有效且通用的功能。</p></blockquote><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>要扩展 Laravel 的缓存机制，我们将使用<code>CacheManager</code>里的<code>extend</code>方法来绑定我们自定义的缓存驱动。扩展其他的管理类也是类似的。比如，我们想注册一个新的缓存驱动，名叫“mongo”，代码可以这样写：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cache::extend(<span class="string">'mongo'</span>, <span class="function"><span class="keyword">function</span><span class="params">($app)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Return Illuminate\Cache\Repository instance...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>extend</code>方法的第一个参数是你要定义的驱动的名字。该名字对应着<code>app/config/cache.php</code>配置文件中的<code>driver</code>项。第二个参数是一个匿名函数（闭包），该匿名函数有一个<code>$app</code>参数是<code>Illuminate\Foundation\Application</code>的实例也是一个IoC容器，该匿名函数要返回一个<code>Illuminate\Cache\Repository</code>的实例。</p><p>要创建我们自己的缓存驱动，首先要实现<code>Illuminate\Cache\StoreInterface</code>接口。所以我们用MongoDB来实现的缓存驱动就可能看上去是这样：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoStore</span> <span class="keyword">implements</span> <span class="title">Illuminate</span>\<span class="title">Cache</span>\<span class="title">StoreInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">($key)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">put</span><span class="params">($key, $value, $minutes)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">increment</span><span class="params">($key, $value = <span class="number">1</span>)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">decrement</span><span class="params">($key, $value = <span class="number">1</span>)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">forever</span><span class="params">($key, $value)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">forget</span><span class="params">($key)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">flush</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需使用MongoDB链接来实现上面的每一个方法即可。一旦实现完毕，就可以照下面这样完成该驱动的注册：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Cache</span>\<span class="title">Repository</span>;</span><br><span class="line">Cache::extend(<span class="string">'mongo'</span>, <span class="function"><span class="keyword">function</span><span class="params">($app)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Repository(<span class="keyword">new</span> MongoStore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以像上面的例子那样来创建<code>Illuminate\Cache\Repository</code>的实例。也就是说通常你不需要创建你自己的仓库类（Repository）。</p><p>如果你不知道要把自定义的缓存驱动代码放到哪儿，可以考虑放到Packagist里！或者你也可以在你应用的主目录下创建一个<code>Extensions</code>目录。比如，你的应用叫做<code>Snappy</code>，你可以将缓存扩展代码放到<code>app/Snappy/Extensions/MongoStore.php</code>。不过请记住Laravel没有对应用程序的结构做硬性规定，所以你可以按任意你喜欢的方式组织你的代码。</p><blockquote><h5 id="在哪儿调用Extend方法？"><a href="#在哪儿调用Extend方法？" class="headerlink" title="在哪儿调用Extend方法？"></a>在哪儿调用Extend方法？</h5><p>如果你还发愁在哪儿放注册代码，先考虑放到服务提供者里吧。我们之前就讲过，使用服务提供者是一种非常棒的管理你应用代码的途径。</p></blockquote><h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>扩展 Laravel 的会话机制和上文的缓存机制一样简单。和刚才一样，我们使用<code>extend</code>方法来注册自定义的代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Session::extend(<span class="string">'mongo'</span>, <span class="function"><span class="keyword">function</span><span class="params">($app)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Return implementation of SessionHandlerInterface</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意我们自定义的会话驱动（译者注：原文是 cache driver，应该是笔误。正确应为 session driver）实现的是<code>SessionHandlerInterface</code>接口。这个接口在 PHP 5.4 以上版本才有。但如果你用的是 PHP 5.3 也别担心，Laravel 会自动帮你定义这个接口的。该接口要实现的方法不多也不难。我们用 MongoDB 来实现就像下面这样：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoHandler</span> <span class="keyword">implements</span> <span class="title">SessionHandlerInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">open</span><span class="params">($savePath, $sessionName)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span><span class="params">($sessionId)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">write</span><span class="params">($sessionId, $data)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">destroy</span><span class="params">($sessionId)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">gc</span><span class="params">($lifetime)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些方法不像刚才的<code>StoreInterface</code>接口定义的那么容易理解。我们来挨个简单讲讲这些方法都是干啥的：</p><ul><li><code>open</code>方法一般在基于文件的会话系统中才会用到。Laravel已经自带了一个<code>native</code>的会话驱动，使用的就是PHP自带的基于文件的会话系统，你可能永远也不需要在这个方法里写东西。所以留空就好。另外这也是一个接口设计的反面教材（稍后我们会继续讨论这一点）。</li><li><code>close</code>方法和<code>open</code>方法通常都不是必需的。对大部分驱动来说都不必要实现。</li><li><code>read</code>方法应该根据<code>$sessionId</code>参数来返回对应的会话数据的字符串形式。在你的会话驱动里，不论读写都不需要做任何数据序列化工作。因为Laravel会负责数据序列化的。</li><li><code>write</code>方法应该将<code>$sessionId</code>对应的<code>$data</code>字符串放置在一个持久化存储系统中。比如MongoDB，Dynamo等等。</li><li><code>destroy</code>方法应该将<code>$sessionId</code>对应的数据从持久化存储系统中删除。</li><li><code>gc</code>方法应该将所有时间超过参数<code>$lifetime</code>的数据全都删除，该参数是一个UNIX时间戳。如果你使用的是类似Memcached或Redis这种有自主到期功能的存储系统，那该方法可以留空。</li></ul><p>一旦<code>SessionHandlerInterface</code>实现完毕，我们就可以将其注册进会话管理器：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Session::extend(<span class="string">'mongo'</span>, <span class="function"><span class="keyword">function</span><span class="params">($app)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MongoHandler;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注册完毕后，我们就可以在<code>app/config/session.php</code>配置文件里使用<code>mongo</code>驱动了。</p><blockquote><h5 id="分享你的知识"><a href="#分享你的知识" class="headerlink" title="分享你的知识"></a>分享你的知识</h5><p>你要是写了个自定义的会话处理器，别忘了在 Packagist 上分享啊！</p></blockquote><h4 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h4><p>身份认证模块的扩展方式和缓存与会话的扩展方式一样：使用我们熟悉的<code>extend</code>方法就可以进行扩展：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Auth::extend(<span class="string">'riak'</span>, <span class="function"><span class="keyword">function</span><span class="params">($app)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Return implementation of Illuminate\Auth\UserProviderInterface</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接口<code>UserProviderInterface</code>负责从各种持久化存储系统——如MySQL，Riak等——中获取数据，然后得到接口<code>UserInterface</code>的实现对象。有了这两个接口，Laravel的身份认证机制就可以不用管用户数据是如何储存的、究竟哪个类来代表用户对象这种事儿，从而继续专注于身份认证本身的实现。</p><p>咱们来看一看<code>UserProviderInterface</code>接口的代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserProviderInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">retrieveById</span><span class="params">($identifier)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">retrieveByCredentials</span><span class="params">(array $credentials)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">validateCredentials</span><span class="params">(UserInterface $user, array $credentials)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法<code>retrieveById</code>通常接受一个数字参数用来表示一个用户，比如MySQL数据库的自增ID。该方法要找到匹配该ID的<code>UserInterface</code>的实现对象，并且将该对象返回。</p><p><code>retrieveByCredentials</code>方法接受一个参数作为登录帐号。该参数是在尝试登录系统时从<code>Auth::attempt</code>方法传来的。那么该方法应该“查询”底层的持久化存储系统，来找到那些匹配到该帐号的用户。通常该方法会执行一个带有“where”条件的查询来匹配参数里的<code>$credentials[&#39;username&#39;]</code>。<strong>该方法不应该做任何密码验证。</strong></p><p><code>validateCredentials</code>方法会通过比较<code>$user</code>参数和<code>$credentials</code>参数来检测用户是否通过认证。比如，该方法会调用<code>$user-&gt;getAuthPassword();</code>方法，将得到的字符串与<code>$credentials[&#39;password&#39;]</code>经过<code>Hash::make</code>处理后的结果进行比对。</p><p>现在我们探索了<code>UserProviderInterface</code>接口的每一个方法，接下来咱们看一看<code>UserInterface</code>接口。别忘了<code>UserInterface</code>的实例应当是<code>retrieveById</code>和<code>retrieveByCredentials</code>方法的返回值：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getAuthIdentifier</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getAuthPassword</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口很简单。 <code>getAuthIdentifier</code>方法应当返回用户的“主键”。就像刚才提到的，在MySQL中可能就是自增主键了。<code>getAuthPassword</code>方法应当返回经过散列处理的用户密码。有了这个接口，身份认证系统就可以不用关心用户类到底使用了什么ORM或者什么存储方式。Laravel已经在<code>app/models</code>目录下，包含了一个默认的<code>User</code>类且实现了该接口。所以你可以参考这个类当例子。</p><p>当我们最后实现了<code>UserProviderInterface</code>接口后，我们可以将该扩展注册进<code>Auth</code>里面：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Auth::extend(<span class="string">'riak'</span>, <span class="function"><span class="keyword">function</span><span class="params">($app)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RiakUserProvider($app[<span class="string">'riak.connection'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用<code>extend</code>方法注册好驱动以后，你就可以在<code>app/config/auth.php</code>配置文件里面切换到新的驱动了。</p><h4 id="使用容器进行扩展"><a href="#使用容器进行扩展" class="headerlink" title="使用容器进行扩展"></a>使用容器进行扩展</h4><p>Laravel框架内几乎所有的服务提供者都会绑定一些对象到IoC容器里。你可以在<code>app/config/app.php</code>文件里找到服务提供者列表。如果你有时间的话，你应该大致过一遍每个服务提供者的源码。这么做你便可以对每个服务提供者有更深的理解，明白他们都往框架里加了什么东西，对应的什么键。那些键就用来联系着各种各样的服务。</p><p>举个例子，<code>PaginationServiceProvider</code>向容器内绑定了一个<code>paginator</code>键，对应着一个<code>Illuminate\Pagination\Environment</code>的实例。你可以很容易的通过覆盖容器绑定来扩展重写该类。比如，你可以创建一个扩展自<code>Environment</code>类的子类：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Snappy</span>\<span class="title">Extensions</span>\<span class="title">Pagination</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Environment</span> <span class="keyword">extends</span> \<span class="title">Illuminate</span>\<span class="title">Pagination</span>\<span class="title">Environment</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类写好以后，你可以再创建个新的<code>SnappyPaginationProvider</code>服务提供者来扩展其<code>boot</code>方法，在里面覆盖 paginator：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnappyPaginationProvider</span> <span class="keyword">extends</span> <span class="title">PaginationServiceProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">boot</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        App::bind(<span class="string">'paginator'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Snappy\Extensions\Pagination\Environment;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">parent</span>::boot();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里我们继承了<code>PaginationServiceProvider</code>，而非默认的基类<code>ServiceProvider</code>。扩展的服务提供者编写完毕后，就可以在<code>app/config/app.php</code>文件里将<code>PaginationServiceProvider</code>替换为你刚扩展的那个类了。</p><p>这就是扩展绑定进容器的核心类的一般方法。基本上每一个核心类都以这种方式绑定进了容器，都可以被重写。还是那一句话，读一遍框架内的服务提供者源码吧。这有助于你熟悉各种类是怎么绑定进容器的，都绑定的是哪些键。这是学习Laravel框架到底如何运转的好方法。</p><h4 id="请求的扩展"><a href="#请求的扩展" class="headerlink" title="请求的扩展"></a>请求的扩展</h4><p>由于这玩意儿是框架里面非常基础的部分，并且在请求流程中很早就被实例化，所以要扩展<code>Request</code>类的方法与之前相比是有些许不同的。</p><p>首先还是要写个子类：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">QuickBill</span>\<span class="title">Extensions</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span> <span class="keyword">extends</span> \<span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Custom, helpful methods here...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类写好后，打开<code>bootstrap/start.php</code>文件。该文件是应用的请求流程中最早被载入的几个文件之一。要注意被执行的第一个动作是创建Laravel的<code>$app</code>实例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$app = <span class="keyword">new</span> \Illuminate\Foundation\Application;</span><br></pre></td></tr></table></figure><p>当新的应用实例创建后，它将会创建一个<code>Illuminate\Http\Request</code>的实例并且将其绑定到IoC容器里，键名为<code>request</code>。所以我们需要找个方法来将一个自定义的类指定为“默认的”请求类，对不对？而且幸运的是，应用实例有一个名为<code>requestClass</code>的方法就是用来干这事儿的！所以我们只需要在<code>bootstrap/start.php</code>文件最上面加一行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Foundation</span>\<span class="title">Application</span>;</span><br><span class="line">Application::requestClass(<span class="string">'QuickBill\Extensions\Request'</span>);</span><br></pre></td></tr></table></figure><p>一旦你指定了自定义的请求类，Laravel 将在任何时候都可以使用这个<code>Request</code>类的实例。并使你很方便的能随时访问到它，甚至单元测试也不例外！</p><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>罗伯特“鲍勃叔叔”马丁阐述了名为“坚实”的一些设计原则（译者注：看下面五个原则的首字母正是 SOLID）。这些都是制作完善的程序设计的优秀基础，一共有五个原则：</p><ul><li>单一职责原则</li><li>开放封闭原则</li><li>里氏替换原则</li><li>接口隔离原则</li><li>依赖反转原则</li></ul><p>让我们深入探索一下，再看点代码样例来说明各个原则。我们将看到，每个原则之间都有联系。如果其中一个原则没有被遵循，那么其他大部分（可能不会是全部）的原则也会出问题。</p><h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><p>单一职责原则规定一个类有且仅有一个理由使其改变。换句话说，一个类的功能边界和职责应当是十分狭窄且集中的。我们之前就提到过，在类的职责问题上，无知是福。一个类应当做它该做的事儿，并且不应当被它的依赖的任何变化所影响到。</p><p>考虑下列类：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(BillerInterface $biller)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;biller = $biller;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span><span class="params">(Order $order)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $recent = <span class="keyword">$this</span>-&gt;getRecentOrderCount($order);</span><br><span class="line">        <span class="keyword">if</span>($recent &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">'Duplicate order likely.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">$this</span>-&gt;biller-&gt;bill($order-&gt;account-&gt;id, $order-&gt;amount);</span><br><span class="line">        </span><br><span class="line">        DB::table(<span class="string">'orders'</span>)-&gt;insert(<span class="keyword">array</span>(</span><br><span class="line">            <span class="string">'account'</span>    =&gt;    $order-&gt;account-&gt;id,</span><br><span class="line">            <span class="string">'amount'</span>    =&gt;    $order-&gt;amount,</span><br><span class="line">            <span class="string">'created_at'</span>=&gt;    Carbon::now()</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getRecentOrderCount</span><span class="params">(Order $order)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $timestamp = Carbon::now()-&gt;subMinutes(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> DB::table(<span class="string">'orders'</span>)-&gt;where(<span class="string">'account'</span>, $order-&gt;account-&gt;id)</span><br><span class="line">                                                -&gt;where(<span class="string">'created_at'</span>, <span class="string">'&gt;='</span>, $timestamps)</span><br><span class="line">                                                -&gt;count();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个类的职责是什么？很显然顾名思义，它是用来处理订单的。不过由于<code>getRecentOrderCount</code>这个方法的存在，这个类就有了在数据库中审查某帐号订单历史来看有没有重复订单的职责。这个额外的验证职责意味着当我们的存储方式改变或当订单验证规则改变时，我们的这个订单处理器也要跟着改变。</p><p>我们必须将这个职责抽离出来放到另外的类里面，比如放到<code>OrderRepository</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderRepository</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getRecentOrderCount</span><span class="params">(Account $account)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $timestamp = Carbon::now()-&gt;subMinutes(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> DB::table(<span class="string">'orders'</span>)-&gt;where(<span class="string">'account'</span>, $account-&gt;id)</span><br><span class="line">                                                -&gt;where(<span class="string">'created_at'</span>, <span class="string">'&gt;='</span>, $timestamp)</span><br><span class="line">                                                -&gt;count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">logOrder</span><span class="params">(Order $order)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DB::table(<span class="string">'orders'</span>)-&gt;insert(<span class="keyword">array</span>(</span><br><span class="line">            <span class="string">'account'</span>    =&gt;    $order-&gt;account-&gt;id,</span><br><span class="line">            <span class="string">'amount'</span>    =&gt;    $order-&gt;amount,</span><br><span class="line">            <span class="string">'created_at'</span>=&gt;    Carbon::now()</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以将我们的资料库（译者注：OrderRepository ）注入到<code>OrderProcessor</code>里，帮后者承担起对账户订单历史的处理责任：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(BillerInterface $biller, OrderRepository $orders)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;biller = $biller;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;orders = $orders;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span><span class="params">(Order $order)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $recent = <span class="keyword">$this</span>-&gt;orders-&gt;getRecentOrderCount($order-&gt;account);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>($recent &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">'Duplicate order likely.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;biller-&gt;bill($order-&gt;account-&gt;id, $order-&gt;amount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;orders-&gt;logOrder($order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们提取出了收集订单数据的责任，当读取和写入订单的方式改变时，我们不再需要修改<code>OrderProcessor</code>这个类了。我们的类的职责更加的专注和精确，这提供了一个更干净、更有表现力的代码，同时也是更容易维护的代码。</p><p>请记住，单一职责原则的关键不仅仅是让函数变短，而是写出职责更精确更高内聚的类，所以要确保类里面所有的方法都属于该类的职责之下的。在建立一个小巧、清晰且职责明确的类库以后，我们的代码会更加解耦，更容易测试，并且更易于更改。</p><h2 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h2><h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>在一个应用的生命周期里，大部分时间都花在了向现有代码库增加功能，而非一直从零开始写新功能。正像你所想的那样，这会是一个繁琐且令人痛苦的过程。当你修改代码的时候，你可能引入新的程序错误，或者将原来管用的功能搞坏掉。理想情况下，我们应该可以像写全新的代码一样，来快速且简单的修改现有的代码。只要采用开放封闭原则来正确的设计我们的应用程序，那么这是可以做到的！</p><blockquote><h5 id="开放封闭原则-1"><a href="#开放封闭原则-1" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h5><p>开放封闭原则规定代码对扩展是开放的，对修改是封闭的。</p></blockquote><h4 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h4><p>为了演示开放封闭原则，我们来继续编写上一章节的<code>OrderProcecssor</code>。考虑下面的<code>process</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$recent = <span class="keyword">$this</span>-&gt;orders-&gt;getRecentOrderCount($order-&gt;account);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($recent &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">'Duplicate order likely.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码可读性很高，且因为我们使用了依赖注入，变得很容易测试。然而，如果我们判断订单的规则改变了呢？如果我们又有新的规则了呢？更进一步，如果随着我们的业务发展，要增加<em>一大堆</em>新规则呢？那我们的<code>process</code>方法会很快变成一坨难以维护的浆糊。因为这段代码必须随着每次业务逻辑的改变而跟着改变，它对修改是开放的，这违反了开放封闭原则。记住，我们希望代码对<em>扩展</em>开放，而不是修改。</p><p>不必再把订单验证直接写在<code>process</code>方法里面，我们来定义一个新的接口：<code>OrderValidator</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OrderValidatorInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">validate</span><span class="params">(Order $order)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步我们来定义一个实现接口的类，来预防重复订单：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecentOrderValidator</span> <span class="keyword">implements</span> <span class="title">OrderValidatorInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(OrderRepository $orders)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;orders = $orders;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">validate</span><span class="params">(Order $order)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $recent = <span class="keyword">$this</span>-&gt;orders-&gt;getRecentOrderCount($order-&gt;account);</span><br><span class="line">        <span class="keyword">if</span>($recent &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">'Duplicate order likely.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很好！我们封装了一个小巧的、可测试的单一业务逻辑。咱们来再创建一个来验证账号是否停用吧：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuspendedAccountValidator</span> <span class="keyword">implements</span> <span class="title">OrderValidatorInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">validate</span><span class="params">(Order $order)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>($order-&gt;account-&gt;isSuspended())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">"Suspended accounts may not order."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们有两个不同的类实现了<code>OrderValidatorInterface</code>接口。咱们将在<code>OrderProcessor</code>里面使用它们。我们只需简单的将一个验证器数组注入进订单处理器实例中。这将使我们以后修改代码时能轻松的添加和删除验证器规则。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(BillerInterface $biller, OrderRepository $orders, array $validators = array<span class="params">()</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;biller = $bller;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;orders = $orders;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;validators = $validators;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们只要在<code>process</code>方法里面循环这个验证器数组即可：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span><span class="params">(Order $order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="keyword">$this</span>-&gt;validators <span class="keyword">as</span> $validator)</span><br><span class="line">    &#123;</span><br><span class="line">        $validator-&gt;validate($order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process valid order...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们在 IoC 容器里面注册<code>OrderProcessor</code>类：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">App::bind(<span class="string">'OrderProcessor'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OrderProcessor(</span><br><span class="line">        App::make(<span class="string">'BillerInterface'</span>),</span><br><span class="line">        App::make(<span class="string">'OrderRepository'</span>),</span><br><span class="line">        <span class="keyword">array</span>(</span><br><span class="line">            App::make(<span class="string">'RecentOrderValidator'</span>),</span><br><span class="line">            App::make(<span class="string">'SuspendedAccountValidator'</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在现有代码里付出些小努力，做一些小改动之后，我们现在可以添加删除新的验证规则而不必修改任何一行现有代码了。每一个新的验证规则就是对<code>OrderValidatorInterface</code>的一个实现类，然后注册进IoC容器里。不必再为那个又大又笨的<code>process</code>方法做单元测试了，我们现在可以单独测试每一个验证规则。现在，我们的代码对扩展是<em>开放</em>的，对修改是<em>封闭</em>的。</p><blockquote><h5 id="抽象的漏洞"><a href="#抽象的漏洞" class="headerlink" title="抽象的漏洞"></a>抽象的漏洞</h5><p>小心那些缺少实现细节的依赖（译者注：比如上面的RecentOrderValidator）。当一个依赖的实现需要改变时，不应该要求它的调用者做任何修改。当需要调用者进行修改时，这就意味着该依赖<em>遗漏</em>了一些实现的细节。当你的抽象有漏洞的话，开放封闭原则就不管用了。</p></blockquote><p>在我们继续学习前，要记住这些原则不是法律。这不是说你应用中每一块代码都应该是“热插拔”式的。例如，一个仅仅从MySQL检索几条记录的小应用程序，不值得去严格遵守每一条你想到的设计原则。不要盲目的应用设计原则，那样你会造出一个“过度设计”的繁琐的系统。记住这些设计原则是用来解决通用的架构问题，制造大型容错能力强的应用。我就这么一说，你可别把它当作懒惰的借口！</p><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><h4 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h4><p>别担心，里氏替换原则读起来吓人学起来简单。该原则要求：一个抽象的任意一个实现，可以被用在任何需要该抽象的地方。读起来绕口，用普通人的话来解释一下。该原则规定：如果某处代码使用了一个接口的一个实现类，那么在这里也可以直接使用该接口的任何其他实现类，不用做出任何修改。</p><blockquote><h5 id="里氏替换原则-1"><a href="#里氏替换原则-1" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h5><p>该原则规定对象应该可以被该对象子类的实例所替换，并且不会影响到程序的正确性。</p></blockquote><h4 id="实践-2"><a href="#实践-2" class="headerlink" title="实践"></a>实践</h4><p>为了说明该原则，我们继续编写上一章节的<code>OrderProcessor</code>。看下面的方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span><span class="params">(Order $order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Validate order...</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;orders-&gt;logOrder($order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意当我们的<code>Order</code>通过了验证，就被<code>OrderRepositoryInterface</code>的实现对象存储起来了。假设当我们的业务刚起步时，我们将订单存储在CSV格式的文件系统中。我们的<code>OrderRepositoryInterface</code>的实现类是<code>CsvOrderRepository</code>。现在，随着我们订单增多，我们想用一个关系数据库来存储订单。那么我们来看看新的订单资料库类该怎么编写吧：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseOrderRepository</span> <span class="keyword">implements</span> <span class="title">OrderRepositoryInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $connection;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">($username, $password)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;connection = <span class="keyword">new</span> DatabaseConnection($username, $password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">logOrder</span><span class="params">(Order $order)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;connection-&gt;run(<span class="string">'insert into orders values (?, ?)'</span>, <span class="keyword">array</span>(</span><br><span class="line">            $order-&gt;id, $order-&gt;amount</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们来研究如何使用这个实现类：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span><span class="params">(Order $order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Validate order...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;repository <span class="keyword">instanceof</span> DatabaseOrderRepository)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;repository-&gt;connect(<span class="string">'root'</span>, <span class="string">'password'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;repository-&gt;logOrder($order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在这段代码中，我们必须在资料库外部检查<code>OrderRepositoryInterface</code>的实例对象是不是用数据库实现的。如果是的话，则必须先连接数据库。在很小的应用中这可能不算什么问题，但如果<code>OrderRepositoryInterface</code>被几十个类调用呢？我们可能就要把这段“启动”代码在每一个调用的地方复制一遍又一遍。这让人非常头疼难以维护，非常容易出错误。一旦我们忘了将所有调用的地方进行同步修改，那程序恐怕就会出问题。</p><p>很明显，上面的例子没有遵循里氏替换原则。如果不附加“启动”代码来调用<code>connect</code>方法，则这段代码就没法用。好了，我们已经找到问题所在，咱们修好他。下面就是新的<code>DatabaseOrderRepository</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseOrderRepository</span> <span class="keyword">implements</span> <span class="title">OrderRepositoryInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $connector;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(DatabaseConnector $connector)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;connector = $connector;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;connector-&gt;bootConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">logOrder</span><span class="params">(Order $order)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $connection = <span class="keyword">$this</span>-&gt;connect();</span><br><span class="line">        $connection-&gt;run(<span class="string">'insert into orders values (?, ?)'</span>, <span class="keyword">array</span>(</span><br><span class="line">            $order-&gt;id, $order-&gt;amount</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在<code>DatabaseOrderRepository</code>掌管了数据库连接，我们可以把“启动”代码从<code>OrderProcessor</code>移除了：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span><span class="params">(Order $order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Validate order...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">$this</span>-&gt;repository-&gt;logOrder($order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一改，我们就可以想用<code>CsvOrderRepository</code>也行，想用<code>DatabaseOrderRepository</code>也行，不用改<code>OrderProcessor</code>一行代码。我们的代码终于实现了里氏替换原则！要注意，我们讨论过的许多架构概念都和<em>知识</em>相关。具体讲，知识就是一个类和它所具有的<em>周边领域</em>，比如用来帮助类完成任务的外围代码和依赖。当你要制作一个容错性强大的应用架构时，限制类的<em>知识</em>是一种常用且重要的手段。</p><p>还要注意如果不遵守里氏替换原则，那后果可能会影响到我们之前已经讨论过的其他原则。不遵守里氏替换原则，那么开放封闭原则一定也会被打破。因为，如果调用者必须检查实例属于哪个子类的，那一旦有个新的子类，调用者就得做出改变。（译者注：这就违背了对修改封闭的原则。）</p><blockquote><h5 id="小心遗漏"><a href="#小心遗漏" class="headerlink" title="小心遗漏"></a>小心遗漏</h5><p>你可能注意到这个原则和上一章节提到的“抽象的漏洞”密切相关。我们的数据库资料库的抽象漏洞就是没有遵守里氏替换原则的第一迹象。要留意那些漏洞！</p></blockquote><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><h4 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h4><p>接口隔离原则规定在实现接口的时候，不能强迫去实现没有用处的方法。你是否曾被迫去实现一些接口里你用不到的方法？如果答案是肯定的，那你可能创建了一个空方法放在那里。被迫去实现用不到的函数，这就是一个违背了接口隔离原则的例子。</p><p>在实际操作中，该原则要求接口必须粒度很细，且专注于一个领域。听起来很耳熟？记住，所有五个“坚实”原则都是相关的，也就是说当打破一个原则时，你通常肯定打破了其他的原则。在这里当你违背了接口隔离原则后，肯定也违背了单一职责原则。</p><p>“臃肿”的接口，有着很多不是所有的实现类都需要的方法。与其写这样的接口，不如将其拆分成多个小巧的接口，里面的方法都是各自领域所需要的。这样将臃肿接口拆成小巧、功能集中的接口后，我们就可以使用小接口来编码，而不必为我们不需要的功能买单。</p><blockquote><h5 id="接口隔离原则-1"><a href="#接口隔离原则-1" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h5><p>该原则规定，一个接口的一个实现类，不应该去实现那些自己用不到的方法。如果需要，那就是接口设计有问题，违背了接口隔离原则。</p></blockquote><h4 id="实践-3"><a href="#实践-3" class="headerlink" title="实践"></a>实践</h4><p>为了说明该原则，我们来思考一个关于会话处理的类库。实际上我们将要考察 PHP 自己的<code>SessionHandlerInterface</code>。下面是该接口定义的方法，他们是从 PHP 5.4 版才开始有的：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SessionHandlerInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">destroy</span><span class="params">($sessionId)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">gc</span><span class="params">($maxLifetime)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">open</span><span class="params">($savePath, $name)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span><span class="params">($sesssionId)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">write</span><span class="params">($sessionId, $sessionData)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们知道接口里面都是什么方法了，我们打算用Memcached来实现它。Memcached需要实现这个接口里的所有方法么？不，里面一半的方法对于Memcached来说都是不需要实现的！</p><p>因为Memcached会自动清除存储的过期数据，我们不需要实现<code>gc</code>方法。我们也不需要实现<code>open</code>和<code>close</code>方法。所以我们被迫去写空方法来站着位子。为了解决在这个问题，我们来定义一个小巧的专门用来垃圾回收的接口：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GarbageCollectorInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">gc</span><span class="params">($maxLifetime)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们有了一个小巧的接口，功能单一而专注。需要垃圾清理的只用依赖这个接口即可，而不必去依赖整个会话处理。</p><p>为了更深入理解该原则，我们用另一个例子来强化理解。想象我们有一个名为<code>Contact</code>的Eloquent类，定义成这样：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contact</span> <span class="keyword">extends</span> <span class="title">Eloquent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getNameAttribute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;attributes[<span class="string">'name'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getEmailAttribute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;attributes[<span class="string">'email'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们再假设我们应用里还有一个叫<code>PasswordReminder</code>的类来负责给用户发送密码找回邮件。下面是<code>PasswordReminder</code>的定义方式的一种：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PasswordReminder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">remind</span><span class="params">(Contact $contact, $view)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Send password reminder e-mail...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能注意到了，<code>PasswordReminder</code>依赖着<code>Contact</code>类，也就是依赖着Eloquent ORM。 对于一个密码找回系统来说，依赖着一个特定的ORM实在是没必要，也是不可取的。切断对该ORM的依赖，我们就可以自由的改变我们后台存储机制或者说ORM，同时不会影响到我们的密码找回组件。重申一遍，违背了“坚实”原则的任何一条，就意味着有个类它<em>知道的</em>太多了。</p><p>要切断这种依赖，我们来创建一个<code>RemindableInterface</code>接口。事实上Laravel已经有了这个接口，并且默认由<code>User</code>模型实现了该接口：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">RemindableInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getReminderEmail</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦接口定义好了，我们就可以在模型上实现它：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contact</span> <span class="keyword">extends</span> <span class="title">Eloquent</span> <span class="keyword">implements</span> <span class="title">RemindableInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getReminderEmail</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终我们可以在<code>PasswordReminder</code>里面依赖这样一个小巧且专注的接口了：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PasswordReminder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">remind</span><span class="params">(RemindableInterface $remindable, $view)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Send password reminder e-mail...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这小小的改动，我们已经移除了密码找回组件里不必要的依赖，并且使它足够灵活能使用任何实现了<code>RemindableInterface</code>的类或ORM。这其实正是Laravel的密码找回组件如何保持与数据库ORM无关的秘诀！</p><blockquote><h5 id="知识就是力量"><a href="#知识就是力量" class="headerlink" title="知识就是力量"></a>知识就是力量</h5><p>我们再次发现了一个使类知道太多东西的陷阱。通过小心留意是否让一个类知道了太多，我们就可以遵守所有的“坚实”原则。</p></blockquote><h2 id="依赖反转原则"><a href="#依赖反转原则" class="headerlink" title="依赖反转原则"></a>依赖反转原则</h2><h4 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h4><p>在整个“坚实”原则概述的旅途中，我们到达最后一站了！最后的原则是依赖反转原则，它规定高等级的代码不应该依赖（迁就）低等级的代码。首先，高等级的代码应该依赖（遵从）着抽象层，抽象层就像是“中间人”一样，负责连接着高等级和低等级的代码。其次，抽象定义不应该依赖（迁就）着具体实现，但具体实现应该依赖（遵从）着抽象定义。如果这些东西让你极端困惑，别担心。接下来我们会将这两方面统统介绍给你。</p><blockquote><h5 id="依赖反转原则-1"><a href="#依赖反转原则-1" class="headerlink" title="依赖反转原则"></a>依赖反转原则</h5><p>该原则要求高等级代码不应该迁就低等级代码，抽象定义不应该迁就具体实现。</p></blockquote><h4 id="实践-4"><a href="#实践-4" class="headerlink" title="实践"></a>实践</h4><p>如果你已经读过了本书前面几个章节，你就已经很好掌握了依赖反转原则！为了说明本原则，让我们考虑下面这个类：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Authenticator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(DatabaseConnection $db)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;db = $db;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">findUser</span><span class="params">($id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;db-&gt;exec(<span class="string">'select * from users where id = ?'</span>, <span class="keyword">array</span>($id));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">authenticate</span><span class="params">($credentials)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Authenticate the user...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能猜到了，<code>Authenticator</code>就是用来查找和验证用户的。继续研究它的构造函数。我们发现它使用了类型提示，要求传入一个<code>DatabaseConnection</code>对象，所以该验证类和数据库被紧密的联系在一起。而且基本上讲，这个数据库还只能是关系数据库。从而可知，我们的高级代码（<code>Authenticator</code>）直接的依赖着低级代码（<code>DatabaseConnection</code>）。</p><p>首先我们来谈谈“高级代码”和“低级代码”。低级代码用于实现基本的操作，比如从磁盘读文件，操作数据库等。高级代码用于封装复杂的逻辑，它们依靠低级代码来达到功能目的，但不能直接和低级代码耦合在一起。取而代之的是高级代码应该依赖着低级代码的顶层抽象，比如接口。不仅如此，低级代码<em>也</em>应当依赖着抽象。 所以我们来写个<code>Authenticator</code>可以用的接口：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserProviderInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">find</span><span class="params">($id)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">findByUsername</span><span class="params">($username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们将该接口注入到<code>Authenticator</code>里面：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Authenticator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(UserProviderInterface $users, HasherInterface $hash)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;hash = $hash;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;users = $users;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">findUser</span><span class="params">($id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;users-&gt;find($id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">authenticate</span><span class="params">($credentials)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $user = <span class="keyword">$this</span>-&gt;users-&gt;findByUsername($credentials[<span class="string">'username'</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;hash-&gt;make($credentials[<span class="string">'password'</span>]) == $user-&gt;password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做了这些小改动后，<code>Authenticator</code>现在依赖于两个高级抽象：<code>UserProviderInterface</code>和<code>HasherInterface</code>。我们可以向<code>Authenticator</code>自由的注入这俩接口的任何实现类。比如，如果我们的用户存储在Redis里面，我们只需写一个<code>RedisUserProvider</code>来实现<code>UserProviderInterface</code>接口即可。<code>Authenticator</code>不再依赖着具体的低级别的存储操作了。</p><p>此外，由于我们的低级别代码实现了<code>UserProviderInterface</code>接口，则我们说该低级代码依赖着这个接口。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisUserProvider</span> <span class="keyword">implements</span> <span class="title">UserProviderInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(RedisConnection $redis)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;redis = $redis;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">find</span><span class="params">($id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;redis-&gt;get(<span class="string">'users:'</span>.$id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">findByUsername</span><span class="params">($username)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $id = <span class="keyword">$this</span>-&gt;redis-&gt;get(<span class="string">'user:id:'</span>.$username);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;find($id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="反转的思维"><a href="#反转的思维" class="headerlink" title="反转的思维"></a>反转的思维</h5><p>贯彻这一原则会<em>反转</em>好多开发者设计应用的方式。不再将高级代码直接和低级代码以“自上而下”的方式耦合在一起，这个原则提出<strong>无论</strong>高级还是低级代码都要依赖于一个高层次的抽象。</p></blockquote><p>在我们没有<em>反转</em><code>Authenticator</code>的依赖之前，它除了使用数据库存储系统别无选择。如果我们改变了存储系统，<code>Authenticator</code>也需要被修改，这就违背了开放封闭原则。我们又一次看到，这些设计原则通常一荣俱荣一损俱损。</p><p>通过强制让<code>Authenticator</code>依赖着一个存储抽象层，我们就可以使用任何实现了<code>UserProviderInterface</code>接口的存储系统，且不用对<code>Authenticator</code>本身做任何修改。传统的依赖关系链已经被<strong>反转</strong>了，代码变得更灵活，更加无惧变化！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;依赖注入&quot;&gt;&lt;a href=&quot;#依赖注入&quot; class=&quot;headerlink&quot; title=&quot;依赖注入&quot;&gt;&lt;/a&gt;依赖注入&lt;/h2&gt;&lt;h4 id=&quot;遇到的问题&quot;&gt;&lt;a href=&quot;#遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;遇到的问题&quot;&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Leetcode-771</title>
    <link href="https://wang-zc.github.io/2019/03/24/Leetcode-771/"/>
    <id>https://wang-zc.github.io/2019/03/24/Leetcode-771/</id>
    <published>2019-03-24T09:45:57.000Z</published>
    <updated>2019-03-24T09:46:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>做了一道Leetcode的题目热热身</p><p>题目：</p><blockquote><p>给定字符串<code>J</code> 代表石头中宝石的类型，和字符串 <code>S</code>代表你拥有的石头。 <code>S</code> 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p><p><code>J</code> 中的字母不重复，<code>J</code> 和 <code>S</code>中的所有字符都是字母。字母区分大小写，因此<code>&quot;a&quot;</code>和<code>&quot;A&quot;</code>是不同类型的石头。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J = &quot;z&quot;, S = &quot;ZZ&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><p><code>S</code> 和 <code>J</code> 最多含有50个字母。</p><p> <code>J</code> 中的字符不重复。</p></blockquote><p>然后给出解答</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> String $J</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> String $S</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">numJewelsInStones</span><span class="params">($J, $S)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        $count = <span class="number">0</span>;</span><br><span class="line">        $stones = <span class="keyword">$this</span>-&gt;explodeList($S);</span><br><span class="line">        $jewel = <span class="keyword">$this</span>-&gt;explodeList($J);</span><br><span class="line">        <span class="keyword">foreach</span> ($stones <span class="keyword">as</span> $item) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in_array($item, $jewel, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                $count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> $count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">explodeList</span><span class="params">($string)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!is_string($string)) &#123;</span><br><span class="line">            <span class="keyword">return</span> [];</span><br><span class="line">        &#125;</span><br><span class="line">        $list = [];</span><br><span class="line">        $length = strlen($string);</span><br><span class="line">        <span class="keyword">if</span> ($length &gt; <span class="number">50</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $length; $i++) &#123;</span><br><span class="line">            $single = substr($string, $i, <span class="number">1</span>);</span><br><span class="line">            $list[] = $single;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> array_filter($list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;做了一道Leetcode的题目热热身&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定字符串&lt;code&gt;J&lt;/code&gt; 代表石头中宝石的类型，和字符串 &lt;code&gt;S&lt;/code&gt;代表你拥有的石头。 &lt;code&gt;S&lt;/code&gt; 中每个字符代表了一种你拥
      
    
    </summary>
    
    
    
      <category term="leetcode" scheme="https://wang-zc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>太久没有学习了</title>
    <link href="https://wang-zc.github.io/2019/03/17/%E5%A4%AA%E4%B9%85%E6%B2%A1%E6%9C%89%E5%AD%A6%E4%B9%A0%E4%BA%86/"/>
    <id>https://wang-zc.github.io/2019/03/17/太久没有学习了/</id>
    <published>2019-03-17T10:21:15.000Z</published>
    <updated>2019-03-24T09:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>太久没有学习了</p></blockquote><p>今天打开Leetcode，发现自己刷题的手都生疏了</p><p>重新刷起来</p><p>题目：</p><blockquote><p>实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;Hello&quot;</span><br><span class="line">输出: &quot;hello&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;here&quot;</span><br><span class="line">输出: &quot;here&quot;</span><br></pre></td></tr></table></figure><p><strong>示例</strong> <strong>3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;LOVELY&quot;</span><br><span class="line">输出: &quot;lovely&quot;</span><br></pre></td></tr></table></figure></blockquote><p>解答</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> String $str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">toLowerCase</span><span class="params">($str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>($str)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!is_string($str)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strtolower($str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>Leetcode</code> 终于支持了 <code>PHP</code> 之后，写这种题目的速度简直飞一样的提升。</p><p>还是需要用<code>Golang</code>重新写一遍才行。</p><p>另外<code>PHP</code>里面 <code>strtolower()</code> 是如何实现的这里没有去研究源码，留下一个<code>todo</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;太久没有学习了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天打开Leetcode，发现自己刷题的手都生疏了&lt;/p&gt;
&lt;p&gt;重新刷起来&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实现函数 ToLowerCase()，该函数接收一
      
    
    </summary>
    
    
    
      <category term="leetcode todo" scheme="https://wang-zc.github.io/tags/leetcode-todo/"/>
    
  </entry>
  
  <entry>
    <title>How to Write Go Code</title>
    <link href="https://wang-zc.github.io/2018/09/09/How-to-Write-Go-Code/"/>
    <id>https://wang-zc.github.io/2018/09/09/How-to-Write-Go-Code/</id>
    <published>2018-09-09T15:18:43.000Z</published>
    <updated>2019-01-02T01:27:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在学习郝林老师的 Go 语言专栏，自己也在从 PHP 向 Golang 的转型中，学习了 GOPATH 的概念之后发现有些懵逼<br>关于 Go 的学习也是一个愉快的过程。</p></blockquote><a id="more"></a><p>去 go 的官网上找到了一篇<a href="https://golang.org/doc/code.html" target="_blank" rel="noopener">文章</a></p><p>尝试自己进行翻译，努力前行。</p><h2 id="How-to-Write-Go-Code"><a href="#How-to-Write-Go-Code" class="headerlink" title="How to Write Go Code"></a>How to Write Go Code</h2><p>如何编写 Go 代码</p><ul><li>Introduction</li><li>Code organization<ul><li>Overview<ul><li>Workspaces</li><li>The GOPATH environment variable</li><li>Import paths</li><li>Your first program</li><li>Your first library</li><li>Package names</li></ul></li></ul></li><li>Testing</li><li>Remote packages</li><li>What’s next</li><li>Getting help</li></ul><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>This document demonstrates the development of a simple Go package and introduces the <code>go tool</code>, the standard way to fetch, build, and install Go packages and commands.</p><p>这篇文档演示了一个简单的 Go 代码包的开发，并且介绍了一种获取，创建和安装 Go 代码包和命令行的安装方法，Go Tool。</p><p>The go tool requires you to organize your code in a specific way. Please read this document carefully. It explains the simplest way to get up and running with your Go installation.</p><p>Go Tool 需要你使用一种特定的方式去写代码，请仔细阅读本文档，你将看到如何使用一种最简单的方式去安装和运行你的 Go 程序。</p><p>A similar explanation is available as a <a href="https://www.youtube.com/watch?v=XCsL89YtqCs" target="_blank" rel="noopener">screencast</a>.</p><p>可以参考链接视频中的样例。</p><h3 id="Code-organization"><a href="#Code-organization" class="headerlink" title="Code organization"></a>Code organization</h3><h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><ul><li>Go programmers typically keep all their Go code in a single workspace.</li><li>Go 编程者通常会把他们所有的 Go 代码放在一个单独的工作区中。</li><li>A workspace contains many version control repositories (managed by Git, for example).</li><li>一个工作区可以包含多个版本控制仓库（像 Git 这种）</li><li>Each repository contains one or more packages.</li><li>每一个仓库都包含一个或者多个代码包。</li><li>Each package consists of one or more Go source files in a single directory.</li><li>每个代码包都有一个目录中的一个或多个 Go 的源代码文件构成。</li><li>The path to a package’s directory determines its import path.</li><li>包的路径决定了导入路径<br>Note that this differs from other programming environments in which every project has a separate workspace and workspaces are closely tied to version control repositories.</li></ul><p>值得注意的是，这和其他的编程语言有很大的不同，其他的变成语言都是每个项目都有一个单独的工作区，而且每个工作区都和版本控制仓库紧密相关。</p><h4 id="Workspaces"><a href="#Workspaces" class="headerlink" title="Workspaces"></a>Workspaces</h4><p>A workspace is a directory hierarchy with two directories at its root:<br>一个工作区包含两个子目录</p><ul><li>src contains Go source files, and </li><li>src 目录包括 Go 的源代码文件</li><li>bin contains executable commands.</li><li><code>bin</code> 目录包含可执行文件<br>The go tool builds and installs binaries to the bin directory.<br>Go Tool 构建二进制文件并且将其安装到 <code>bin</code> 目录下</li></ul><p>The src subdirectory typically contains multiple version control repositories (such as for Git or Mercurial) that track the development of one or more source packages.<br>src 子目录中通常包含多个版本控制仓库（例如 Git 和 Mercurial ），用于跟踪一个或者多个代码包的开发。</p><p>To give you an idea of how a workspace looks in practice, here’s an example:<br>为了让你对工作区有一个直观的感受，可以参考下面的例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bin/</span><br><span class="line">    hello                          <span class="comment"># command executable</span></span><br><span class="line">    outyet                         <span class="comment"># command executable</span></span><br><span class="line">src/</span><br><span class="line">    github.com/golang/example/</span><br><span class="line">        .git/                      <span class="comment"># Git repository metadata</span></span><br><span class="line">    hello/</span><br><span class="line">        hello.go               <span class="comment"># command source</span></span><br><span class="line">    outyet/</span><br><span class="line">        main.go                <span class="comment"># command source</span></span><br><span class="line">        main_test.go           <span class="comment"># test source</span></span><br><span class="line">    stringutil/</span><br><span class="line">        reverse.go             <span class="comment"># package source</span></span><br><span class="line">        reverse_test.go        <span class="comment"># test source</span></span><br><span class="line">    golang.org/x/image/</span><br><span class="line">        .git/                      <span class="comment"># Git repository metadata</span></span><br><span class="line">    bmp/</span><br><span class="line">        reader.go              <span class="comment"># package source</span></span><br><span class="line">        writer.go              <span class="comment"># package source</span></span><br><span class="line">    ... (many more repositories and packages omitted) ...</span><br></pre></td></tr></table></figure><p>The tree above shows a workspace containing two repositories (example and image). The example repository contains two commands (hello and outyet) and one library (stringutil). The image repository contains the bmp package and several others.<br>上面的树形目录展示了一个工作区中包含了两个 Git 仓库（example 和 image），示例中的仓库中包含了两个命令（hello 和 outyet）以及一个函数库（stringutil），image 的库还包括了 bmp 包和一些其他的代码包。</p><p>A typical workspace contains many source repositories containing many packages and commands. Most Go programmers keep all their Go source code and dependencies in a single workspace.<br>一个典型的工作区包括一些源代码库，这些代码库也包含了很多代码包和命令。大部分 Go 程序员习惯把 Go 的源代码和依赖文件放在一个工作区中。</p><p>Note that symbolic links should not be used to link files or directories into your workspace.<br>值得注意的是，不能将软链接链接文件或者目录到工作区中</p><p>Commands and libraries are built from different kinds of source packages. We will discuss the distinction later.<br>命令和库是从不同的源码包构建的，我们会在后续的内容中进行讨论。</p><h4 id="The-GOPATH-environment-variable"><a href="#The-GOPATH-environment-variable" class="headerlink" title="The GOPATH environment variable"></a>The GOPATH environment variable</h4><p>The GOPATH environment variable specifies the location of your workspace. It defaults to a directory named go inside your home directory, so $HOME/go on Unix, $home/go on Plan 9, and %USERPROFILE%go (usually C:UsersYourNamego) on Windows.<br>GOPATH  环境变量指定了你的工作区位置，默认是在你的 home 目录下，在 Linux 系统中是 $HOME/go或者 $home/go，而在 Windows 中是 %USERPROFILE%go (通常是 C:UsersYourNamego)</p><p>If you would like to work in a different location, you will need to set GOPATH to the path to that directory. (Another common setup is to set GOPATH=$HOME.) Note that GOPATH must not be the same path as your Go installation.<br>如果你想要设置一个不同的工作区，你需要在将 GOPATH 设置成该目录的路径，（通常会把他设置成GOPATH=$HOME ）请注意，GOPATH 不能与 Go 安装的路径相同。</p><p>The command go env GOPATH prints the effective current GOPATH; it prints the default location if the environment variable is unset.<br>运行命令 go env GOPATH 打印当前设置的 GOPATH ; 如果未设置环境变量，它将打印默认位置。</p><p>For convenience, add the workspace’s bin subdirectory to your PATH:<br>为了方便，通常会把工作区的 bin 目录添加到环境变量中设置为 GOBIN</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:$(go env GOPATH)/bin</span><br></pre></td></tr></table></figure><p>The scripts in the rest of this document use $GOPATH instead of $(go env GOPATH) for brevity. To make the scripts run as written if you have not set GOPATH, you can substitute $HOME/go in those commands or else run:<br>为简洁起见，本文档其余部分中的脚本使用 $GOPATH而不是 $(go env GOPATH)。如果你没有设置GOPATH，要使脚本以书面形式运行，你可以在这些命令中替换 $HOME/go ，否则运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> GOPATH=$(go env GOPATH)</span><br></pre></td></tr></table></figure><p>To learn more about the GOPATH environment variable, see ‘go help gopath’.<br>如果想要学习更多的关于 GOPATH 环境变量的内容，可以查看 <code>go help gopath</code>。</p><p>To use a custom workspace location, set the GOPATH environment variable.<br>如果想要设置一个自定义的工作区目录，可以单独设置 GOPATH 的环境变量。</p><h4 id="Import-paths"><a href="#Import-paths" class="headerlink" title="Import paths"></a>Import paths</h4><p>An import path is a string that uniquely identifies a package. A package’s import path corresponds to its location inside a workspace or in a remote repository (explained below).<br>导入路径是唯一标识包的字符串。包的导入路径对应于其在工作空间内或远程仓库中的位置（如下所述）。</p><p>The packages from the standard library are given short import paths such as “fmt” and “net/http”. For your own packages, you must choose a base path that is unlikely to collide with future additions to the standard library or other external libraries.<br>标准库中导入的包具有很简短的路径，像 ”fmt” 或者 ”net/http” 包一样，但是对于开发者自己的代码包，开发者必须选择一个不会于标准库或者其他的依赖库相冲突的基础路径。</p><p>If you keep your code in a source repository somewhere, then you should use the root of that source repository as your base path. For instance, if you have a GitHub account at github.com/user, that should be your base path.<br>如果将代码保存在某个源存储库中，则应使用该源存储库的根作为基本路径。例如，如果你在 github.com/user 下面有个 GitHub 的账户，那么 github.com/user 就是你的根目录。</p><p>Note that you don’t need to publish your code to a remote repository before you can build it. It’s just a good habit to organize your code as if you will publish it someday. In practice you can choose any arbitrary path name, as long as it is unique to the standard library and greater Go ecosystem.<br>请注意，你在构建完成之前不需要将代码推送到远程仓库中去，当你推送的时候你就会知道这绝对是一个好习惯，只要对于 Go 的标准库和 Go 包含的各种第三方库来说你的代码路径是唯一的，你可以随便起名。</p><p>We’ll use github.com/user as our base path. Create a directory inside your workspace in which to keep source code:<br>我们将会把 github.com/user 当做基础路径，创建一个目录，保存我们的源代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p <span class="variable">$GOPATH</span>/src/github.com/user</span><br></pre></td></tr></table></figure><h4 id="Your-first-program"><a href="#Your-first-program" class="headerlink" title="Your first program"></a>Your first program</h4><p>To compile and run a simple program, first choose a package path (we’ll use github.com/user/hello) and create a corresponding package directory inside your workspace:<br>为了创建一个简单的程序，第一步应该选择一个代码包路径（github.com/user/hello）并且在工作区内创建相对应的包目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir <span class="variable">$GOPATH</span>/src/github.com/user/hello</span><br></pre></td></tr></table></figure><p>Next, create a file named hello.go inside that directory, containing the following Go code.<br>下一步，在里面创建一个 hello.go 的文件，包含一下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello, world."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now you can build and install that program with the go tool:<br>现在你可以通过 Go Tool 来构建和安装它了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go install github.com/user/hello</span><br></pre></td></tr></table></figure><p>Note that you can run this command from anywhere on your system. The go tool finds the source code by looking for the github.com/user/hello package inside the workspace specified by GOPATH.<br>注意，你可以在你系统的任意地方使用这个命令，Go Tool 将会通过 GOPATH 找到位于 github.com/user/hello 目录下的源代码文件。</p><p>You can also omit the package path if you run go install from the package directory:<br>如果从包目录运行go install，你也可以省略包路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/user/hello</span><br><span class="line">$ go install</span><br></pre></td></tr></table></figure><p>This command builds the hello command, producing an executable binary. It then installs that binary to the workspace’s bin directory as hello (or, under Windows, hello.exe). In our example, that will be $GOPATH/bin/hello, which is $HOME/go/bin/hello.<br>上面这行命令创建了 hello 命令，产生了一个二进制文件。把这个二进制文件放在了工作区中的 bin 目录下（在 Windows 系统下，就像是 hello.exe 这种文件一样），在我们的例子中，$GOPATH/bin/hello 就是 $HOME/go/bin/hello</p><p>The go tool will only print output when an error occurs, so if these commands produce no output they have executed successfully.<br>Go Tool 只有在错误产生的时候才会输出内容，所以如果运行命令的时候没有任何输出，这就意味着着命令是执行成功的。</p><p>You can now run the program by typing its full path at the command line:<br>你可以通过以下的命令来执行文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="variable">$GOPATH</span>/bin/hello</span><br><span class="line">Hello, world.</span><br></pre></td></tr></table></figure><p>Or, as you have added $GOPATH/bin to your PATH, just type the binary name:<br>或者在你把 $GOPATH/bin 添加到环境变量中之后，你就可以执行以名称来执行命令了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hello</span><br><span class="line">Hello, world.</span><br></pre></td></tr></table></figure><p>If you’re using a source control system, now would be a good time to initialize a repository, add the files, and commit your first change. Again, this step is optional: you do not need to use source control to write Go code.<br>如果您正在使用源代码管理系统，那么现在是初始化存储库，添加文件和提交第一个更改的好时机。当然你可以选择做或者不做：您不需要使用源代码控制来编写 Go 代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/user/hello</span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /home/user/work/src/github.com/user/hello/.git/</span><br><span class="line">$ git add hello.go</span><br><span class="line">$ git commit -m <span class="string">"initial commit"</span></span><br><span class="line">[master (root-commit) 0b4507d] initial commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 hello.go</span><br></pre></td></tr></table></figure><p>Pushing the code to a remote repository is left as an exercise for the reader.<br>把代码推送到仓库中就当做一次课下练习吧，试一试。</p><h4 id="Your-first-library"><a href="#Your-first-library" class="headerlink" title="Your first library"></a>Your first library</h4><p>Let’s write a library and use it from the hello program.<br>让我们为 hello 这个程序写一个依赖库。</p><p>Again, the first step is to choose a package path (we’ll use github.com/user/stringutil) and create the package directory:<br>同样的，第一步是选择代码包的路径（github.com/user/stringutil），创建目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir <span class="variable">$GOPATH</span>/src/github.com/user/stringutil</span><br></pre></td></tr></table></figure><p>Next, create a file named reverse.go in that directory with the following contents.<br>下一步，在目录下创建一个叫做 reverse.go 的文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package stringutil contains utility functions for working with strings.</span></span><br><span class="line"><span class="keyword">package</span> stringutil</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reverse returns its argument string reversed rune-wise left to right.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    r := []<span class="keyword">rune</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(r)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(r)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        r[i], r[j] = r[j], r[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now, test that the package compiles with go build:<br>现在，我们来测试一下我们的代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build github.com/user/stringutil</span><br></pre></td></tr></table></figure><p>Or, if you are working in the package’s source directory, just:<br>如果在代码包的目录中，可以直接运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build</span><br></pre></td></tr></table></figure><p>This won’t produce an output file. Instead it saves the compiled package in the local build cache.<br>这行命令不会产生任何输出文件，它会将编译好的包文件放在本地缓存目录中。</p><p>After confirming that the stringutil package builds, modify your original hello.go (which is in $GOPATH/src/github.com/user/hello) to use it:<br>在确认了 stringutil 构建完成之后，你可以修改 hello.go 文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/user/stringutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(stringutil.Reverse(<span class="string">"!oG ,olleH"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Install the hello program:<br>重新安装 hello</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go install github.com/user/hello</span><br></pre></td></tr></table></figure><p>Running the new version of the program, you should see a new, reversed message:<br>重新运行程序，你可以看到以下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hello</span><br><span class="line">Hello, Go!</span><br></pre></td></tr></table></figure><p>After the steps above, your workspace should look like this:<br>这一步完成后，你的工作区空间看起来应该是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bin/</span><br><span class="line">    hello                 <span class="comment"># command executable</span></span><br><span class="line">src/</span><br><span class="line">    github.com/user/</span><br><span class="line">        hello/</span><br><span class="line">            hello.go      <span class="comment"># command source</span></span><br><span class="line">        stringutil/</span><br><span class="line">            reverse.go    <span class="comment"># package source</span></span><br></pre></td></tr></table></figure><h4 id="Package-names"><a href="#Package-names" class="headerlink" title="Package names"></a>Package names</h4><p>The first statement in a Go source file must be<br>Go 源代码中的第一行语句必须是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> name</span><br></pre></td></tr></table></figure><p>where name is the package’s default name for imports. (All files in a package must use the same name.)<br>其中name是包的默认名称。 （包中的所有文件必须使用相同的名称。）</p><p>Go’s convention is that the package name is the last element of the import path: the package imported as “crypto/rot13” should be named rot13.<br>Go的约定是包名称是导入路径的最后一个元素：导入为“crypto / rot13”的包应命名为rot13。</p><p>Executable commands must always use package main.<br>可执行命令必须始终使用 package main。</p><p>There is no requirement that package names be unique across all packages linked into a single binary, only that the import paths (their full file names) be unique.<br>只要导入路径（它们的完整文件名）是唯一的， 不要求包名称在链接到单个二进制文件的所有包中都是唯一的。</p><p>See Effective Go to learn more about Go’s naming conventions.<br>请参阅Effective Go以了解有关Go的命名约定的更多信息。</p><h3 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h3><p>Go has a lightweight test framework composed of the go test command and the testing package.<br>Go有一个由 go test 命令和测试包组成的轻量级测试框架。</p><p>You write a test by creating a file with a name ending in <code>_test.go</code> that contains functions named TestXXX with signature <code>func (t *testing.T)</code>. The test framework runs each such function; if the function calls a failure function such as t.Error or t.Fail, the test is considered to have failed.<br>您通过创建名称以_test.go结尾的文件来编写测试，该文件包含名为TestXXX且带有签名func（t * testing.T）的函数。测试框架运行每个这样的功能;如果函数调用失败函数（如t.Error或t.Fail），则认为测试失败。</p><p>Add a test to the stringutil package by creating the file $GOPATH/src/github.com/user/stringutil/reverse_test.go containing the following Go code.<br>通过创建包含以下Go代码的文件 <code>$GOPATH/src/github.com/user/stringutil/reverse_test.go</code>，将测试添加到stringutil 包中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stringutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReverse</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    cases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        in, want <span class="keyword">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="string">"Hello, world"</span>, <span class="string">"dlrow ,olleH"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Hello, 世界"</span>, <span class="string">"界世 ,olleH"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">""</span>, <span class="string">""</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> cases &#123;</span><br><span class="line">        got := Reverse(c.in)</span><br><span class="line">        <span class="keyword">if</span> got != c.want &#123;</span><br><span class="line">            t.Errorf(<span class="string">"Reverse(%q) == %q, want %q"</span>, c.in, got, c.want)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then run the test with go test:<br>然后用go测试运行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> github.com/user/stringutil</span><br><span class="line">ok      github.com/user/stringutil 0.165s</span><br></pre></td></tr></table></figure><p>As always, if you are running the go tool from the package directory, you can omit the package path:<br>如果从包目录运行go工具，则可以省略包路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">ok      github.com/user/stringutil 0.165s</span><br></pre></td></tr></table></figure><p>Run go help test and see the testing package documentation for more detail.<br>运行 <code>go help test</code> 并查看测试包文档以获取更多详细信息。</p><h3 id="Remote-packages"><a href="#Remote-packages" class="headerlink" title="Remote packages"></a>Remote packages</h3><p>An import path can describe how to obtain the package source code using a revision control system such as Git or Mercurial. The go tool uses this property to automatically fetch packages from remote repositories. For instance, the examples described in this document are also kept in a Git repository hosted at GitHub github.com/golang/example. If you include the repository URL in the package’s import path, go get will fetch, build, and install it automatically:<br>导入路径可以描述如何使用诸如 Git 或 Mercurial 之类的代码管理系统来获取源代码包。  Go Tool 使用此属性自动从远程存储库获取包。例如，本文档中描述的示例也保存在 GitHub github.com/golang/example 上托管的 Git 仓库中。如果您在包的导入路径中包含存储库 URL ，那么go将自动获取，构建和安装它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/golang/example/hello</span><br><span class="line">$ <span class="variable">$GOPATH</span>/bin/hello</span><br><span class="line">Hello, Go examples!</span><br></pre></td></tr></table></figure><p>If the specified package is not present in a workspace, go get will place it inside the first workspace specified by GOPATH. (If the package does already exist, go get skips the remote fetch and behaves the same as go install.)<br>如果工作空间中不存在指定的包，则 get 将其放在 GOPATH 指定的第一个工作空间内。 （如果包已经存在，请跳过远程提取，其行为与 go install 相同。）</p><p>After issuing the above go get command, the workspace directory tree should now look like this:<br>发出上面的go get命令后，工作区目录树现在应如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bin/</span><br><span class="line">    hello                           <span class="comment"># command executable</span></span><br><span class="line">src/</span><br><span class="line">    github.com/golang/example/</span><br><span class="line">    .git/                       <span class="comment"># Git repository metadata</span></span><br><span class="line">        hello/</span><br><span class="line">            hello.go                <span class="comment"># command source</span></span><br><span class="line">        stringutil/</span><br><span class="line">            reverse.go              <span class="comment"># package source</span></span><br><span class="line">            reverse_test.go         <span class="comment"># test source</span></span><br><span class="line">    github.com/user/</span><br><span class="line">        hello/</span><br><span class="line">            hello.go                <span class="comment"># command source</span></span><br><span class="line">        stringutil/</span><br><span class="line">            reverse.go              <span class="comment"># package source</span></span><br><span class="line">            reverse_test.go         <span class="comment"># test source</span></span><br></pre></td></tr></table></figure><p>The hello command hosted at GitHub depends on the stringutil package within the same repository. The imports in hello.go file use the same import path convention, so the go get command is able to locate and install the dependent package, too.<br>在GitHub上托管的hello命令取决于同一存储库中的stringutil包。 hello.go文件中的导入使用相同的导入路径约定，因此 go get 命令也能够找到并安装依赖包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import <span class="string">"github.com/golang/example/stringutil"</span></span><br></pre></td></tr></table></figure><p>This convention is the easiest way to make your Go packages available for others to use. The Go Wiki and godoc.org provide lists of external Go projects.<br>此约定是使您的Go包可供其他人使用的最简单方法。 Go Wiki和godoc.org提供了外部Go项目的列表。</p><p>For more information on using remote repositories with the go tool, see go help importpath.<br>有关使用go工具使用远程存储库的更多信息，请参阅go help importpath。</p><h3 id="What’s-next"><a href="#What’s-next" class="headerlink" title="What’s next"></a>What’s next</h3><p>Subscribe to the golang-announce mailing list to be notified when a new stable version of Go is released.<br>See Effective Go for tips on writing clear, idiomatic Go code.<br>Take A Tour of Go to learn the language proper.<br>Visit the documentation page for a set of in-depth articles about the Go language and its libraries and tools.<br>订阅golang-announce邮件列表，以便在发布新的稳定版Go时收到通知。<br>有关编写清晰，惯用的Go代码的提示，请参阅Effective Go。<br>学习 A Tour of Go ，学习语法。<br>访问文档页面，获取有关Go语言及其库和工具的深入文章。</p><h3 id="Getting-help"><a href="#Getting-help" class="headerlink" title="Getting help"></a>Getting help</h3><p>For real-time help, ask the helpful gophers in #go-nuts on the Freenode IRC server.<br>The official mailing list for discussion of the Go language is Go Nuts.<br>Report bugs using the Go issue tracker.<br>要获得实时帮助，请在Freenode IRC上使用 #go-nuts 标签询问开发者。<br>讨论Go语言的官方邮件列表是Go Nuts。<br>使用Go问题跟踪器报告错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在学习郝林老师的 Go 语言专栏，自己也在从 PHP 向 Golang 的转型中，学习了 GOPATH 的概念之后发现有些懵逼&lt;br&gt;关于 Go 的学习也是一个愉快的过程。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="golang" scheme="https://wang-zc.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Code Rules</title>
    <link href="https://wang-zc.github.io/2018/08/25/Code-Rules/"/>
    <id>https://wang-zc.github.io/2018/08/25/Code-Rules/</id>
    <published>2018-08-25T07:23:44.000Z</published>
    <updated>2019-01-02T01:29:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>因为之前都没有很严格的代码规范，所以这周开始制定代码规范，大致从五部分来做。<br>【强制】严格遵守 PSR 规范，详尽的 PSR 规范可以点击链接访问<a href="#">URL 链接</a>(<a href="https://psr.phphub.org/" target="_blank" rel="noopener">https://psr.phphub.org/</a>)</p></blockquote><a id="more"></a><h3 id="0x00-团队代码规范"><a href="#0x00-团队代码规范" class="headerlink" title="0x00  团队代码规范"></a>0x00  团队代码规范</h3><ul><li>命名规范 ✅</li><li>代码片段 ✅</li><li>数据库设计✅</li><li>开发守则  ✅</li></ul><h4 id="关于-Code-的规范"><a href="#关于-Code-的规范" class="headerlink" title="关于 Code 的规范"></a>关于 Code 的规范</h4><blockquote><p>PHP 系列可以参考 PSR 规范，<a href="https://psr.phphub.org/" target="_blank" rel="noopener" title="PSR 标准规范">PSR</a>(<a href="https://psr.phphub.org/" target="_blank" rel="noopener">https://psr.phphub.org/</a>)<br>JavaScript 可以参考 <a href="https://github.com/fex-team/styleguide/blob/master/javascript.md" target="_blank" rel="noopener">JS URL</a>(<a href="https://github.com/fex-team/styleguide/blob/master/javascript.md" target="_blank" rel="noopener">https://github.com/fex-team/styleguide/blob/master/javascript.md</a>)<br>关于 MySQL 的规范可以参考《阿里巴巴 Java 开发手册中》的数据库部分</p></blockquote><ul><li>PHP代码文件 必须 以 <code>&lt;?php</code> 或 <code>&lt;?=</code> 标签开始；</li><li>PHP代码文件 必须 以 <code>不带 BOM 的 UTF-8 编码</code>；</li><li>PHP代码中 应该 只定义类、函数、常量等声明，或其他会产生 副作用 的操作（如：生成文件输出以及修改 <code>.ini</code> 配置文件等），二者只能选其一；</li></ul><h3 id="0x01、命名规范"><a href="#0x01、命名规范" class="headerlink" title="0x01、命名规范"></a>0x01、命名规范</h3><ol><li><p>【强制】代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。<br> 说明： 正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式，但是一些在英文中无法对应的词语可以使用拼音，如搬砖等。但是拼音方案也要尽量避免采用，变量必须有所含义，不允许出现<code>$data</code>,<code>$a</code> 等无意义的变量名。</p></li><li><p>【强制】类名使用 <code>UpperCamelCase</code> 风格，但以下情形例外：<code>DO / BO / DTO / VO / AO /PO / UID</code> 等。<br> 说明：关于 <code>ThinkPHP</code> 框架下开发的时候要遵循框架开发的规则，对于 <code>Controller</code> 的文件命名不做强制要求。<br> 正例： <code>MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion</code></p></li><li><p>【强制】类内方法名、类内参数名、成员变量、局部变量都统一使用<code>lowerCamelCase</code>风格，必须遵从驼峰形式。<br> 正例：<code>localValue / getHttpMessage() / inputUserId</code></p></li><li><p>【强制】抽象类命名使用 <code>Abstract</code> 开头； 异常类命名使用 <code>Exception</code> 结尾； 测试类命名以它要测试的类的名称开始，以 <code>Test</code> 结尾。</p></li><li><p>【强制】常量命名、配置参数和语言变量全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。<br> 例如 <code>HAS_ONE</code>和 <code>MANY_TO_MANY</code>；语言变量例如<code>MY_LANG</code>，以下划线打头的语言变量通常用于系统语言变量，例如 <code>_CLASS_NOT_EXIST_</code>；</p></li><li><p>【强制】杜绝完全不规范的缩写， 避免望文不知义。<br> 反例： <code>AbstractClass</code>“缩写” 命名成 <code>AbsClass</code>； <code>condition</code>“缩写” 命名成 <code>condi</code>，此类随意缩写严重降低了代码的可阅读性。</p></li><li><p>【推荐】如果模块、 接口、类、方法使用了设计模式，在命名时需体现出具体模式。<br> 说明： 将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。<br> 正例： <code>public class OrderFactory</code>;<code>public class LoginProxy</code>;<br> <code>public class ResourceObserver</code>;</p></li><li><p>【参考】各层命名规约，遵守<code>Service/DAO</code> 层方法命名规约<br> 1） 获取单个对象的方法用 <code>get</code> 做前缀。<br> 2） 获取多个对象的方法用 <code>list</code> 做前缀，复数形式结尾如： <code>listObjects</code>。<br> 3） 获取统计值的方法用 <code>count</code> 做前缀。<br> 4） 插入的方法用 <code>save/insert</code> 做前缀。<br> 5） 删除的方法用 <code>remove/delete</code> 做前缀。<br> 6） 修改的方法用 <code>update</code> 做前缀。</p></li><li><p>关于 <code>ThinkPHP</code> 的一些需要遵守的地方也需要注意</p><ul><li>类文件都是以<code>.class.php</code>为后缀（这里是指的<code>ThinkPHP</code>内部使用的类库文件，不代表外部加载的类库文件），使用驼峰法命名，并且首字母大写，例如 <code>DbMysql.class.php</code>；</li><li>类的命名空间地址和所在的路径地址一致，例如 <code>Home\Controller\UserController</code>类所在的路径应该是 <code>Application/Home/Controller/UserController.class.php</code>；</li><li>确保文件的命名和调用大小写一致，是由于在类<code>Unix</code>系统上面，对大小写是敏感的（而<code>ThinkPHP</code>在调试模式下面，即使在<code>Windows</code>平台也会严格检查大小写）；</li><li>类名和文件名一致（包括上面说的大小写一致），例如 <code>UserController</code>类的文件命名是<code>UserController.class.php</code>，<code>InfoModel</code>类的文件名是<code>InfoModel.class.php</code>， 并且不同的类库的类命名有一定的规范；</li><li>函数、配置文件等其他类库文件之外的一般是以.php为后缀（第三方引入的不做要求）；</li><li>函数的命名使用小写字母和下划线的方式，例如 <code>get_client_ip</code> ；</li><li>类内方法的命名使用驼峰法，并且首字母小写或者使用下划线 <code>_</code>，例如 <code>getUserName</code>，<code>_parseType</code>，下划线开头的方法属于私有方法；</li><li>类内属性的命名使用驼峰法，并且首字母小写或者使用下划线 <code>_</code>，例如 <code>tableName</code>、<code>_instance</code>，下划线开头的属性属于私有属性；</li><li>以双下划线<code>__</code>打头的函数或方法作为魔法方法，例如 <code>__call</code> 和 <code>__autoload</code>；</li><li>常量必须大写字母和下划线命名，例如 <code>HAS_ONE</code> 和 <code>MANY_TO_MANY</code>；</li><li>配置参数以大写字母和下划线命名，例如 <code>HTML_CACHE_ON</code>；</li><li>语言变量以大写字母和下划线命名，例如 <code>MY_LANG</code>，以下划线打头的语言变量通常用于系统语言变量，例如 <code>_CLASS_NOT_EXIST_</code>；</li><li>ThinkPHP的模板文件默认是以 <code>.html</code> 为后缀（可以通过配置修改）；</li><li>数据表和字段采用小写加下划线方式命名，并注意字段名不要以下划线开头，例如 <code>think_user</code> 表和 <code>user_name</code> 字段是正确写法，类似 <code>_username</code> 这样的数据表字段可能会被过滤。</li></ul></li></ol><h3 id="0x02-代码片段"><a href="#0x02-代码片段" class="headerlink" title="0x02 代码片段"></a>0x02 代码片段</h3><ol><li><p>【强制】代码使用4个空格符而不是「Tab 键」进行缩进（这里可以在<code>PhpStorm</code>的配置中设置）。</p></li><li><p>【强制】每个 <code>namespace</code> 命名空间声明语句和 <code>use</code> 声明语句块后面，必须插入一个空白行。</p></li><li><p>【强制】类的开始花括号 <code>{</code> 必须写在函数声明后自成一行，结束花括号 <code>}</code> 也必须写在函数主体后自成一行。</p></li><li><p>【强制】方法的开始花括号 <code>{</code> 必须写在函数声明后自成一行，结束花括号 <code>}</code> 也必须写在函数主体后自成一行。</p></li><li><p>【强制】类的属性和方法必须添加访问修饰符 <code>private</code>、<code>protected</code> 以及 <code>public</code>，<code>abstract</code> 以及 <code>final</code>必须声明在访问修饰符之前，而 <code>static</code> 必须声明在访问修饰符之后。</p></li><li><p>【强制】控制结构的关键字后必须要有一个空格符，而调用方法或函数时则一定不可有。</p></li><li><p>【强制】控制结构的开始花括号 <code>{</code> 必须写在声明的同一行，而结束花括号 <code>}</code> 必须写在主体后自成一行。</p></li><li><p>【强制】控制结构的开始左括号后和结束右括号前，都 <em><strong>一定不可</strong></em> 有空格符。</p></li><li><p>【推荐】单行注释无比使用 <code>//</code>来进行标注，和下一行代码对齐</p></li><li><p>【推荐】多行注释，可以使用 <code>/**/</code> 来做注释开头和结尾</p></li><li><p>【推荐】简单的接口不需要些注释，不要写过多的注释，复杂的逻辑注释注意准确性和时效性，如果注释已经失效，记得更新日志。否则删掉。</p></li><li><p>前端的 <code>JS</code> 文件和 <code>HTML</code> 文件上线时需要删除注释内容。前端不适宜写过多的注释内容，以备留下安全隐患。</p></li><li><p>【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。<br>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> two = <span class="number">2L</span>;</span><br><span class="line"><span class="keyword">float</span> three = <span class="number">3F</span>;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br></pre></td></tr></table></figure><p>说明： 增加 sb 这个变量，如果需要对齐，则给 a、 b、 c 都要增加几个空格，在变量比较多的情况下，是非常累赘的事情</p></li></ol><h5 id="正确示例如下"><a href="#正确示例如下" class="headerlink" title="正确示例如下"></a>正确示例如下</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Vendor</span>\<span class="title">Package</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">FooInterface</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">BarClass</span> <span class="title">as</span> <span class="title">Bar</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">OtherVendor</span>\<span class="title">OtherPackage</span>\<span class="title">BazClass</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">Bar</span> <span class="keyword">implements</span> <span class="title">FooInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sampleFunction</span><span class="params">($a, $b = null)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($a === $b) &#123;</span><br><span class="line">            bar();</span><br><span class="line">        &#125; <span class="keyword">elseif</span> ($a &gt; $b) &#123;</span><br><span class="line">            $foo-&gt;bar($arg1);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BazClass::bar($arg2, $arg3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 方法的内容</span></span><br><span class="line">        $argc = <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x02-开发守则"><a href="#0x02-开发守则" class="headerlink" title="0x02 开发守则"></a>0x02 开发守则</h3><ol><li><p>开发过程中保持和产品、测试的实时沟通，切勿<code>独立</code>开发，有了新的 <code>idea</code>，要记得及时和产品沟通。每一个确定的需求都要保证开发，测试和产品是清楚无误的。</p></li><li><p>在开始新的迭代的时候，再三沟通，再三沟通，再三沟通好要迭代的内容。</p></li><li><p>下笔之前，多思考。<code>THINK MORE, CODE LESS</code></p></li><li><p>每个函数不超过 <code>50</code> 行，非强制性，但绝对不可以超过 <code>150</code> 行，开发过程中应当避免每个方法过长，适时解构，不要让代码耦合性过强。</p></li><li><p>无论是<code>laravel</code> 或者<code>ThinkPHP</code>哪一个框架，<code>Controller</code>中的<code>func</code> 不要太复杂。复杂逻辑写在相对应的<code>Service</code>或者<code>Logic</code>中。</p></li><li><p><code>Controller</code>中不允许直接调用<code>Model</code></p></li><li><p>在每次的上线时维护好上线文档。一次小上线也要记录好本次上线的内容。</p></li><li><p>不要盲目的拷贝，粘贴。要知道拷贝粘贴节约的时间没有多少。把方法解耦，提取公共方法。这样才是长久之计。</p></li><li><p>对自己的代码要负责，要有强烈的羞耻心。</p></li><li><p>多记录日志，对每一个步骤流程都做日志流程记录，尤其是订单流程。这样出现问题排查起来很方便。</p></li><li><p>不断思考，不断前进。</p></li><li><p>请尽量使用 <code>teambition</code> 合作, 约束自己</p></li><li><p>多自我学习, 没工作内容的时候才是成长的好机会</p></li><li><p>多交流</p></li><li><p><code>SVN commit</code> 有目的的时候, 尽量填写 <code>msg</code>, 不要改改就提交</p></li><li><p>复制的代码一定要改注释, 保持注释的正确性</p></li><li><p>写死数据进行测试是可以的, 但是测试完了要去掉(如果没用)</p></li><li><p>阅读下其他盆友的代码, 熟悉流程, 不能只知道自己的小块, 至少要知道个大概流程吧.</p></li><li><p>注意<code>api</code>的兼容性，<code>response</code>结构不要删减；注意数据类型的一致性</p></li><li><p>接口完成后如果可以请录入<code>postman</code>，并告知客户端盆友改动项</p></li><li><p>注意如果<code>apivN</code>改了, 也要考虑下<code>apiM</code>的情况, 比如说<code>api1</code>不再支持微信资料的覆盖, 这种改变, <code>api</code>也是肯定不能支持的, 都要改掉!; 而如果是<code>api1</code>加了某个字段, <code>api</code>不需要用到, 那可以不加.</p></li><li><p>个人感觉不要用一样的命名, 我刚才搜索一个方法, <code>controller</code>, <code>logic</code>, <code>model</code>里全叫一个名字; 实例化后的变量名也不容易作为搜索条件区分, 一搜就悲剧了. 大家注意<code>controller</code>里是给用户访问的入口, <code>logic</code>里是集合的操作, <code>model</code>里是对数据库的操作, 以此来定名字.</p></li></ol><h3 id="0x31-数据库设计"><a href="#0x31-数据库设计" class="headerlink" title="0x31 数据库设计"></a>0x31 数据库设计</h3><h5 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h5><ol><li><p>【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，所以字段名称需要慎重考虑。说明：<code>MySQL</code>在<code>Windows</code>下不区分大小写，但在<code>Linux</code>下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。正例：<code>aliyun_admin</code>，<code>rdc_config</code>，<code>level3_name</code> 反例：<code>AliyunAdmin</code>，<code>rdcConfig</code>，<code>level_3_name</code> </p></li><li><p>【强制】表名字段名不使用英文与拼音的复合表达式，符合表达习惯。禁用保留字，如<code>desc</code>、<code>date</code>、<code>range、match、delayed</code>等，请参考MySQL官方保留字。</p></li><li><p>【强制】主键索引名为<code>pk_</code>字段名；唯一索引名为<code>uk_</code>字段名；普通索引名则为<code>idx_</code>字段名。 说明：<code>pk_</code> 即<code>primary key</code>；<code>uk_</code> 即 <code>unique key</code>；<code>idx_</code> 即<code>index</code>的简称。 </p></li></ol><h5 id="表-字段规则"><a href="#表-字段规则" class="headerlink" title="表/字段规则"></a>表/字段规则</h5><ol><li><p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。 说明：以学生和成绩的关系为例，学生表中的<code>student_id</code>是主键，那么成绩表中的<code>student_id</code>则为外键。如果更新学生表中的<code>student_id</code>，同时触发成绩表中的<code>student_id</code>更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。 </p></li><li><p>【强制】所有的字符存储与表示，均以<code>utf-8</code>编码，注意字符统计函数的区别。 </p></li><li><p>【强制】如果存储的字符串长度几乎相等，使用<code>char</code>定长字符串类型。 </p></li><li><p>【强制】<code>varchar</code>是可变长字符串，不预先分配存储空间，长度不要超过 2000，如果存储长度大于此值，定义字段类型为<code>text</code>，独立出来一张表，用主键来对应，避免影响其它字段索引效率。 </p></li><li><p>【推荐】表必备三字段：<code>id, createon, updateon</code>。 说明：其中id必为主键，类型为<code>bigint unsigned</code>、单表时自增、步长为1。<code>createon, updateon</code>的类型均为<code>datetime</code>类型。</p></li><li><p>【推荐】所有字段都应该有默认值，不应该存在值为<code>NULL</code>的列，<code>NULL</code>值在统计中会造成很多麻烦。 </p></li><li><p>【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：<br>  1）不是频繁修改的字段。<br>  2）不是<code>varchar</code>超长字段，更不能是<code>text</code>字段。 正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。 </p></li><li><p>【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。 </p></li></ol><h5 id="索引规则"><a href="#索引规则" class="headerlink" title="索引规则"></a>索引规则</h5><ol><li><p>【强制】勿认为一个查询就需要建一个索引，也不要胡乱认为索引会消耗空间、严重拖慢更新和新增速度，而是应该业务需求考虑索引的必要程度。</p></li><li><p>【强制】对于有限的几个值的列不需要建索引。 </p></li><li><p>【强制】经常出现在<code>where</code>条件和<code>order by</code>子句中的列一定要建立索引。</p></li><li><p>【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。<br> 说明：不要以为唯一索引影响了<code>insert</code>速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。 </p></li><li><p>【强制】在<code>varchar</code>字段上建立索引时，必须指定索引长度，一般来说 8 位即可，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。 </p></li><li><p>【推荐】 <code>SQL</code>性能优化的目标：至少要达到 <code>range</code> 级别，要求是<code>ref</code>级别，如果可以是<code>consts</code>最好。<br> 说明：<br>  1）<code>consts</code> 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。<br>  2）<code>ref</code> 指的是使用普通的索引（<code>normal index</code>）。<br>  3）<code>range</code> 对索引进行范围检索。 反例：<code>explain</code>表的结果，<code>type=index</code>，索引物理文件全扫描，速度非常慢，这个<code>index</code>级别比较<code>range</code>还低，与全表扫描是小巫见大巫。 </p></li></ol><h5 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h5><ol><li><p>【强制】不要使用<code>count(列名)</code>或<code>count(常量)</code>来替代<code>count(*)</code>，<code>count(*)</code>是<code>SQL92</code>定义的标准统计行数的语法，跟数据库无关，跟<code>NULL</code>和非<code>NULL</code>无关。 说明：<code>count(*)</code>会统计值为<code>NULL</code>的行，而<code>count(列名)</code>不会统计此列为<code>NULL</code>值的行。 </p></li><li><p>【强制】<code>order by</code>排序的时候如果是根据创建时间来排序，不要使用<code>createon</code>列，直接用<code>order by id</code> 或者<code>order by id desc</code>。说明：通过主键来排序大幅提高性能。</p></li><li><p>【强制】 在代码中写分页查询逻辑时，若<code>count</code>为0应直接返回，避免执行后面的分页语句。 </p></li><li><p>【强制】<code>where</code>条件中如果字段是字符类型，代码中的条件值必须加上引号，避免索引失效。 </p></li><li><p>【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。 说明：1）增加查询分析器解析成本；2）无用字段增加网络消耗，尤其是text类型的字段。 </p></li><li><p>【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。 </p></li><li><p>【强制】 除临时表外程序中禁止使用<code>TRUNCATE TABLE</code> 。说明：<code>TRUNCATE TABLE</code> 在功能上与不带 <code>WHERE</code> 子句的 <code>DELETE</code> 语句相同，极有可能造成事故。 </p></li><li><p>【推荐】<code>in</code>操作能避免则避免，若实在避免不了，需要仔细评估<code>in</code>后边的集合元素数量，控制在1000个之内。 </p></li><li><p>【推荐】不要写一个大而全的数据更新接口。不管是不是自己的目标更新字段，都进行<code>update table set c1=value1,c2=value2,c3=value3;</code>这是不对的。执行<code>SQL</code>时，不要更新无改动的字段，一是易出错；二是效率低；三是增加<code>binlog</code>存储。 </p></li><li><p>【推荐】利用延迟关联或者子查询优化超多分页场景。 说明：<code>MySQL</code>并不是跳过<code>offset</code>行，而是取<code>offset+N</code>行，然后返回放弃前<code>offset</code>行，返回<code>N</code>行，那当<code>offset</code>特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行<code>SQL</code>改写。 正例：先快速定位需要获取的<code>id</code>段，然后再关联： <code>SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</code></p></li><li><p>【推荐】建组合索引的时候，区分度最高的在最左边。 正例：如果<code>where a=? and b=?</code>，如果<code>a</code>列的几乎接近于唯一值，那么只需要单建<code>idx_a</code>索引即可。 说明：存在非等号和等号混合时，在建索引时，请把等号条件的列前置。如：<code>where c&gt;? and d=?</code> 那么即使<code>c</code>的区分度更高，也必须把d放在索引的最前列，即索引<code>idx_d_c</code>。 </p></li><li><p>【推荐】超过三个表禁止<code>join</code>。需要<code>join</code>的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。 说明：即使双表<code>join</code>也要注意表索引、<code>SQL</code>性能。 </p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;因为之前都没有很严格的代码规范，所以这周开始制定代码规范，大致从五部分来做。&lt;br&gt;【强制】严格遵守 PSR 规范，详尽的 PSR 规范可以点击链接访问&lt;a href=&quot;#&quot;&gt;URL 链接&lt;/a&gt;(&lt;a href=&quot;https://psr.phphub.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://psr.phphub.org/&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>svn 自动打包</title>
    <link href="https://wang-zc.github.io/2018/08/19/svn-%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85/"/>
    <id>https://wang-zc.github.io/2018/08/19/svn-自动打包/</id>
    <published>2018-08-19T08:22:07.000Z</published>
    <updated>2019-01-02T01:28:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>找了个时间写了一个 SVN 自动寻找某人打包的工具</p><p>最近是比较痛苦的一段时间，git 和 svn 一起运行。</p><p>然后这里面每次 svn 打包的时候都会少上文件，花了一会儿，写了一个 svn 自动打包的工具。</p></blockquote><a id="more"></a><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">fwrite(STDOUT, <span class="string">"Please enter your working copt path[ep: /www/htdocs/xxx ]"</span>);</span><br><span class="line">$path = trim(fgets(STDIN));</span><br><span class="line"></span><br><span class="line">fwrite(STDOUT, <span class="string">"Please enter your svn version for last make package [ep: 16600]:"</span>);</span><br><span class="line">$lastVersion = trim(fgets(STDIN));</span><br><span class="line"></span><br><span class="line">fwrite(STDOUT, <span class="string">"Please enter your svn name [ep: xx.zhang]:"</span>);</span><br><span class="line">$name = trim(fgets(STDIN));</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\n Path is :&#123;$path&#125;\n"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\n Version is :&#123;$lastVersion&#125;\n"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\n Name is :&#123;$name&#125;\n"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\n"</span>;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">' 3...'</span> . <span class="string">"\n"</span>;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">' 2...'</span> . <span class="string">"\n"</span>;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">' 1...'</span> . <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"-------------------------------------------------------------\n"</span>;</span><br><span class="line">exec(<span class="string">"svn info &#123;$path&#125;"</span>, $info);</span><br><span class="line"></span><br><span class="line">$revision = $info[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">empty</span>($revision)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Please Check Your Input Path? \n"</span>;</span><br><span class="line">    <span class="keyword">die</span>;</span><br><span class="line">&#125;</span><br><span class="line">$localPath = str_replace(<span class="string">'Working Copy Root Path: '</span>, <span class="string">''</span>, $info[<span class="number">1</span>]);</span><br><span class="line">$svnUrl    = str_replace(<span class="string">'URL: '</span>, <span class="string">''</span>, $info[<span class="number">2</span>]);</span><br><span class="line">preg_match_all(<span class="string">'/\d&#123;4,6&#125;/'</span>, $revision, $match);</span><br><span class="line">$version = $match[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">exec(<span class="string">'svn diff -r '</span> . $lastVersion . <span class="string">':'</span> . $version . <span class="string">' --summarize '</span> . $svnUrl, $svn);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">empty</span>($svn)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"SVN Error...Can't to make package!\n"</span>;</span><br><span class="line">    <span class="keyword">die</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Ready to collect svn update diff files....\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">$filePath = <span class="keyword">array</span>();</span><br><span class="line"><span class="keyword">foreach</span> ($svn <span class="keyword">as</span> $value) &#123;</span><br><span class="line">    $fileStatus  = substr($value, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    $svnFilePath = str_replace($fileStatus . <span class="string">'       '</span>, <span class="string">''</span>, $value);</span><br><span class="line">    $svnLog      = <span class="keyword">array</span>();</span><br><span class="line">    exec(<span class="string">'svn log -r '</span> . $lastVersion . <span class="string">':'</span> . $version . <span class="string">' '</span> . $svnFilePath . <span class="string">' | grep '</span> . $name, $svnLog);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>($svnLog)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    $changePath = str_replace($fileStatus . <span class="string">'       '</span> . $svnUrl, $localPath, $value);</span><br><span class="line">    $filePath[] = $changePath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">empty</span>($filePath)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Can't Find Update File\n"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $count = count($filePath);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Find &#123;$count&#125; File To Update!\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mkdir</span></span><br><span class="line">    $date        = date(<span class="string">"Y-m-d"</span>);</span><br><span class="line">    $packagePath = $localPath . <span class="string">'/svn_package/'</span> . $date . <span class="string">'/'</span>;</span><br><span class="line">    <span class="keyword">if</span> (is_dir($packagePath)) &#123;</span><br><span class="line">        exec(<span class="string">'rm -rf '</span> . $packagePath . <span class="string">"*"</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Find a Exist Package FilePath\n"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mkdir($packagePath, <span class="number">0777</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> ($filePath <span class="keyword">as</span> $path) &#123;</span><br><span class="line">        $targetFile = str_replace($localPath . <span class="string">'/'</span>, $packagePath, $path);</span><br><span class="line">        $dirName    = dirname($targetFile);</span><br><span class="line">        <span class="keyword">if</span> (!is_dir($dirName)) &#123;</span><br><span class="line">            exec(<span class="string">'mkdir -p '</span> . $dirName);</span><br><span class="line">        &#125;</span><br><span class="line">        exec(<span class="string">'cp '</span> . $path . <span class="string">' '</span> . $targetFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Finish....\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;找了个时间写了一个 SVN 自动寻找某人打包的工具&lt;/p&gt;
&lt;p&gt;最近是比较痛苦的一段时间，git 和 svn 一起运行。&lt;/p&gt;
&lt;p&gt;然后这里面每次 svn 打包的时候都会少上文件，花了一会儿，写了一个 svn 自动打包的工具。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="svn" scheme="https://wang-zc.github.io/tags/svn/"/>
    
  </entry>
  
  <entry>
    <title>Gitlab 迁移</title>
    <link href="https://wang-zc.github.io/2018/08/19/Gitlab-%E8%BF%81%E7%A7%BB/"/>
    <id>https://wang-zc.github.io/2018/08/19/Gitlab-迁移/</id>
    <published>2018-08-19T08:17:09.000Z</published>
    <updated>2019-01-02T01:30:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Gitlab 是一个优秀的产品，现在已经升级到了 11.6.0 的版本了。</p></blockquote><a id="more"></a><p>之前原来组建的<code>docker</code>里的<code>Gitlab</code>打算迁移出来到一台新机器上了，新机器的硬盘也大。</p><p>这次迁移还是费了一阵功夫的。</p><p>发现自己的<code>Gitlab</code>的版本是<code>10.1.1</code>的老版本，最新的版本是<code>11.1.4</code>这个版本。</p><p>在一开始准备升级的时候提示我升级不成功，需要先升级到<code>10.8.x</code>才能升级成功，好吧，先升级到了<code>10.8</code>之后然后准备安装<code>11</code>的版本。</p><p>在一阵等待之后终于安装成功了，因为虚拟机迁移的问题，内部的端口需要重新打开配置，后来发现新机器的 <code>HTTPS</code> 正常访问，但是我之前用了 <code>ssh-key</code>方式，一直不通很难受。</p><p>一开始发现22端口始终是空闲的，其实早该想到 ssh 端口在哪里被用到了，可是愚蠢的我开始去看防火墙，看了下防火墙的配置，发现22端口是打开的，返回来又查，查不到占用。后来看端口转发设置是否有问题，发现端口转发也没问题。奇了怪了，后来问了下大哥，发现 ssh 端口是 16390 端口。。。。。。</p><p>于是改了进去 Gitlab 的端口配置，终于生效了。</p><p>可是因为虚拟机转发到了一台新主机上，发现端口变了。老机器不认这个 Host 了</p><p>GG….</p><p>查了一下如何解决之后打开本地的 Know_host 文件把之前对老机器的指纹删掉。_</p><p>后续自动发布的时候发现自己之前设置的 hooks 钩子也不生效了。</p><p>hhh</p><p>别提多烦了，初步确认应该是权限的问题，后来登录了新机器发现果然是权限问题。</p><p>同理，删了旧机器的指纹，然后给了权限。</p><p>搞定。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Gitlab 是一个优秀的产品，现在已经升级到了 11.6.0 的版本了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Gitlab" scheme="https://wang-zc.github.io/tags/Gitlab/"/>
    
  </entry>
  
  <entry>
    <title>SVN 迁移到 Gitlab</title>
    <link href="https://wang-zc.github.io/2018/08/06/SVN-%E8%BF%81%E7%A7%BB%E5%88%B0-Gitlab/"/>
    <id>https://wang-zc.github.io/2018/08/06/SVN-迁移到-Gitlab/</id>
    <published>2018-08-06T01:46:27.000Z</published>
    <updated>2019-01-02T01:29:01.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>自己搭建了 Gitlab 也有一段时间了，看了一下准备把一些项目陆续的迁移到 Gitlab 中。</p><p>之前迁移了一次 CM，但是过程没有记录下来。</p><p>这次记录一下过程</p><p>参考一篇文章<a href="https://blog.csdn.net/Hello_Mr_Cc/article/details/72742503" target="_blank" rel="noopener">CSDN Blog</a></p><p>还有一篇<a href="https://www.lovelucy.info/codebase-from-svn-to-git-migration-keep-commit-history.html" target="_blank" rel="noopener">Blog</a></p></blockquote><a id="more"></a><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>按照顺序执行，先把 svn 中的 author 导出成 user.txt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/www/htdocs/xxx » svn <span class="built_in">log</span> ^/ --xml | grep -P <span class="string">"^&lt;author"</span> | sort -u | perl -pe <span class="string">'s/&lt;author&gt;(.*?)&lt;\/author&gt;/$1 = /'</span> &gt; users.txt</span><br><span class="line">usage: grep [-abcDEFGHhIiJLlmnOoqRSsUVvwxZ] [-A num] [-B num] [-C[num]]</span><br><span class="line">    [-e pattern] [-f file] [--binary-files=value] [--color=when]</span><br><span class="line">    [--context[=num]] [--directories=action] [--label] [--line-buffered]</span><br><span class="line">    [--null] [pattern] [file ...]</span><br><span class="line">svn: E000032: Write error: Broken pipe</span><br></pre></td></tr></table></figure><p>但是在执行的时候报错了，提示<code>Write error: Broken pipe</code>，看了网上的一些东西，描述是，在命令的执行中，如果是<code>xxx|xxx</code>这种，上一个命令的输出，给到了下一个命令的输入，如果上一个输出有问题，那么会提示错误信息。</p><p>后来去尝试不断的拆分命令，很快就定位到了 <code>grep -P</code> 这里，grep 是没有 -P 这个选项的。看了下 man page，没找到 P 选项的含义，所以这里去除了 -P 就 OK 了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn <span class="built_in">log</span> ^/ --xml | grep <span class="string">"^&lt;author"</span> | sort -u | perl -pe <span class="string">'s/&lt;author&gt;(.*?)&lt;\/author&gt;/$1 = /'</span></span><br></pre></td></tr></table></figure><p>得到的 user.txt 是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qingping.xxx=xxx&lt;xxx@xx.cn&gt;</span><br></pre></td></tr></table></figure><p>这里把 Gitlab 中的 author 对应填入进去。</p><h3 id="获取-SVN-的数据到本地"><a href="#获取-SVN-的数据到本地" class="headerlink" title="获取 SVN 的数据到本地"></a>获取 SVN 的数据到本地</h3><p>通过 git svn clone 命令把 SVN 仓库导入到 Git 中，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git svn <span class="built_in">clone</span> svn://xxx.xx@svn.xx.cn:16/openapi/trunk/openapi.xx.xx --no-metadata --authors-file=user.txt /www/htdocs/openapi</span><br></pre></td></tr></table></figure><p>通过以上命令就会在目标文件夹中生成一个 git 项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------</span><br><span class="line">/www/htdocs/openapi(branch:master) » git branch -a</span><br><span class="line">* master</span><br><span class="line">  remotes/git-svn</span><br><span class="line">------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>但是这里生成了一个本地的 master 分支，和一个 git-svn 的 remote，我总是看这个 git-svn 不顺眼，如何才能删掉呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/www/htdocs/openapi(branch:master) » git remote rm remotes/git-svn</span><br><span class="line">error: Could not remove config section <span class="string">'remote.remotes/git-svn'</span></span><br></pre></td></tr></table></figure><p>发现这里有些奇怪，这里感觉有些奇怪，但是也没有</p><p>借鉴了博客里面的东西，使用<code>git clone</code>删除了里面原有的 git-svn remote.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;自己搭建了 Gitlab 也有一段时间了，看了一下准备把一些项目陆续的迁移到 Gitlab 中。&lt;/p&gt;
&lt;p&gt;之前迁移了一次 CM，但是过程没有记录下来。&lt;/p&gt;
&lt;p&gt;这次记录一下过程&lt;/p&gt;
&lt;p&gt;参考一篇文章&lt;a href=&quot;https://blog.csdn.net/Hello_Mr_Cc/article/details/72742503&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSDN Blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还有一篇&lt;a href=&quot;https://www.lovelucy.info/codebase-from-svn-to-git-migration-keep-commit-history.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Blog&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MySQL 索引探索</title>
    <link href="https://wang-zc.github.io/2018/05/07/MySQL-%E7%B4%A2%E5%BC%95%E6%8E%A2%E7%B4%A2/"/>
    <id>https://wang-zc.github.io/2018/05/07/MySQL-索引探索/</id>
    <published>2018-05-07T02:30:08.000Z</published>
    <updated>2019-01-02T01:31:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于索引，你想知道的事情</p></blockquote><a id="more"></a><h3 id="索引是什么？"><a href="#索引是什么？" class="headerlink" title="索引是什么？"></a>索引是什么？</h3><h4 id="索引的解释"><a href="#索引的解释" class="headerlink" title="索引的解释"></a>索引的解释</h4><blockquote><p><a href="https://zh.wikipedia.org/wiki/数据库索引" target="_blank" rel="noopener">数据库索引</a>，是数据库管理系统中一个排序的数据结构，以协助快速查询，更新数据库表中数据。</p></blockquote><ul><li><p>值得注意的是：SQL 标准并没有为数据库用户提供任何在数据库系统中控制创建和维护索引的防范，由于索引是冗余的数据结构，因此索引对保证正确性来说并不是必须的；但是索引对事务的高效处理十分重要，对完整性约束的有效实施也很重要；如果没有索引的话，MySQL进行全表扫描会对资源进行极大的浪费.</p></li><li><p><strong>如果不恰当的使用索引的话，只会增加无效的数据维护，耗费资源，同时查询效率仍然得不到提高。</strong></p></li><li><p>那么索引究竟是什么呢？<strong>索引是一种数据结构，一个索引是存储的表中一个特定列或者某几个特定列的值数据结构</strong>，索引是在列上创建的。</p></li></ul><h4 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h4><blockquote><p>有两种基本的索引类型<br><strong>顺序索引</strong>：基于值的顺序排序<br><strong>散列索引</strong>：基于将值平均分布在若干散列桶中，一个值所属的散列通是有一个函数决定的，该函数被称为<em>散列函数</em></p></blockquote><h6 id="顺序索引"><a href="#顺序索引" class="headerlink" title="顺序索引"></a>顺序索引</h6><p>顺序索引中，根据包含记录是否按照搜索码制定的顺序排序可以分为<strong>聚集索引和非聚集索引</strong></p><ul><li>被索引文件中的记录自身也可以按照某种排序顺序存储，一个文件可以有多个索引，分别预计不同的搜索码，如果包含记录的文件按照某个搜索码指定的顺序排序，那么改搜索码对应的索引称为<em>聚集索引</em>，也称为主索引(Primary Index)。</li><li>搜索码指定的顺序于文件中记录的物理顺序不同的索引被称为<strong>非聚集索引</strong>或者<strong>辅助索引</strong>。</li><li>非聚集索引和聚集索引的区别在于，通过聚集索引可以查到需要查找的数据，而通过非聚集索引可以查到记录对应的主键值, 再使用主键的值通过聚集索引查找到需要的数据</li><li>关于数据库中 Key，Primary Key，Unique Key 与 index 的不同可以参见这篇<a href="https://blog.csdn.net/nanamasuda/article/details/52543177" target="_blank" rel="noopener">文章</a></li><li>关于顺序索引，一般如果没有明确表示的话指的就是 B+Tree 索引</li></ul><h6 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h6><ul><li>哈希索引(hash index)基于哈希表实现，只有精确匹配索引所有咧的查询才有效；对于每一行数据，存储引擎都会对所有的索引计算一个哈希码，哈希吗是一个较小的值，并且不同键值计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</li></ul><blockquote><p><em>聚簇索引和非聚簇索引并不是单独的索引类型，而是一种数据存储方式</em> [高性能 MySQL]</p></blockquote><h4 id="索引的优点和缺点"><a href="#索引的优点和缺点" class="headerlink" title="索引的优点和缺点"></a>索引的优点和缺点</h4><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ul><li>索引大大减少减少了服务器需要扫描的数据量</li><li>索引可以帮助服务器避免排序和临时表</li><li>索引可以将随机 I/O 变为顺序 I/O</li></ul><h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><blockquote><p>索引的缺点主要是针对不合理索引而言的，对于开发者而言，索引维护所耗费的资源和索引所提供的快速查询能力节省的时间资源两者进行取舍。</p></blockquote><ul><li>创建和维护索引都需要耗费时间，而且随着数据量的增加而增加。</li><li>每个索引还需要耗费额外的物理空间资源。</li><li>当对表中的数据进行 CURD 操作的时候，索引也需要对应的动态维护，增加数据维护成本。</li></ul><h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><blockquote><p>MySQL 存储索引的时候一般我们没有明确之处其余结构就是指的是 B-Tree 数据结构存储索引。<a href="https://blog.csdn.net/linglongwunv/article/details/20066823" target="_blank" rel="noopener">参考资料</a></p></blockquote><blockquote><p>卫星数据：指的是索引元素所指向的数据记录，比如数据库的某一行。</p></blockquote><h4 id="磁盘-I-O"><a href="#磁盘-I-O" class="headerlink" title="磁盘 I/O"></a>磁盘 I/O</h4><ul><li>动态查询树主要有：二叉查找树，平衡二叉查找树，红黑树，B-Tree/B+Tree/B*Tree</li><li>前三者是典型的二叉查找树结构，其查找的时间复杂度O(log2N)与树的深度相关，那么降低树的深度自然对查找效率是有所提高的；还有一个实际问题：就是大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了），这样导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下，那么如何减少树的深度，一个基本的想法就是：采用多叉树结构（由于树节点元素数量是有限的，自然该节点的子树数量也就是有限的）。</li><li>关于硬盘(外存储器)的解读,磁盘获取数据由三部分时间组成:查找时间(代价最高),等待时间,传输时间.</li><li>磁盘读取数据是以盘块(block)为基本单位的。位于同一盘块中的所有数据都能被一次性全部读取出来。而磁盘IO代价主要花费在查找时间Ts上。因此我们应该尽量将相关信息存放在同一盘块，同一磁道中。或者至少放在同一柱面或相邻柱面上，以求在读/写信息时尽量减少磁头来回移动的次数，避免过多的查找时间Ts。</li><li>当我们利用索引查询的时候,显然不可能把整个索引全部加载到内存中,只能逐一加载每一个磁盘页,这里的磁盘页对应这索引树的节点.</li><li>在使用树结构查询的时候如果使用二叉树,那么磁盘的 IO 次数最坏情况下等于索引树的高度.此时索引树的高度就对查询资源至关重要.</li></ul><h4 id="B-Tree-Wiki"><a href="#B-Tree-Wiki" class="headerlink" title="B-Tree Wiki"></a>B-Tree <a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener">Wiki</a></h4><p><strong>什么是 B-Tree？</strong>一个 m 阶的 B 树有以下几个特征。</p><ol><li>根节点至少有两个子节点</li><li>每个中间节点都包含 K-1个元素和 K 个子节点，其中 m/2&lt;=k&lt;=m</li><li>每一个叶子节点都包含 K-1个元素，其中 m/2&lt;=k&lt;=m</li><li>所有的叶子节点都位于同一层</li><li>每个非终端节点中包含有 n 个关键词信息(n，P0，K1，P1，K2….Kn，Pn)<br> a. 其中 n 的取值范围是ceil(m/2)-1&lt;=n&lt;=m-1<br> b. Ki为关键字,且关键字按照顺序排序(K(i-1)&lt;Ki)<br> c. Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。[<strong>每个节点中的元素从小到大排列，节点当中 K-1个元素正好是 K 个孩子包含元素的值域划分</strong>]<img src="/2018/05/07/MySQL-%E7%B4%A2%E5%BC%95%E6%8E%A2%E7%B4%A2/B-Tree.png" class=""></li></ol><blockquote><p>模拟查找文件29的过程：</p></blockquote><blockquote><p> (1) 根据根结点指针找到文件目录的根磁盘块1，将其中的信息导入内存。【磁盘IO操作1次】</p></blockquote><blockquote><p> (2) 此时内存中有两个文件名17，35和三个存储其他磁盘页面地址的数据。根据算法我们发现17&lt;29&lt;35，因此我们找到指针p2。</p></blockquote><blockquote><p>(3) 根据p2指针，我们定位到磁盘块3，并将其中的信息导入内存。【磁盘IO操作2次】</p></blockquote><blockquote><p>(4) 此时内存中有两个文件名26，30和三个存储其他磁盘页面地址的数据。根据算法我们发现26&lt;29&lt;30，因此我们找到指针p2。</p></blockquote><blockquote><p>(5) 根据p2指针，我们定位到磁盘块8，并将其中的信息导入内存。【磁盘IO操作3次】</p></blockquote><blockquote><p>(6) 此时内存中有两个文件名28，29。根据算法我们查找到文件29，并定位了该文件内存的磁盘地址。</p></blockquote><blockquote><p>分析上面的过程，发现需要3次磁盘IO操作和3次内存查找操作。关于内存中的文件名查找，由于是一个有序表结构，可以利用折半查找提高效率。至于3次磁盘IO操作时影响整个B-tree查找效率的决定因素。</p></blockquote><blockquote><p>当然，如果我们使用平衡二叉树的磁盘存储结构来进行查找，磁盘IO操作最少4次，最多5次。而且文件越多，B-tree比平衡二叉树所用的磁盘IO操作次数将越少，效率也越高。</p></blockquote><img src="/2018/05/07/MySQL-%E7%B4%A2%E5%BC%95%E6%8E%A2%E7%B4%A2/1525599028356.png" class=""><p>B 树中每个节点都具有<strong>卫星数据</strong></p><h6 id="节点的插入"><a href="#节点的插入" class="headerlink" title="节点的插入"></a>节点的插入</h6><blockquote><p>插入（insert）操作：插入一个元素时，首先在B-tree中是否存在，如果不存在，即在叶子结点处结束，然后在叶子结点中插入该新的元素，注意：如果叶子结点空间足够，这里需要向右移动该叶子结点中大于新插入关键字的元素，如果空间满了以致没有足够的空间去添加新的元素，则将该结点进行“分裂”，将一半数量的关键字元素分裂到新的其相邻右结点中，中间关键字元素上移到父结点中（当然，如果父结点空间满了，也同样需要“分裂”操作），而且当结点中关键元素向右移动了，相关的指针也需要向右移。如果在根结点插入新元素，空间满了，则进行分裂操作，这样原来的根结点中的中间关键字元素向上移动到新的根结点中，因此导致树的高度增加一层。</p></blockquote><p>例:自顶向下查找4的节点位置，发现4应当插入到节点元素3，5之间</p><img src="/2018/05/07/MySQL-%E7%B4%A2%E5%BC%95%E6%8E%A2%E7%B4%A2/1525597344961.png" class=""><p>节点3，5已经是两元素节点，无法再增加。父亲节点 2， 6 也是两元素节点，也无法再增加。根节点9是单元素节点，可以升级为两元素节点。于是拆分节点3，5与节点2，6，让根节点9升级为两元素节点4，9。节点6独立为根节点的第二个孩子</p><img src="/2018/05/07/MySQL-%E7%B4%A2%E5%BC%95%E6%8E%A2%E7%B4%A2/1525597368111.png" class=""><h6 id="节点的删除操作"><a href="#节点的删除操作" class="headerlink" title="节点的删除操作"></a>节点的删除操作</h6><blockquote><p>删除(delete)操作：首先查找B-tree中需删除的元素,如果该元素在B-tree中存在，则将该元素在其结点中进行删除，如果删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素到父节点中，然后是移动之后的情况；如果没有，直接删除后，移动之后的情况.。</p></blockquote><blockquote><p>删除元素，移动相应元素之后，如果某结点中元素数目小于ceil(m/2)-1，则需要看其某相邻兄弟结点是否丰满（结点中元素个数大于ceil(m/2)-1），如果丰满，则向父节点借一个元素来满足条件；如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于ceil(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点，以此来满足条件。那咱们通过下面实例来详细了解吧。</p></blockquote><p>例:删除11节点</p><img src="/2018/05/07/MySQL-%E7%B4%A2%E5%BC%95%E6%8E%A2%E7%B4%A2/1525597390731.png" class=""><p>删除11后，节点12只有一个孩子，不符合B树规范。因此找出12,13,15三个节点的中位数13，取代节点12，而节点12自身下移成为第一个孩子。（这个过程称为左旋）</p><img src="/2018/05/07/MySQL-%E7%B4%A2%E5%BC%95%E6%8E%A2%E7%B4%A2/1525597423876.png" class=""><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h4><blockquote><p>B+Tree 是对于 B-Tree 的一种变体，有着比 B-Tree 更高的查询效率。</p></blockquote><p><strong>一个 m 阶的 B 树有着如下特点</strong></p><ol><li>有 K 个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</li><li>所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li><li>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</li></ol><img src="/2018/05/07/MySQL-%E7%B4%A2%E5%BC%95%E6%8E%A2%E7%B4%A2/1525598880919.png" class=""><p>根节点的最大元素等荣誉整个树的最大元素,叶子节点包含了全量元素信息,并且每一个叶子节点都带有指向下一个节点的指针,形成了一个有序链表.</p><img src="/2018/05/07/MySQL-%E7%B4%A2%E5%BC%95%E6%8E%A2%E7%B4%A2/1525598986414.png" class=""><p>在 B+Tree 树中,只有叶子节点保存卫星数据.</p><img src="/2018/05/07/MySQL-%E7%B4%A2%E5%BC%95%E6%8E%A2%E7%B4%A2/1525599206701.png" class=""><p>需要补充的是，在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。</p><p>由于 B+Tree 树的中间节点没有卫星数据，所以同样大小的磁盘也(1~4K)可以容纳更多的元素，意味着查询的 IO 次数越少。</p><p>另外，B+Tree 的查询必须最终查询到叶子节点，和 B-Tree 不同，查询性能最稳定，而且在范围查询中，比起只能以来繁琐的中序遍历的 B 树，更有效率。</p><p>综合来看，B+Tree 对比 B-Tree 有三大优势:</p><ol><li>单一节点存储更多的元素，使得查询的IO次数更少。</li><li>所有查询都要查找到叶子节点，查询性能稳定。</li><li>所有叶子节点形成有序链表，便于范围查询。</li></ol><h4 id="哈希索引-1"><a href="#哈希索引-1" class="headerlink" title="哈希索引"></a>哈希索引</h4><blockquote><p>关于哈希索引，目前 MySQL 中只有 Memory 和 NDB 两种引擎支持，详细了解可以参考这篇文章<a href="http://homeway.me/2015/09/13/mysql-hash-index/" target="_blank" rel="noopener">MySQL索引之哈希索引</a>，本文不在赘述。</p></blockquote><h3 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h3><blockquote><p>理解了索引的数据结构之后我们就理解了索引在创建和使用上的一些方法(以下所描述的索引均指的是 B-Tree 索引)。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> People (</span><br><span class="line">    last_name   <span class="built_in">varchar</span>(<span class="number">50</span>)     <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    first_name  <span class="built_in">varchar</span>(<span class="number">50</span>)     <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    dob         <span class="built_in">date</span>            <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    gendar      enum(<span class="string">'m'</span>,<span class="string">'f'</span>)   <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">key</span>(last_name, first_name, dob)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>使用 B-Tree 索引的查询类型适用于下列集中情况</li></ul><ol><li>全值匹配<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from People where last_name = &apos;Allen&apos; and first_name = &apos;Cuba&apos; and dob = &apos;1999-01-01&apos;;</span><br></pre></td></tr></table></figure></li><li>匹配最左前缀<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from People where last_name = &apos;Allen&apos;;</span><br></pre></td></tr></table></figure></li><li>匹配列前缀<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from People where last_name like &apos;A%&apos;;</span><br></pre></td></tr></table></figure></li><li>匹配范围值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from People where last_name &gt; &apos;Allen&apos; and last_name &lt; &apos;Bob&apos;;</span><br></pre></td></tr></table></figure></li><li>精确匹配某一列并范围匹配另外一列<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from People where last_name = &apos;Allen&apos; and last_name like &apos;B%&apos;;</span><br></pre></td></tr></table></figure></li><li>只访问索引的查询<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select  last_name, </span><br><span class="line">        first_name, </span><br><span class="line">        dob</span><br><span class="line">from People </span><br><span class="line">where   last_name = &apos;Allen&apos; </span><br><span class="line">    and first_name = &apos;Cuba&apos; </span><br><span class="line">    and dob = &apos;1999-01-01&apos;;</span><br></pre></td></tr></table></figure></li></ol><ul><li>关于使用索引的一些限制</li></ul><ol><li>如果不是按照索引的最左列开始查找，则无法使用索引<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from People where first_name = &apos;Allen&apos;;</span><br></pre></td></tr></table></figure></li><li>不能跳过索引中的列<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from People where last_name = &apos;Allen&apos; and dob = &apos;1999-01-01&apos;;</span><br></pre></td></tr></table></figure></li><li>如果查询中有某个列的范围查询，则其右边的所有咧都无法使用索引优化查询<pre><code>select * from People where last_name = &apos;Allen&apos; and first_name like &apos;J%&apos; and dob = &apos;1999-01-01&apos;;</code></pre><h5 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h5></li></ol><blockquote><p><a href="https://tech.meituan.com/mysql-index.html" target="_blank" rel="noopener">参考资料</a></p></blockquote><blockquote><ol><li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li></ol></blockquote><blockquote><ol start="2"><li>使用独立的列</li></ol></blockquote><blockquote><ol start="3"><li>多列索引：MySQL 从5.0之后的更新版本引入了一种叫<strong>索引合并</strong>的<a href="https://dev.mysql.com/doc/refman/5.6/en/index-merge-optimization.html" target="_blank" rel="noopener">策略</a>，关于这项策略可以参考<a href="http://www.cnblogs.com/digdeep/p/4975977.html" target="_blank" rel="noopener">MySQL 优化之 index merge</a></li></ol></blockquote><blockquote><ol start="4"><li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li></ol></blockquote><blockquote><ol start="5"><li>尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录</li><li>索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);</li><li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li></ol></blockquote><hr><p>一些有价值的参考资料</p><ul><li><a href="http://www.freeoa.net/osuport/db/mysql-index-using-study-note_2827.html" target="_blank" rel="noopener">http://www.freeoa.net/osuport/db/mysql-index-using-study-note_2827.html</a></li><li><a href="https://blog.csdn.net/alexdamiao/article/details/51934917" target="_blank" rel="noopener">https://blog.csdn.net/alexdamiao/article/details/51934917</a></li><li><a href="https://zhuanlan.zhihu.com/p/23624390" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23624390</a></li><li><a href="https://www.cnblogs.com/morvenhuang/archive/2009/03/30/1425534.html" target="_blank" rel="noopener">https://www.cnblogs.com/morvenhuang/archive/2009/03/30/1425534.html</a></li><li><a href="http://www.cnblogs.com/digdeep/p/4975977.html" target="_blank" rel="noopener">http://www.cnblogs.com/digdeep/p/4975977.html</a></li><li><a href="https://tech.meituan.com/mysql-index.html" target="_blank" rel="noopener">https://tech.meituan.com/mysql-index.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;关于索引，你想知道的事情&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="MySQL" scheme="https://wang-zc.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://wang-zc.github.io/2018/05/07/hello-world/"/>
    <id>https://wang-zc.github.io/2018/05/07/hello-world/</id>
    <published>2018-05-07T02:05:58.000Z</published>
    <updated>2018-05-07T02:05:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>High Availability PHP System</title>
    <link href="https://wang-zc.github.io/2017/07/07/High-Availability-PHP-System/"/>
    <id>https://wang-zc.github.io/2017/07/07/High-Availability-PHP-System/</id>
    <published>2017-07-07T15:41:14.000Z</published>
    <updated>2018-05-07T15:44:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>自从去北京参加完 Devlink 的 PHP 开发者大会回来一直没有和小伙伴分享得到的收获,这次准备了一个 KeyNote 来讲述</p></blockquote><img src="/2017/07/07/High-Availability-PHP-System/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84PHP.001.jpeg" class=""><img src="/2017/07/07/High-Availability-PHP-System/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84PHP.002.jpeg" class=""><img src="/2017/07/07/High-Availability-PHP-System/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84PHP.003.jpeg" class=""><img src="/2017/07/07/High-Availability-PHP-System/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84PHP.004.jpeg" class=""><img src="/2017/07/07/High-Availability-PHP-System/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84PHP.005.jpeg" class=""><img src="/2017/07/07/High-Availability-PHP-System/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84PHP.006.jpeg" class=""><img src="/2017/07/07/High-Availability-PHP-System/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84PHP.007.jpeg" class=""><img src="/2017/07/07/High-Availability-PHP-System/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84PHP.008.jpeg" class=""><img src="/2017/07/07/High-Availability-PHP-System/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84PHP.009.jpeg" class=""><img src="/2017/07/07/High-Availability-PHP-System/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84PHP.010.jpeg" class=""><img src="/2017/07/07/High-Availability-PHP-System/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84PHP.011.jpeg" class=""><img src="/2017/07/07/High-Availability-PHP-System/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84PHP.012.jpeg" class="">]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;自从去北京参加完 Devlink 的 PHP 开发者大会回来一直没有和小伙伴分享得到的收获,这次准备了一个 KeyNote 来讲述&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;/2017/07/07/High-Availability-
      
    
    </summary>
    
    
    
      <category term="PHP" scheme="https://wang-zc.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>艺龙搬砖项目复盘</title>
    <link href="https://wang-zc.github.io/2017/04/17/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/"/>
    <id>https://wang-zc.github.io/2017/04/17/艺龙搬砖项目复盘/</id>
    <published>2017-04-17T15:46:36.000Z</published>
    <updated>2018-05-07T15:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>艺龙的搬砖项目可以说是接受挑战比较大的项目了,做完之后来了一次复盘</p></blockquote><img src="/2017/04/17/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E5%A4%8D%E7%9B%98.001.jpeg" class=""><img src="/2017/04/17/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E5%A4%8D%E7%9B%98.002.jpeg" class=""><img src="/2017/04/17/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E5%A4%8D%E7%9B%98.003.jpeg" class=""><img src="/2017/04/17/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E5%A4%8D%E7%9B%98.004.jpeg" class=""><img src="/2017/04/17/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E5%A4%8D%E7%9B%98.005.jpeg" class=""><img src="/2017/04/17/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E5%A4%8D%E7%9B%98.006.jpeg" class=""><img src="/2017/04/17/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E5%A4%8D%E7%9B%98.007.jpeg" class=""><img src="/2017/04/17/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E5%A4%8D%E7%9B%98.008.jpeg" class=""><img src="/2017/04/17/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E5%A4%8D%E7%9B%98.009.jpeg" class=""><img src="/2017/04/17/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E5%A4%8D%E7%9B%98.010.jpeg" class=""><img src="/2017/04/17/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E5%A4%8D%E7%9B%98.011.jpeg" class=""><img src="/2017/04/17/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E5%A4%8D%E7%9B%98.012.jpeg" class=""><img src="/2017/04/17/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E5%A4%8D%E7%9B%98.013.jpeg" class=""><img src="/2017/04/17/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E5%A4%8D%E7%9B%98.014.jpeg" class="">]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;艺龙的搬砖项目可以说是接受挑战比较大的项目了,做完之后来了一次复盘&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;/2017/04/17/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E9%A1%B9%E7%9
      
    
    </summary>
    
    
    
      <category term="项目成长" scheme="https://wang-zc.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>华衫讲孙子兵法读后感</title>
    <link href="https://wang-zc.github.io/2016/12/05/%E5%8D%8E%E8%A1%AB%E8%AE%B2%E5%AD%99%E5%AD%90%E5%85%B5%E6%B3%95%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    <id>https://wang-zc.github.io/2016/12/05/华衫讲孙子兵法读后感/</id>
    <published>2016-12-05T15:36:08.000Z</published>
    <updated>2018-05-07T15:39:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天读完了《华衫讲透孙子兵法》，这本书对我而言读起来还是比较费劲的，一些概念理解起来比较难，其中掺杂着一些注解，在最一开始去理解文言文的意思，经常出错，需要不断的去查古文字典来校对，但是读到后面结合着华杉讲大白话文慢慢的啃下来。读完最大的感触是，哇，这本书，今后十年都值得我反复去读。</p><p>言归正传，这本书一共十三章</p><ul><li>计篇</li><li>作战</li><li>谋攻</li><li>军行</li><li>兵势</li><li>虚实</li><li>军争</li><li>九变</li><li>行军</li><li>地形</li><li>九地</li><li>火攻</li><li>用间<br>如果时间紧的话，可以仔细查阅下第一章《计篇》，孙子兵法最精髓的文字都在这一章了。我个人在读书的时候也是会经常性的翻回第一章，因为后面的很多内容都是对第一章的解读，孙子兵法自春秋战国起至今已经两千七百多年的历史了，被各个朝代君王或将领解读的更是数不胜数，短短几天我肯定不会悟出什么大道理哈哈哈，否则我就是圣人了（虽然我一直很崇拜王阳明…）只有一些切身的体会写出来共享一下，权作纪念吧。</li></ul><blockquote><p>“兵者，国之大事，死生之道，存亡之道，不可不察也”</p></blockquote><p>这句话是计篇的第一句话，也说出了孙子的价值观，孙子兵法研究的不是战之法，其实是不战之法，这一直是我的错误理解，之前一说孙子兵法，总和三十六计联系起来，受到了很多误导，孙子兵法讲的通篇都是讲堂堂正正之道，“五事七计”，道、天、地、将、法，关乎国计民生，生死存亡。又怎么会是明修栈道、暗度陈仓的阴谋诡计呢（笑…</p><p>道为民，为民愿，说个大白话就是广大人民的根本利益，要师出有名，正义不正义这种事情需要这场战争结束了几十年一百年之后才会盖棺定论，所以要想在道上胜出就要靠宣传机器，国家的宣传机器甚至比战争机器还要重要，什么狐狸叫，鱼藏刀都是常用的手段，老百姓信啥，就给他搞啥，这样就能集合众心众力，再套一句大白话（老乡，跟着红军有地分啊）就明白啥意思了。<br>天为军事气象学，阴阳为气势，寒暑为时令。还涉及到了“势”..比较玄..</p><p>地为地形，散、轻、争、交、衢、重、圮、围、死九种地名</p><p>将者，智、信、仁、勇、严也，这一条涉及到了选将任能，一些管理的知识，我没有太理解其中很多的话语是否有更深层次的解读，也和我的本身经历有关，没有过管理的经历～<br>法，也为管理，想想也是，两军交战就是那么一下子刺激，其余绝大多数时间都是在军营中操练士卒，如何制订军法，如何管理部下，都是大学问，要么刘邦问韩信说，我能带多少兵？韩信说：“主公，十万兵，不能更多了”。刘邦问：“你呢？”，韩信说：“多多益善”。管理的学问就在此处。</p><p>在孙子兵法中，有一点是多处体现的 ：“胜兵先胜而后求战，败兵先战而后求胜”，这句话简直是….精彩绝伦！要让自己不可战胜，顺便打一场稳赢的仗，最好能不打，直接招降算了。而且所谓胜利不是指的是消灭敌人就叫胜利了，关键是自己变得强了还是弱了，如果杀敌一千，自损八百，很难说是不是胜利。我也没办法做很多的解读，处于只可意会不能言传的状态…囧</p><p>知己知彼，百战不殆。这句话流传甚广，大家的重点很容易想到知彼上去，这一点在兵法中也有体现，就是最后一章《用间》，但是真正重要的其实是知己啊，“不知彼而知己，一胜一负；不知彼，不知己，每战必败”，知晓自己的优势和劣势，扬长避短，让敌人无法分清你的虚实，调动敌人而不被敌人调动，兵法云：故善战者，致人而不致于人。</p><p>最后说说心，“以治待乱，以静待哗，此治心者也”，这里有很深的感悟，因为最近自己深处的环境不是特别安稳，有一种隐而未发的动荡感，总感觉工作和生活都比较不在节奏上，看到何氏注解的那一段的时候心有悸动。原注如下：</p><blockquote><p>吾之治足以待乱，吾之静足以待哗，前有百万之敌，而吾视之，则如遇小寇。亚夫之遇寇也，坚卧不起；栾箴之临敌也，好以整，又好以暇。夫审此二人，蕴以何术哉？盖其心智之所有素，养之有余也。</p></blockquote><p>海纳百川，有容乃大，壁立千仞，无欲则刚。治自己的心，是一切的根本。</p><p>但是读的时候也有很多地方不理解，甚至不认同，兵法一书，也绝不可能面面具到，把所有的人生大道理都给你讲的透透的，要不然还要那么多文人注解作何用，一本周易永流传了。但是读兵法带给人的感受是读其它书籍全然未有过的，兵法讲的是计，讲的是胸怀天下，登高望远，现在的我们虽然不可能把孙子叫回来让他老人家给你解释一下，但是通过看兵法，稍加体会亦能受益无穷。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天读完了《华衫讲透孙子兵法》，这本书对我而言读起来还是比较费劲的，一些概念理解起来比较难，其中掺杂着一些注解，在最一开始去理解文言文的意思，经常出错，需要不断的去查古文字典来校对，但是读到后面结合着华杉讲大白话文慢慢的啃下来。读完最大的感触是，哇，这本书，今后十年都值得我
      
    
    </summary>
    
    
    
      <category term="读书笔记" scheme="https://wang-zc.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>支付战争</title>
    <link href="https://wang-zc.github.io/2016/11/20/%E6%94%AF%E4%BB%98%E6%88%98%E4%BA%89/"/>
    <id>https://wang-zc.github.io/2016/11/20/支付战争/</id>
    <published>2016-11-20T15:33:16.000Z</published>
    <updated>2018-05-07T15:39:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>周六和朋友打羽毛球打得肉疼不已…趁着周天下雨的功夫把《支付战争》读完了，埃里克写的很好，读起来酣畅淋漓，仿佛自己就在世纪初的PayPal公司和他们一起经历这些起起伏伏。创业这个事儿真是不容易。</p><p>1999年，那个时候马云和他的十八罗汉在杭州建立阿里巴巴，在太平洋的另一边有一群疯狂而有充满激情的人开始了他们的创业之路，彼得·蒂尔和马克斯·列夫琴一起组建了一家公司立志于解决支付问题，我想大概从那时开始创业公司就有了这种调性，就像埃里克在书中说的那样“混乱的办公室，热情洋溢不知道谁是谁的同事们，这是一群心底的狂人，欢迎来到创业公司”。混乱之中蕴含着无尽的想象力和可能性，这是在CBD的格子间里绝对不会感受到的。就像很多的电影中描绘的那样，这家年轻充满活力的公司走上了漫长的统治世界之路。</p><p>但是在小的公司也会有对手存在，除非你马上小的关门了，几个月后PayPal迎来了他的对手们，dotBank和X.com，似乎大家意识到支付领域的美味，都想进来分一杯羹。在同对手不断的竞争中，PayPal也对自己的业务进行了明确的定位，专注于拍卖领域，想尽一切办法拓展新用户，有用户才有未来嘛。此时的PayPal无疑是整个发展阶段最有吸引力的时候，在这个阶段，紧张刺激的竞争，新行业的急先锋，充满希望的伟大愿景使得大量人才纷涌而至，这些激情洋溢的年轻人成就了日后名震世界的PayPal黑帮…不过创业公司都是最烧钱的公司，尤其是像PayPal这样立足于新兴行业需要教育用户的公司无疑更是烧的厉害，要想走的更远就需要尽快消灭对手，壮大自己，在这种强敌环伺的情况下PayPal要想走下去就不可避免的选择了消灭对手的另外一种方式：合并。PayPal和X.com进行了合并，成功的甩开了其他的竞争对手，成为行业内的领先者。但是每一次合并都是对公司文化的冲击和考验，X.com有着其完全不同的文化氛围（从他们的工程师喜欢用Windows就知道了。。）PayPal在这次合并过程中占据弱势，尤其是在马斯克任职CEO之后，有着“钢铁侠”之称的埃隆·马斯克从来都不是好惹的人，在公司的整合之中，PayPal的品牌危机、产品危机、客服危机不断爆发，支付业务所依赖的巨头eBay也开始反击，2000年的上半年对PayPal来说充满恶意。</p><p>在接下来的业务转型中，PayPal开始艰难的从一个免费的互联网服务变成一个成功的付费服务，产品的艰难转型，用户的谩骂，财政赤字的上涨，诈骗团伙的虎视眈眈令人绝望。马斯克领导下的PayPal不可避免的走向深渊，而长久以来的文化交锋也日益激烈，PayPal诞生后最激烈的罢免就在这样的环境下产生了，马斯克下台，蒂尔重新执掌公司，到这里不禁判断出，对PayPal而言，蒂尔才是他们的精神领袖，而马斯克不是，但是对X.com的人来说又恰好相反，公司文化这种东西真是妙不可言。事实上蒂尔真的给人惊喜，在蒂尔执掌公司之后，PayPal全力削减成本，账户升级高达95%，诈骗损失被遏制住，说是力挽狂澜也丝毫不为过。</p><p>但是PayPal自始至终都有一个强大的对手，PayPal的大多数业务都依赖于拍卖平台eBay，而当eBay开始发力做支付时，来自于垄断者和重量级平台的威胁让人喘不过气来。孙子兵法有句话：昔之善战者，先为不可胜，以待敌之可胜。在这样的情况下，最大化的利用自己的优势，等待eBay自己露出马脚，然后用尽全力主动出击才有一线生机，当面对这样一个对手的时候，怎么重视都不为过。但是面对这样一个对手，结局也很简单，要么创新业务，脱离依赖，要么被平台收购结束持久战。在经历了各种波折的IPO之后，eBay以15亿美元收购PayPal，在新一步的公司整合中，蒂尔离职，PayPal黑帮各自离职创业。如今的PayPal也已经成为支付业的巨头，难以撼动。</p><p>在读这本书的过程中，穿插着很多条线，而我对其中的两条线特别感兴趣，一条是技术发展，一条是公司文化。两条线又相互交缠在一起。技术在PayPal的发展中是至关重要的一环，早期通过工程师在eBay页面上作嵌入标记开展了PayPal在拍卖支付业务，在获取用户的过程中退出的网络买手机器人计划让PayPal在最初的竞争中占据了先发优势。在和X.com的整合过程中，技术冲突是公司文化冲突的主战场，（X.com的工程师喜欢在Windows平台上工作，而马克斯·列夫琴领导的PayPal团队在Unix平台上工作，这不亚于宗教战争啊同志们！！）工程团队的混乱导致公司无法向前推进，因为在互联网创业公司，技术绝对是根基的存在，没有牢固的技术架构，业务模型无法扩大和发展。统一平台，统一管理，是PayPal走下去必须解决的问题，在发展过程中，马克斯着力于使用技术手段遏制诈骗损失，推出了大名鼎鼎的“列夫琴测试”和“伊戈尔”扫描程序，相信如今所有的人都或多或少的使用接触过这项技术。2000年推出的验证码，被沿用至今，一项伟大的发明。作为一名工程人员，最大的幸福也莫过于此吧。。。而在后期的发展中，工程师们总是表现最明显的一员，IPO时八点五十就到公司了。。啧啧真可怕。。 ：）</p><p>读完之后对马克斯·列夫琴充满好奇和敬佩。</p><p>希望成为这样的人</p><p>ps：还有好多好多的支线…天太冷了，不想写了…干脆把提纲贴出哈哈哈</p><p>想想下一本书看啥呢。。。</p><img src="/2016/11/20/%E6%94%AF%E4%BB%98%E6%88%98%E4%BA%89/pic1.jpg" class=""><img src="/2016/11/20/%E6%94%AF%E4%BB%98%E6%88%98%E4%BA%89/pic2.jpg" class=""><img src="/2016/11/20/%E6%94%AF%E4%BB%98%E6%88%98%E4%BA%89/pic3.jpg" class="">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;周六和朋友打羽毛球打得肉疼不已…趁着周天下雨的功夫把《支付战争》读完了，埃里克写的很好，读起来酣畅淋漓，仿佛自己就在世纪初的PayPal公司和他们一起经历这些起起伏伏。创业这个事儿真是不容易。&lt;/p&gt;
&lt;p&gt;1999年，那个时候马云和他的十八罗汉在杭州建立阿里巴巴，在太平洋
      
    
    </summary>
    
    
    
      <category term="读书笔记" scheme="https://wang-zc.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>精益创业实战</title>
    <link href="https://wang-zc.github.io/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/"/>
    <id>https://wang-zc.github.io/2016/11/07/精益创业实战/</id>
    <published>2016-11-07T15:26:47.000Z</published>
    <updated>2018-05-07T15:52:18.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这周某个时候和卢大哥讨论起了软件测试的问题，很巧的是我们有一些不同的看法，这个时候大哥给给我递了一本书，年轻人多看书，多看报，少吃零食早睡觉，一脸不信的我接过了书趁着周末这两天窝在北邮的自习室里读完了这本《精益创业实战》，一本好书，值得多读几遍。</p></blockquote><blockquote><p>本书的作者是Ash Maurya，以下简称老A..写作者的话嗯..严肃了……</p></blockquote><p>－－－－－－－－－－－－－－－－－－</p><p>目录是很吸引人的地方，打个比喻，你和一个人相亲，绝大多数情况下，估计会先看看这个人的照片，如果还感兴趣的话听听别人的评价，和读书是一样一样滴，看看目录，读读序言，心里大致对这本书有个模糊的认知，接下来就是带着疑问和思考去读书啦。</p><p>身处一家互联网创业公司，而且还是在中关村这片地儿，早上卖煎饼果子的大爷都能和你掰扯两句商业模式，时间久了总会或多或少的了解到一些创业的知识，然后便肃然起敬。我敬佩创业的人，在我看来创业者们是一群实干家，是一群心底里想做点事儿的人，做的好坏成败暂且搁置，有这份勇气就值得敬佩。</p><p>这本书按照目录走，全书分为四部分</p><p>－ 总章</p><p>－ 把A计划写下来</p><p>－ 找到计划中风险最高的部分</p><p>－ 系统的测试计划</p><p>老A在阐述自己方法的同时拿自己创办的公司 CloudFire 举例，一步一步的向读者展示他对于精益创业方法论的认知和在创业过程中的实践。我个人最感兴趣的章节是在对系统的测试中对于用户的访谈这一片段，针对问题作用户访谈，针对解决方案作用户访谈，针对MVP作用户访谈。读起来真是大开眼界，因为日常工作是研发为主，几乎没有和用户打过交道，所以读起来对这几个章节格外感兴趣，读出了和人沟通的无限可能性哈哈哈哈…但是读这本书的时候令我困惑的地方是“渠道”和“控制风险”，内联和外联，亲力亲为与自动化，在读完全书回过头去试图做出解答的时候也没有得出自己满意的答案，看来还是修炼不够啊，好好修炼去吧。</p><p>把A计划写下来，老A是这么说的，什么是A计划呢，通俗来说大家记得用来嘲笑程序员的一句话嘛“我有一个好点子，就差一个写代码的了”，这里面的“好点子”就指的是A计划，就像是创业者的一次灵光，产品经理失眠整晚碰到清晨的第一缕阳光…嗯，反正就是这种东西，大家体会一下….但是A计划和青春期的小伙子一样靠不住，大多数A计划都迈着无比沉重的步伐走向各自的八宝山..为了留住这些不靠谱的电子，老A给大家想了一个方法：精益画布。这也是贯穿整本书的灵魂所在，整本书就是在不断的完善它，证伪它，完善它。做好你的精益画布，你的A计划也就写下来了。看下图，精益画布长这样…</p><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/note.png" class=""><p>在接触到精益画布之后我遇到了一个没有认识过的概念“早期接触者”，各位产品经理们不要笑…在下真是第一次接触这块东西，你们想笑的还在后面呢…囧…早期接纳者在我看来应该是被问题困扰最深的那拨人，已经快要忍不住了，啥产品出来以后都抱着死马能当活马医的心态用一用，只要能解决问题，缓解一下都成，让我想起了地方台那些卖药广告的群演老大爷们（我抱着试一试的心态买了这个药，腰也不疼了，腿也不酸了，也能下地干活了…）但是早期接纳者也有一个问题是，TA可能会和你的用户有很大的不一样，这意味着你的产品会遭受到一定程度上的误导?但是先不要想那么远啦，八字还没有一撇呢，精益画布很有效的一点是能落在实处，你的产品创造，你的商业思维，你的营销策略都可以从这一张画布上发散开来，而且以此为基础，你会不断的迭代优化，最起码你心里有底在，我这个东西是干嘛的，卖给谁，咋赚钱，咋发展，咋跑路。。。blabla。。。如果你不会看的话，老A还在书里贴心地介绍了一套产品数据的指标“海盗指标组”。</p><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/pic.png" class=""><p>找出计划中风险最高的部分，说实话我对这部分不是特别明白，有一句我觉得应该是这部分的点睛之笔：构建产品的本质就是控制风险。我只能浅浅的理解一下这句话的意思，并没有领悟到老A想告诉的其它含义😅 。在精益画布的帮助下我尝试去解读这句话的意思，在你的产品模式中，最难的应该是独特卖点这一个地方，你要告诉你的用户，来买我的服务吧，你在别家买不到的。每一个非垄断行业里都想一个热火朝天的大卖场，老板们在台后面不断的叫喊着，来啊～来啊～，看看我啊～，使出浑身解数，这个暖萌，那个高冷…咳咳…向一个喜欢二次元的宅男宣传户外我觉得这就是最大的风险，在确认风险的时候首先你要证伪，这一点着实让我大吃一惊，证伪这一点确实是之前没有考虑过的事情，如果跳过这一步的话就是努力的向着死胡同奔跑，所以毫无疑问这一点非常重要，那么如何证伪呢？在控制风险这一章里，定性验证，定量核实是老A提出的方法，关于这一点我理解的奥义在于小步快跑，不断纠正方向，在你的产品服务没有大卖特卖之前，市场不知道你的存在，这个时候如果你想知道市场的反馈那就抓住一切可以学习的机会快速学习，先做个小Demo拿着先上，找几个用户聊一聊，尽快修正，这样的话无论是正面反馈还是负面反馈都会让你做出快速的响应，否则死都不知道怎么死的。。。</p><p>老A花了大量的篇幅来讲系统的测试计划这一章，而这一章也着实重要，系统的测试指的是用高效的方法和最小的成本来获取反馈，从反馈中提取精华，快速迭代。这也是我最感兴趣的一点，在和用户的沟通中，提取出他们真正的需求，福特先生有过一句很出名的话：如果你问用户要什么，他们会说要一匹更快的马。从这句话中不难看出，如果提炼用户需求，搞清楚用户的世界是一个很考验人能力的工作。面对用户之前，一定一定要做到一点，了解自己的问题。连自己都没搞定，怎么去搞定用户呢，其次哈哈哈哈，最好玩的地方是在和用户交流的过程中，探索用户的价值观…要命啦，这一点我觉得有点玄学的特点，但是也并不难，因为人们会很愿意和陌生人吐露自己的真实想法，和熟人反而更难。了解用户存在的问题，不要引导用户的回答，一步一步的引诱着他吐露自己纯洁或者猥琐的内心世界… </p><p>在做用户访谈的时候（ 尤其是早期确定早期接纳者的阶段 ）放弃那些没什么共鸣的人群，同时还有一点值得警惕的是放弃那些不遵守商业规则和契约的人，这些人给你带来的负面影响远远大于正面影响，放弃那些屌丝老板们。针对问题作用户访谈的时候注意用户对问题的描述和你对问题的理解是否存在偏差，存在于什么地方，为什么会存在这样的偏差，不断的拷问自己找到最终的问题所在。在针对解决方案作用户访谈的时候展示自己的解决方案，诱导用户产生兴趣，（ 问题是由两方面引起的，一是痛苦，二是欲望。老A说的太精辟了.. ）在和用户的交流中关注用户的反应，这在价格验证的时候是一个很重要的依据。</p><p>在成功的造出了1.0版本之后就进入了不断的学习环节，通过市场反应不断调节产品，使得产品和市场的匹配程度越来越高，同时给创业者更严峻的考验是活下去，前段时间有句话很冷，但是又很火那就是“Winter is coming.”那么这段时间大家都是穿上了秋衣秋裤挤一挤艰难过冬，在没有暖气还有雾霾的日子里，创业者们要努力的让自己的公司活下去，活到下一个春天来临，大浪淘沙啊。。。</p><p>读完这本书之后我发现了几处我常犯的错误，虽然我不是创业者，只是程序猿（ 你看，我就犯了一个错误 ）。。。</p><ul><li><p>过早的优化，在日常工作中，经常不断的优化代码，心心念念的想着优化业务逻辑，君不见Teambition里的todo list还有一长串呢。一定不要提早优化，在上线初期过早的优化代码和下雨前擦车一样傻。</p></li><li><p>是注意资源的浪费，在开发的某些时候会碰到一些奇奇怪怪的问题，比如网络问题，比如一些硬件玄学问题。。但是有时候执拗起来又拽着问题不放，不经意间就造成了对人力成本的极大浪费。这样非常不好。</p></li><li><p>是理想化追求，想文中开头提到的自动化测试和单元测试，因为之前开发过程中并没有做到单元测试，而且也并非是TDD开发，所以在开发过程中我并没有参与到测试这一环中，都是由专门负责测试任务的同事进行测试工作。但是在接触到的很多文章和讲座里多提到了开发参与测试的重要性，我仍然对这一点持有疑惑，但是在正确的时间做正确的事情，这一点我深信不疑。</p></li></ul><p>关于这本书还有好多问题没有得出结论，大多都是和用户，和产品相关的问题，看来需要补一补这方面知识了。。。</p><blockquote><p>期待下一次在读这本书会有新收获。</p></blockquote><p>本书后来做了一次 KeyNote 和办公室的小伙伴分享</p><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%8D%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98.001.jpeg" class=""><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%8D%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98.002.jpeg" class=""><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%8D%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98.003.jpeg" class=""><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%8D%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98.004.jpeg" class=""><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%8D%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98.005.jpeg" class=""><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%8D%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98.006.jpeg" class=""><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%8D%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98.007.jpeg" class=""><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%8D%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98.008.jpeg" class=""><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%8D%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98.009.jpeg" class=""><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%8D%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98.010.jpeg" class=""><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%8D%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98.011.jpeg" class=""><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%8D%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98.012.jpeg" class=""><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%8D%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98.013.jpeg" class=""><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%8D%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98.014.jpeg" class=""><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%8D%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98.015.jpeg" class=""><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%8D%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98.016.jpeg" class=""><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%8D%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98.017.jpeg" class=""><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%8D%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98.018.jpeg" class=""><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%8D%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98.019.jpeg" class=""><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%8D%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98.020.jpeg" class=""><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%8D%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98.021.jpeg" class=""><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%8D%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98.022.jpeg" class=""><img src="/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%8D%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98.023.jpeg" class="">]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这周某个时候和卢大哥讨论起了软件测试的问题，很巧的是我们有一些不同的看法，这个时候大哥给给我递了一本书，年轻人多看书，多看报，少吃零食早睡觉，一脸不信的我接过了书趁着周末这两天窝在北邮的自习室里读完了这本《精益创业实战》，一本好书，值得多读几遍。&lt;
      
    
    </summary>
    
    
    
      <category term="读书笔记" scheme="https://wang-zc.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>人际互动的秘密</title>
    <link href="https://wang-zc.github.io/2016/09/02/%E4%BA%BA%E9%99%85%E4%BA%92%E5%8A%A8%E7%9A%84%E7%A7%98%E5%AF%86/"/>
    <id>https://wang-zc.github.io/2016/09/02/人际互动的秘密/</id>
    <published>2016-09-02T15:20:30.000Z</published>
    <updated>2018-05-07T15:39:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每个人都是孤独的，都生活在独立的世界中，孤独的出生，孤独的死亡。纵然哪些欢声笑语的人也有一个孤单的心灵，因为地球本就是孤独的，远处只有二向箔在默默地注视着你.</p></blockquote><p>前一段时间正好赶上李松蔚老师讲心理学的Live，我就屁颠屁颠的买了一期，听完很多收获，下面主要是整理了一下李松蔚老师的过程，其中混杂着自己的感触，算是一篇Live笔记了，下面整理了李老师讲述的几个要点供参考…</p><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>授权是互动过程的一部分。互动是双方或者多方的关系，老话说的是一个巴掌拍不响就是这个理儿。互动一定是一个相互依存的关系，不能割裂。<br>说到互动，这里有有一个很基础的观点，授权。互动和授权的关系很像是数理逻辑的充分必要条件这种依赖关系，又有点像是Venn图的数学关系（这方面见仁见智了…）。<br>举个例子，当一个女生讲，“我被这个渣男毁掉了一生”。看起来是在这个女生和渣男的交往过程中，渣男参与进来毁掉了女生的一生。但是这里浮现出了“授权”的概念，这里的逻辑是这样的，在交往过程中，这个女生授权这个渣男毁掉了她的一生，她选择相信这个渣男毁掉了你的一生…<br>在人际交往中，只要一个人做的事情或者一些事物对你产生了影响，这里面一定有你的授权。比如说当你打开这个微信，看这篇文章，就是你在授权它影响你。是因为你的授权，你的所作所为，所以这篇文章才会对你产生影响。<br>互动在授权的基础上可以拆分成下面着两个进程</p><ol><li>他做了一些事情</li><li>你授权他的行为对你产生影响<br>互动需要对方的授权，是一个相互配合的事情。<br>现在社会上有一些相对狭隘的想法，就忽略了这一点，在互动的过程一方感觉自己的话是有魔力的，可以带动另一方的情绪，自己的某种话语魔力（活着人格魅力或者什么肢体动作乱七八糟的鸟东西），导致对方受到了某种影响，这种魔力有好多个名字，掌控感，领导力，leadership诸如此类，但是这样会陷入一个很尴尬的地位，完全忽略了另一方的配合，忽略了和你沟通的对象的存在了，我们把授权的概念拉到这个场景下解释一下其实是由于对方配合你，才让你认为自己产生某种魔力。才让你产生这种虚妄的感觉。（可以想象两个极端场景［1］大哥给小弟讲心灵鸡汤［2］阿谀奉承 ）<br> 在互动中有两条规则是存在的，这两条规则李松蔚老师称之为元规则。</li></ol><ul><li>你在人际互动中可以做任何事 （没有束缚，没有规则）</li><li>你不能控制这件事的结果（无法预测）<br>  举一个最当下的例子：我可以在这篇文章里写任何东西，美好的，肮脏的，哲学的，数理的等等等等任何事情，包括犯法的，乱伦的事情，都是可以的。法律和道德是社会后来加的基本规则，我们在互动中可以做任何事情。但是我无法控制我做完之后产生的后果，触犯了法律，违背了社会公德，会遭受到国家机器的惩罚，世俗人民的谴责（谩骂）或者写了一篇好文章第二天发现自己成为名人了?…被读者骂等等等等。<br>当我发现我写了一篇文章被读者骂的很惨，心里觉得十分气愤，这个时候套用授权的概念是我授权让别人的文字对我产生了影响。所有的互动中肯定会有授权的存在，你的所做所为都是因为你授权这件事情，这个人，这些事物影响到了你。</li></ul><h3 id="不可知论"><a href="#不可知论" class="headerlink" title="不可知论"></a>不可知论</h3><p>我们只能感知自己的情绪。任何除你之外的其他人，其他事都是不可知的，我们唯一能确定的有且仅有我们自己的感受。当别人的情绪对你产生影响的时候本质上来讲其实是一个不可知的事物给你带来了你自己可以确定的对你的影响。<br>举个例子：某一天因为公司业绩达到了目标，CEO在公司内部发表了激情洋溢的演说，但是现场的人员反馈没有CEO预想的热烈，零星点点几片掌声（没办法，研发就是这个鸟样子。。。囧。。），然后呢CEO觉得不太开心。这个月没奖金发了！<br><strong>拆分一下</strong></p><ol><li>这个例子里面CEO的讲话对员工产生的影响是无法预测的（你永远都不知道别人在想什么）</li><li>员工表现不是特别积极，CEO在心里会根据这些反馈得出一个消极的结论（@warn:这里是CEO授权让这些反馈影响到了他自己）从而产生了一个挫败的感觉，CEO不知道员工是不是喜欢他的演讲，但是CEO心里猜想员工可能不喜欢他的演讲，从而产生了挫败的情绪</li><li>员工的感觉是不可知的，但是CEO的挫败情绪是我们确定一定以及肯定可知的！</li></ol><p><strong>拆分结束</strong><br>我们顺利的从不可知回到了可知，归结起来尝试这样去理解：别人的想法和状态是不可知的，不可信的，那是别人的事情，但是在这些别人的情绪反馈里我们产生了自己的可能性推论，虽然我们无法验证这种可能性，但是我们授权这种可能性对我们自己产生影响。</p><h3 id="课题分离"><a href="#课题分离" class="headerlink" title="课题分离"></a>课题分离</h3><p>我们只能处理自己的情绪。在一段人际关系中，基于上面的不可知论，我们永远无法知道别人的感受，永远只能处理自己的感受课题，因为只有我们自己的感受是我们真正能感受到的，真正能把握的。<br>举个例子，我做了一件事情让别人不舒服了，那我是否需要处理别人的不舒服? 不需要。因为你不知道他是不是真的不舒服，就算他明白的告诉你你让他不舒服了，也只是你选择相信了你的选择而已（见第一节）。别人的情绪让别人去处理，你无法处理，你能处理的只是你自己的情绪，你自己的可知感受。<br>那这样的话是不是™就可以不负责任了呢？不是的，处理自己的感受，别人的感受让别人处理，这是一条元规则，参考组成世界的普朗克常数，我让别人不舒服了并不会直接推导出我要去处理别人的不舒服，这里跳过了一环，你让别人不舒服了，你自己感觉很内疚，你去处理别人的不舒服其实是在解决你的内疚，不是处理别人的不舒服，在重申一遍，别人的情绪只能让别人去处理。<br>做一道习题，一个女生说，我妈妈不喜欢我染头发，我不染了。这里的逻辑有问题吗？<br>Of course，这个女生说我妈妈不喜欢我染头发，我不染了，但是中间欠缺了一环就是这个女生自己的感受，她妈妈不喜欢她染头发，对她产生了某种影戏那个，她感到害怕之类的情绪，因为她的这些情绪，所以她选择了不染头发。我们做出一些决定并不是因为别人的原因，而是因为要抚平我们自己的情绪，课题分离的原则体现在我们只能处理我们自己的情绪，即使我们是因为别人的某种反应做出了一些调整，但是这个调整的原因实际上是我们对于别人的某种反应得出来的某种反应或者某种映像作出的调整。</p><h3 id="一个完整的人际反射"><a href="#一个完整的人际反射" class="headerlink" title="一个完整的人际反射"></a>一个完整的人际反射</h3><ul><li>对方做了什么</li><li>对方做的事情对我来说意味着什么</li><li>我做什么，来应对我的情绪<br>当两个人的反射拼接到一起就形成了一个循环的互动链条，这里可以参考下计算机科学里面的TCP握手协议.</li></ul><p>感兴趣的可以点击查看原文看下李松蔚老师的<a href="https://mp.weixin.qq.com/s?__biz=MzA4NTI3NTkyNQ==&mid=2654002622&idx=1&sn=bfc18f40b042628b63a986622746066c&scene=4&uin=MjkzODM0MzEwMQ%3D%3D&key=7b81aac53bd2393d55de75a46b6ec27932fe634f88d1b794ce2bfe102c634e7d1e55939fc884a1031a0091a8f8a872bb" target="_blank" rel="noopener">文章</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;每个人都是孤独的，都生活在独立的世界中，孤独的出生，孤独的死亡。纵然哪些欢声笑语的人也有一个孤单的心灵，因为地球本就是孤独的，远处只有二向箔在默默地注视着你.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前一段时间正好赶上李松蔚老师讲心理学的Live
      
    
    </summary>
    
    
    
      <category term="读书笔记" scheme="https://wang-zc.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
