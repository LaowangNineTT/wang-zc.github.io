<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白大米的笔记</title>
  
  <subtitle>Be evil, Don&#39;t be evil.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wang-zc.github.io/"/>
  <updated>2019-03-24T09:46:26.111Z</updated>
  <id>https://wang-zc.github.io/</id>
  
  <author>
    <name>Tierney Wong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-771</title>
    <link href="https://wang-zc.github.io/2019/03/24/Leetcode-771/"/>
    <id>https://wang-zc.github.io/2019/03/24/Leetcode-771/</id>
    <published>2019-03-24T09:45:57.000Z</published>
    <updated>2019-03-24T09:46:26.111Z</updated>
    
    <content type="html"><![CDATA[<p>做了一道Leetcode的题目热热身</p><p>题目：</p><blockquote><p>给定字符串<code>J</code> 代表石头中宝石的类型，和字符串 <code>S</code>代表你拥有的石头。 <code>S</code> 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p><p><code>J</code> 中的字母不重复，<code>J</code> 和 <code>S</code>中的所有字符都是字母。字母区分大小写，因此<code>&quot;a&quot;</code>和<code>&quot;A&quot;</code>是不同类型的石头。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;</span><br><span class="line">&gt; 输出: 3</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入: J = &quot;z&quot;, S = &quot;ZZ&quot;</span><br><span class="line">&gt; 输出: 0</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>注意:</strong></p><p><code>S</code> 和 <code>J</code> 最多含有50个字母。</p><p> <code>J</code> 中的字符不重复。</p></blockquote><p>然后给出解答</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> String $J</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> String $S</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">numJewelsInStones</span><span class="params">($J, $S)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        $count = <span class="number">0</span>;</span><br><span class="line">        $stones = <span class="keyword">$this</span>-&gt;explodeList($S);</span><br><span class="line">        $jewel = <span class="keyword">$this</span>-&gt;explodeList($J);</span><br><span class="line">        <span class="keyword">foreach</span> ($stones <span class="keyword">as</span> $item) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in_array($item, $jewel, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                $count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> $count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">explodeList</span><span class="params">($string)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!is_string($string)) &#123;</span><br><span class="line">            <span class="keyword">return</span> [];</span><br><span class="line">        &#125;</span><br><span class="line">        $list = [];</span><br><span class="line">        $length = strlen($string);</span><br><span class="line">        <span class="keyword">if</span> ($length &gt; <span class="number">50</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $length; $i++) &#123;</span><br><span class="line">            $single = substr($string, $i, <span class="number">1</span>);</span><br><span class="line">            $list[] = $single;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> array_filter($list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;做了一道Leetcode的题目热热身&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定字符串&lt;code&gt;J&lt;/code&gt; 代表石头中宝石的类型，和字符串 &lt;code&gt;S&lt;/code&gt;代表你拥有的石头。 &lt;code&gt;S&lt;/code&gt; 中每个字符代表了一种你拥
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://wang-zc.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>太久没有学习了</title>
    <link href="https://wang-zc.github.io/2019/03/17/%E5%A4%AA%E4%B9%85%E6%B2%A1%E6%9C%89%E5%AD%A6%E4%B9%A0%E4%BA%86/"/>
    <id>https://wang-zc.github.io/2019/03/17/太久没有学习了/</id>
    <published>2019-03-17T10:21:15.000Z</published>
    <updated>2019-03-17T10:22:23.051Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>太久没有学习了</p></blockquote><p>今天打开Leetcode，发现自己刷题的手都生疏了</p><p>重新刷起来</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;太久没有学习了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天打开Leetcode，发现自己刷题的手都生疏了&lt;/p&gt;
&lt;p&gt;重新刷起来&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>How to Write Go Code</title>
    <link href="https://wang-zc.github.io/2018/09/09/How-to-Write-Go-Code/"/>
    <id>https://wang-zc.github.io/2018/09/09/How-to-Write-Go-Code/</id>
    <published>2018-09-09T15:18:43.000Z</published>
    <updated>2019-01-02T01:27:25.868Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在学习郝林老师的 Go 语言专栏，自己也在从 PHP 向 Golang 的转型中，学习了 GOPATH 的概念之后发现有些懵逼<br>关于 Go 的学习也是一个愉快的过程。<br><a id="more"></a></p></blockquote><p>去 go 的官网上找到了一篇<a href="https://golang.org/doc/code.html" target="_blank" rel="noopener">文章</a></p><p>尝试自己进行翻译，努力前行。</p><h2 id="How-to-Write-Go-Code"><a href="#How-to-Write-Go-Code" class="headerlink" title="How to Write Go Code"></a>How to Write Go Code</h2><p>如何编写 Go 代码</p><ul><li>Introduction</li><li>Code organization<ul><li>Overview<ul><li>Workspaces</li><li>The GOPATH environment variable</li><li>Import paths</li><li>Your first program</li><li>Your first library</li><li>Package names</li></ul></li></ul></li><li>Testing</li><li>Remote packages</li><li>What’s next</li><li>Getting help</li></ul><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>This document demonstrates the development of a simple Go package and introduces the <code>go tool</code>, the standard way to fetch, build, and install Go packages and commands.</p><p>这篇文档演示了一个简单的 Go 代码包的开发，并且介绍了一种获取，创建和安装 Go 代码包和命令行的安装方法，Go Tool。</p><p>The go tool requires you to organize your code in a specific way. Please read this document carefully. It explains the simplest way to get up and running with your Go installation.</p><p>Go Tool 需要你使用一种特定的方式去写代码，请仔细阅读本文档，你将看到如何使用一种最简单的方式去安装和运行你的 Go 程序。</p><p>A similar explanation is available as a <a href="https://www.youtube.com/watch?v=XCsL89YtqCs" target="_blank" rel="noopener">screencast</a>.</p><p>可以参考链接视频中的样例。</p><h3 id="Code-organization"><a href="#Code-organization" class="headerlink" title="Code organization"></a>Code organization</h3><h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><ul><li>Go programmers typically keep all their Go code in a single workspace.</li><li>Go 编程者通常会把他们所有的 Go 代码放在一个单独的工作区中。</li><li>A workspace contains many version control repositories (managed by Git, for example).</li><li>一个工作区可以包含多个版本控制仓库（像 Git 这种）</li><li>Each repository contains one or more packages.</li><li>每一个仓库都包含一个或者多个代码包。</li><li>Each package consists of one or more Go source files in a single directory.</li><li>每个代码包都有一个目录中的一个或多个 Go 的源代码文件构成。</li><li>The path to a package’s directory determines its import path.</li><li>包的路径决定了导入路径<br>Note that this differs from other programming environments in which every project has a separate workspace and workspaces are closely tied to version control repositories.</li></ul><p>值得注意的是，这和其他的编程语言有很大的不同，其他的变成语言都是每个项目都有一个单独的工作区，而且每个工作区都和版本控制仓库紧密相关。</p><h4 id="Workspaces"><a href="#Workspaces" class="headerlink" title="Workspaces"></a>Workspaces</h4><p>A workspace is a directory hierarchy with two directories at its root:<br>一个工作区包含两个子目录</p><ul><li>src contains Go source files, and </li><li>src 目录包括 Go 的源代码文件</li><li>bin contains executable commands.</li><li><code>bin</code> 目录包含可执行文件<br>The go tool builds and installs binaries to the bin directory.<br>Go Tool 构建二进制文件并且将其安装到 <code>bin</code> 目录下</li></ul><p>The src subdirectory typically contains multiple version control repositories (such as for Git or Mercurial) that track the development of one or more source packages.<br>src 子目录中通常包含多个版本控制仓库（例如 Git 和 Mercurial ），用于跟踪一个或者多个代码包的开发。</p><p>To give you an idea of how a workspace looks in practice, here’s an example:<br>为了让你对工作区有一个直观的感受，可以参考下面的例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bin/</span><br><span class="line">    hello                          <span class="comment"># command executable</span></span><br><span class="line">    outyet                         <span class="comment"># command executable</span></span><br><span class="line">src/</span><br><span class="line">    github.com/golang/example/</span><br><span class="line">        .git/                      <span class="comment"># Git repository metadata</span></span><br><span class="line">    hello/</span><br><span class="line">        hello.go               <span class="comment"># command source</span></span><br><span class="line">    outyet/</span><br><span class="line">        main.go                <span class="comment"># command source</span></span><br><span class="line">        main_test.go           <span class="comment"># test source</span></span><br><span class="line">    stringutil/</span><br><span class="line">        reverse.go             <span class="comment"># package source</span></span><br><span class="line">        reverse_test.go        <span class="comment"># test source</span></span><br><span class="line">    golang.org/x/image/</span><br><span class="line">        .git/                      <span class="comment"># Git repository metadata</span></span><br><span class="line">    bmp/</span><br><span class="line">        reader.go              <span class="comment"># package source</span></span><br><span class="line">        writer.go              <span class="comment"># package source</span></span><br><span class="line">    ... (many more repositories and packages omitted) ...</span><br></pre></td></tr></table></figure><p>The tree above shows a workspace containing two repositories (example and image). The example repository contains two commands (hello and outyet) and one library (stringutil). The image repository contains the bmp package and several others.<br>上面的树形目录展示了一个工作区中包含了两个 Git 仓库（example 和 image），示例中的仓库中包含了两个命令（hello 和 outyet）以及一个函数库（stringutil），image 的库还包括了 bmp 包和一些其他的代码包。</p><p>A typical workspace contains many source repositories containing many packages and commands. Most Go programmers keep all their Go source code and dependencies in a single workspace.<br>一个典型的工作区包括一些源代码库，这些代码库也包含了很多代码包和命令。大部分 Go 程序员习惯把 Go 的源代码和依赖文件放在一个工作区中。</p><p>Note that symbolic links should not be used to link files or directories into your workspace.<br>值得注意的是，不能将软链接链接文件或者目录到工作区中</p><p>Commands and libraries are built from different kinds of source packages. We will discuss the distinction later.<br>命令和库是从不同的源码包构建的，我们会在后续的内容中进行讨论。</p><h4 id="The-GOPATH-environment-variable"><a href="#The-GOPATH-environment-variable" class="headerlink" title="The GOPATH environment variable"></a>The GOPATH environment variable</h4><p>The GOPATH environment variable specifies the location of your workspace. It defaults to a directory named go inside your home directory, so $HOME/go on Unix, $home/go on Plan 9, and %USERPROFILE%go (usually C:UsersYourNamego) on Windows.<br>GOPATH  环境变量指定了你的工作区位置，默认是在你的 home 目录下，在 Linux 系统中是 $HOME/go或者 $home/go，而在 Windows 中是 %USERPROFILE%go (通常是 C:UsersYourNamego)</p><p>If you would like to work in a different location, you will need to set GOPATH to the path to that directory. (Another common setup is to set GOPATH=$HOME.) Note that GOPATH must not be the same path as your Go installation.<br>如果你想要设置一个不同的工作区，你需要在将 GOPATH 设置成该目录的路径，（通常会把他设置成GOPATH=$HOME ）请注意，GOPATH 不能与 Go 安装的路径相同。</p><p>The command go env GOPATH prints the effective current GOPATH; it prints the default location if the environment variable is unset.<br>运行命令 go env GOPATH 打印当前设置的 GOPATH ; 如果未设置环境变量，它将打印默认位置。</p><p>For convenience, add the workspace’s bin subdirectory to your PATH:<br>为了方便，通常会把工作区的 bin 目录添加到环境变量中设置为 GOBIN</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:$(go env GOPATH)/bin</span><br></pre></td></tr></table></figure><p>The scripts in the rest of this document use $GOPATH instead of $(go env GOPATH) for brevity. To make the scripts run as written if you have not set GOPATH, you can substitute $HOME/go in those commands or else run:<br>为简洁起见，本文档其余部分中的脚本使用 $GOPATH而不是 $(go env GOPATH)。如果你没有设置GOPATH，要使脚本以书面形式运行，你可以在这些命令中替换 $HOME/go ，否则运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> GOPATH=$(go env GOPATH)</span><br></pre></td></tr></table></figure><p>To learn more about the GOPATH environment variable, see ‘go help gopath’.<br>如果想要学习更多的关于 GOPATH 环境变量的内容，可以查看 <code>go help gopath</code>。</p><p>To use a custom workspace location, set the GOPATH environment variable.<br>如果想要设置一个自定义的工作区目录，可以单独设置 GOPATH 的环境变量。</p><h4 id="Import-paths"><a href="#Import-paths" class="headerlink" title="Import paths"></a>Import paths</h4><p>An import path is a string that uniquely identifies a package. A package’s import path corresponds to its location inside a workspace or in a remote repository (explained below).<br>导入路径是唯一标识包的字符串。包的导入路径对应于其在工作空间内或远程仓库中的位置（如下所述）。</p><p>The packages from the standard library are given short import paths such as “fmt” and “net/http”. For your own packages, you must choose a base path that is unlikely to collide with future additions to the standard library or other external libraries.<br>标准库中导入的包具有很简短的路径，像 ”fmt” 或者 ”net/http” 包一样，但是对于开发者自己的代码包，开发者必须选择一个不会于标准库或者其他的依赖库相冲突的基础路径。</p><p>If you keep your code in a source repository somewhere, then you should use the root of that source repository as your base path. For instance, if you have a GitHub account at github.com/user, that should be your base path.<br>如果将代码保存在某个源存储库中，则应使用该源存储库的根作为基本路径。例如，如果你在 github.com/user 下面有个 GitHub 的账户，那么 github.com/user 就是你的根目录。</p><p>Note that you don’t need to publish your code to a remote repository before you can build it. It’s just a good habit to organize your code as if you will publish it someday. In practice you can choose any arbitrary path name, as long as it is unique to the standard library and greater Go ecosystem.<br>请注意，你在构建完成之前不需要将代码推送到远程仓库中去，当你推送的时候你就会知道这绝对是一个好习惯，只要对于 Go 的标准库和 Go 包含的各种第三方库来说你的代码路径是唯一的，你可以随便起名。</p><p>We’ll use github.com/user as our base path. Create a directory inside your workspace in which to keep source code:<br>我们将会把 github.com/user 当做基础路径，创建一个目录，保存我们的源代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p <span class="variable">$GOPATH</span>/src/github.com/user</span><br></pre></td></tr></table></figure><h4 id="Your-first-program"><a href="#Your-first-program" class="headerlink" title="Your first program"></a>Your first program</h4><p>To compile and run a simple program, first choose a package path (we’ll use github.com/user/hello) and create a corresponding package directory inside your workspace:<br>为了创建一个简单的程序，第一步应该选择一个代码包路径（github.com/user/hello）并且在工作区内创建相对应的包目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir <span class="variable">$GOPATH</span>/src/github.com/user/hello</span><br></pre></td></tr></table></figure><p>Next, create a file named hello.go inside that directory, containing the following Go code.<br>下一步，在里面创建一个 hello.go 的文件，包含一下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello, world."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now you can build and install that program with the go tool:<br>现在你可以通过 Go Tool 来构建和安装它了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go install github.com/user/hello</span><br></pre></td></tr></table></figure><p>Note that you can run this command from anywhere on your system. The go tool finds the source code by looking for the github.com/user/hello package inside the workspace specified by GOPATH.<br>注意，你可以在你系统的任意地方使用这个命令，Go Tool 将会通过 GOPATH 找到位于 github.com/user/hello 目录下的源代码文件。</p><p>You can also omit the package path if you run go install from the package directory:<br>如果从包目录运行go install，你也可以省略包路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/user/hello</span><br><span class="line">$ go install</span><br></pre></td></tr></table></figure><p>This command builds the hello command, producing an executable binary. It then installs that binary to the workspace’s bin directory as hello (or, under Windows, hello.exe). In our example, that will be $GOPATH/bin/hello, which is $HOME/go/bin/hello.<br>上面这行命令创建了 hello 命令，产生了一个二进制文件。把这个二进制文件放在了工作区中的 bin 目录下（在 Windows 系统下，就像是 hello.exe 这种文件一样），在我们的例子中，$GOPATH/bin/hello 就是 $HOME/go/bin/hello</p><p>The go tool will only print output when an error occurs, so if these commands produce no output they have executed successfully.<br>Go Tool 只有在错误产生的时候才会输出内容，所以如果运行命令的时候没有任何输出，这就意味着着命令是执行成功的。</p><p>You can now run the program by typing its full path at the command line:<br>你可以通过以下的命令来执行文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="variable">$GOPATH</span>/bin/hello</span><br><span class="line">Hello, world.</span><br></pre></td></tr></table></figure><p>Or, as you have added $GOPATH/bin to your PATH, just type the binary name:<br>或者在你把 $GOPATH/bin 添加到环境变量中之后，你就可以执行以名称来执行命令了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hello</span><br><span class="line">Hello, world.</span><br></pre></td></tr></table></figure><p>If you’re using a source control system, now would be a good time to initialize a repository, add the files, and commit your first change. Again, this step is optional: you do not need to use source control to write Go code.<br>如果您正在使用源代码管理系统，那么现在是初始化存储库，添加文件和提交第一个更改的好时机。当然你可以选择做或者不做：您不需要使用源代码控制来编写 Go 代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/user/hello</span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /home/user/work/src/github.com/user/hello/.git/</span><br><span class="line">$ git add hello.go</span><br><span class="line">$ git commit -m <span class="string">"initial commit"</span></span><br><span class="line">[master (root-commit) 0b4507d] initial commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 hello.go</span><br></pre></td></tr></table></figure><p>Pushing the code to a remote repository is left as an exercise for the reader.<br>把代码推送到仓库中就当做一次课下练习吧，试一试。</p><h4 id="Your-first-library"><a href="#Your-first-library" class="headerlink" title="Your first library"></a>Your first library</h4><p>Let’s write a library and use it from the hello program.<br>让我们为 hello 这个程序写一个依赖库。</p><p>Again, the first step is to choose a package path (we’ll use github.com/user/stringutil) and create the package directory:<br>同样的，第一步是选择代码包的路径（github.com/user/stringutil），创建目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir <span class="variable">$GOPATH</span>/src/github.com/user/stringutil</span><br></pre></td></tr></table></figure><p>Next, create a file named reverse.go in that directory with the following contents.<br>下一步，在目录下创建一个叫做 reverse.go 的文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package stringutil contains utility functions for working with strings.</span></span><br><span class="line"><span class="keyword">package</span> stringutil</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reverse returns its argument string reversed rune-wise left to right.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    r := []<span class="keyword">rune</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(r)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(r)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        r[i], r[j] = r[j], r[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now, test that the package compiles with go build:<br>现在，我们来测试一下我们的代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build github.com/user/stringutil</span><br></pre></td></tr></table></figure><p>Or, if you are working in the package’s source directory, just:<br>如果在代码包的目录中，可以直接运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build</span><br></pre></td></tr></table></figure><p>This won’t produce an output file. Instead it saves the compiled package in the local build cache.<br>这行命令不会产生任何输出文件，它会将编译好的包文件放在本地缓存目录中。</p><p>After confirming that the stringutil package builds, modify your original hello.go (which is in $GOPATH/src/github.com/user/hello) to use it:<br>在确认了 stringutil 构建完成之后，你可以修改 hello.go 文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/user/stringutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(stringutil.Reverse(<span class="string">"!oG ,olleH"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Install the hello program:<br>重新安装 hello</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go install github.com/user/hello</span><br></pre></td></tr></table></figure><p>Running the new version of the program, you should see a new, reversed message:<br>重新运行程序，你可以看到以下输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hello</span><br><span class="line">Hello, Go!</span><br></pre></td></tr></table></figure></p><p>After the steps above, your workspace should look like this:<br>这一步完成后，你的工作区空间看起来应该是这样的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bin/</span><br><span class="line">    hello                 <span class="comment"># command executable</span></span><br><span class="line">src/</span><br><span class="line">    github.com/user/</span><br><span class="line">        hello/</span><br><span class="line">            hello.go      <span class="comment"># command source</span></span><br><span class="line">        stringutil/</span><br><span class="line">            reverse.go    <span class="comment"># package source</span></span><br></pre></td></tr></table></figure></p><h4 id="Package-names"><a href="#Package-names" class="headerlink" title="Package names"></a>Package names</h4><p>The first statement in a Go source file must be<br>Go 源代码中的第一行语句必须是<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> name</span><br></pre></td></tr></table></figure></p><p>where name is the package’s default name for imports. (All files in a package must use the same name.)<br>其中name是包的默认名称。 （包中的所有文件必须使用相同的名称。）</p><p>Go’s convention is that the package name is the last element of the import path: the package imported as “crypto/rot13” should be named rot13.<br>Go的约定是包名称是导入路径的最后一个元素：导入为“crypto / rot13”的包应命名为rot13。</p><p>Executable commands must always use package main.<br>可执行命令必须始终使用 package main。</p><p>There is no requirement that package names be unique across all packages linked into a single binary, only that the import paths (their full file names) be unique.<br>只要导入路径（它们的完整文件名）是唯一的， 不要求包名称在链接到单个二进制文件的所有包中都是唯一的。</p><p>See Effective Go to learn more about Go’s naming conventions.<br>请参阅Effective Go以了解有关Go的命名约定的更多信息。</p><h3 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h3><p>Go has a lightweight test framework composed of the go test command and the testing package.<br>Go有一个由 go test 命令和测试包组成的轻量级测试框架。</p><p>You write a test by creating a file with a name ending in <code>_test.go</code> that contains functions named TestXXX with signature <code>func (t *testing.T)</code>. The test framework runs each such function; if the function calls a failure function such as t.Error or t.Fail, the test is considered to have failed.<br>您通过创建名称以_test.go结尾的文件来编写测试，该文件包含名为TestXXX且带有签名func（t * testing.T）的函数。测试框架运行每个这样的功能;如果函数调用失败函数（如t.Error或t.Fail），则认为测试失败。</p><p>Add a test to the stringutil package by creating the file $GOPATH/src/github.com/user/stringutil/reverse_test.go containing the following Go code.<br>通过创建包含以下Go代码的文件 <code>$GOPATH/src/github.com/user/stringutil/reverse_test.go</code>，将测试添加到stringutil 包中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stringutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReverse</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    cases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        in, want <span class="keyword">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="string">"Hello, world"</span>, <span class="string">"dlrow ,olleH"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Hello, 世界"</span>, <span class="string">"界世 ,olleH"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">""</span>, <span class="string">""</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> cases &#123;</span><br><span class="line">        got := Reverse(c.in)</span><br><span class="line">        <span class="keyword">if</span> got != c.want &#123;</span><br><span class="line">            t.Errorf(<span class="string">"Reverse(%q) == %q, want %q"</span>, c.in, got, c.want)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then run the test with go test:<br>然后用go测试运行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> github.com/user/stringutil</span><br><span class="line">ok      github.com/user/stringutil 0.165s</span><br></pre></td></tr></table></figure><p>As always, if you are running the go tool from the package directory, you can omit the package path:<br>如果从包目录运行go工具，则可以省略包路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">ok      github.com/user/stringutil 0.165s</span><br></pre></td></tr></table></figure><p>Run go help test and see the testing package documentation for more detail.<br>运行 <code>go help test</code> 并查看测试包文档以获取更多详细信息。</p><h3 id="Remote-packages"><a href="#Remote-packages" class="headerlink" title="Remote packages"></a>Remote packages</h3><p>An import path can describe how to obtain the package source code using a revision control system such as Git or Mercurial. The go tool uses this property to automatically fetch packages from remote repositories. For instance, the examples described in this document are also kept in a Git repository hosted at GitHub github.com/golang/example. If you include the repository URL in the package’s import path, go get will fetch, build, and install it automatically:<br>导入路径可以描述如何使用诸如 Git 或 Mercurial 之类的代码管理系统来获取源代码包。  Go Tool 使用此属性自动从远程存储库获取包。例如，本文档中描述的示例也保存在 GitHub github.com/golang/example 上托管的 Git 仓库中。如果您在包的导入路径中包含存储库 URL ，那么go将自动获取，构建和安装它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/golang/example/hello</span><br><span class="line">$ <span class="variable">$GOPATH</span>/bin/hello</span><br><span class="line">Hello, Go examples!</span><br></pre></td></tr></table></figure><p>If the specified package is not present in a workspace, go get will place it inside the first workspace specified by GOPATH. (If the package does already exist, go get skips the remote fetch and behaves the same as go install.)<br>如果工作空间中不存在指定的包，则 get 将其放在 GOPATH 指定的第一个工作空间内。 （如果包已经存在，请跳过远程提取，其行为与 go install 相同。）</p><p>After issuing the above go get command, the workspace directory tree should now look like this:<br>发出上面的go get命令后，工作区目录树现在应如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bin/</span><br><span class="line">    hello                           <span class="comment"># command executable</span></span><br><span class="line">src/</span><br><span class="line">    github.com/golang/example/</span><br><span class="line">    .git/                       <span class="comment"># Git repository metadata</span></span><br><span class="line">        hello/</span><br><span class="line">            hello.go                <span class="comment"># command source</span></span><br><span class="line">        stringutil/</span><br><span class="line">            reverse.go              <span class="comment"># package source</span></span><br><span class="line">            reverse_test.go         <span class="comment"># test source</span></span><br><span class="line">    github.com/user/</span><br><span class="line">        hello/</span><br><span class="line">            hello.go                <span class="comment"># command source</span></span><br><span class="line">        stringutil/</span><br><span class="line">            reverse.go              <span class="comment"># package source</span></span><br><span class="line">            reverse_test.go         <span class="comment"># test source</span></span><br></pre></td></tr></table></figure><p>The hello command hosted at GitHub depends on the stringutil package within the same repository. The imports in hello.go file use the same import path convention, so the go get command is able to locate and install the dependent package, too.<br>在GitHub上托管的hello命令取决于同一存储库中的stringutil包。 hello.go文件中的导入使用相同的导入路径约定，因此 go get 命令也能够找到并安装依赖包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import <span class="string">"github.com/golang/example/stringutil"</span></span><br></pre></td></tr></table></figure><p>This convention is the easiest way to make your Go packages available for others to use. The Go Wiki and godoc.org provide lists of external Go projects.<br>此约定是使您的Go包可供其他人使用的最简单方法。 Go Wiki和godoc.org提供了外部Go项目的列表。</p><p>For more information on using remote repositories with the go tool, see go help importpath.<br>有关使用go工具使用远程存储库的更多信息，请参阅go help importpath。</p><h3 id="What’s-next"><a href="#What’s-next" class="headerlink" title="What’s next"></a>What’s next</h3><p>Subscribe to the golang-announce mailing list to be notified when a new stable version of Go is released.<br>See Effective Go for tips on writing clear, idiomatic Go code.<br>Take A Tour of Go to learn the language proper.<br>Visit the documentation page for a set of in-depth articles about the Go language and its libraries and tools.<br>订阅golang-announce邮件列表，以便在发布新的稳定版Go时收到通知。<br>有关编写清晰，惯用的Go代码的提示，请参阅Effective Go。<br>学习 A Tour of Go ，学习语法。<br>访问文档页面，获取有关Go语言及其库和工具的深入文章。</p><h3 id="Getting-help"><a href="#Getting-help" class="headerlink" title="Getting help"></a>Getting help</h3><p>For real-time help, ask the helpful gophers in #go-nuts on the Freenode IRC server.<br>The official mailing list for discussion of the Go language is Go Nuts.<br>Report bugs using the Go issue tracker.<br>要获得实时帮助，请在Freenode IRC上使用 #go-nuts 标签询问开发者。<br>讨论Go语言的官方邮件列表是Go Nuts。<br>使用Go问题跟踪器报告错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在学习郝林老师的 Go 语言专栏，自己也在从 PHP 向 Golang 的转型中，学习了 GOPATH 的概念之后发现有些懵逼&lt;br&gt;关于 Go 的学习也是一个愉快的过程。&lt;br&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://wang-zc.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Code Rules</title>
    <link href="https://wang-zc.github.io/2018/08/25/Code-Rules/"/>
    <id>https://wang-zc.github.io/2018/08/25/Code-Rules/</id>
    <published>2018-08-25T07:23:44.000Z</published>
    <updated>2019-01-02T01:29:46.415Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>因为之前都没有很严格的代码规范，所以这周开始制定代码规范，大致从五部分来做。<br>【强制】严格遵守 PSR 规范，详尽的 PSR 规范可以点击链接访问<a href="#">URL 链接</a>(<a href="https://psr.phphub.org/" target="_blank" rel="noopener">https://psr.phphub.org/</a>)</p></blockquote><a id="more"></a><h3 id="0x00-团队代码规范"><a href="#0x00-团队代码规范" class="headerlink" title="0x00  团队代码规范"></a>0x00  团队代码规范</h3><ul><li>命名规范 ✅</li><li>代码片段 ✅</li><li>数据库设计✅</li><li>开发守则  ✅</li></ul><h4 id="关于-Code-的规范"><a href="#关于-Code-的规范" class="headerlink" title="关于 Code 的规范"></a>关于 Code 的规范</h4><blockquote><p>PHP 系列可以参考 PSR 规范，<a href="https://psr.phphub.org/" title="PSR 标准规范" target="_blank" rel="noopener">PSR</a>(<a href="https://psr.phphub.org/" target="_blank" rel="noopener">https://psr.phphub.org/</a>)<br>JavaScript 可以参考 <a href="https://github.com/fex-team/styleguide/blob/master/javascript.md" target="_blank" rel="noopener">JS URL</a>(<a href="https://github.com/fex-team/styleguide/blob/master/javascript.md" target="_blank" rel="noopener">https://github.com/fex-team/styleguide/blob/master/javascript.md</a>)<br>关于 MySQL 的规范可以参考《阿里巴巴 Java 开发手册中》的数据库部分</p></blockquote><ul><li>PHP代码文件 必须 以 <code>&lt;?php</code> 或 <code>&lt;?=</code> 标签开始；</li><li>PHP代码文件 必须 以 <code>不带 BOM 的 UTF-8 编码</code>；</li><li>PHP代码中 应该 只定义类、函数、常量等声明，或其他会产生 副作用 的操作（如：生成文件输出以及修改 <code>.ini</code> 配置文件等），二者只能选其一；</li></ul><h3 id="0x01、命名规范"><a href="#0x01、命名规范" class="headerlink" title="0x01、命名规范"></a>0x01、命名规范</h3><ol><li><p>【强制】代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。<br> 说明： 正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式，但是一些在英文中无法对应的词语可以使用拼音，如搬砖等。但是拼音方案也要尽量避免采用，变量必须有所含义，不允许出现<code>$data</code>,<code>$a</code> 等无意义的变量名。</p></li><li><p>【强制】类名使用 <code>UpperCamelCase</code> 风格，但以下情形例外：<code>DO / BO / DTO / VO / AO /PO / UID</code> 等。<br> 说明：关于 <code>ThinkPHP</code> 框架下开发的时候要遵循框架开发的规则，对于 <code>Controller</code> 的文件命名不做强制要求。<br> 正例： <code>MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion</code></p></li><li><p>【强制】类内方法名、类内参数名、成员变量、局部变量都统一使用<code>lowerCamelCase</code>风格，必须遵从驼峰形式。<br> 正例：<code>localValue / getHttpMessage() / inputUserId</code></p></li><li><p>【强制】抽象类命名使用 <code>Abstract</code> 开头； 异常类命名使用 <code>Exception</code> 结尾； 测试类命名以它要测试的类的名称开始，以 <code>Test</code> 结尾。</p></li><li><p>【强制】常量命名、配置参数和语言变量全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。<br> 例如 <code>HAS_ONE</code>和 <code>MANY_TO_MANY</code>；语言变量例如<code>MY_LANG</code>，以下划线打头的语言变量通常用于系统语言变量，例如 <code>_CLASS_NOT_EXIST_</code>；</p></li><li><p>【强制】杜绝完全不规范的缩写， 避免望文不知义。<br> 反例： <code>AbstractClass</code>“缩写” 命名成 <code>AbsClass</code>； <code>condition</code>“缩写” 命名成 <code>condi</code>，此类随意缩写严重降低了代码的可阅读性。</p></li><li><p>【推荐】如果模块、 接口、类、方法使用了设计模式，在命名时需体现出具体模式。<br> 说明： 将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。<br> 正例： <code>public class OrderFactory</code>;<code>public class LoginProxy</code>;<br> <code>public class ResourceObserver</code>;</p></li><li><p>【参考】各层命名规约，遵守<code>Service/DAO</code> 层方法命名规约<br> 1） 获取单个对象的方法用 <code>get</code> 做前缀。<br> 2） 获取多个对象的方法用 <code>list</code> 做前缀，复数形式结尾如： <code>listObjects</code>。<br> 3） 获取统计值的方法用 <code>count</code> 做前缀。<br> 4） 插入的方法用 <code>save/insert</code> 做前缀。<br> 5） 删除的方法用 <code>remove/delete</code> 做前缀。<br> 6） 修改的方法用 <code>update</code> 做前缀。</p></li><li><p>关于 <code>ThinkPHP</code> 的一些需要遵守的地方也需要注意</p><ul><li>类文件都是以<code>.class.php</code>为后缀（这里是指的<code>ThinkPHP</code>内部使用的类库文件，不代表外部加载的类库文件），使用驼峰法命名，并且首字母大写，例如 <code>DbMysql.class.php</code>；</li><li>类的命名空间地址和所在的路径地址一致，例如 <code>Home\Controller\UserController</code>类所在的路径应该是 <code>Application/Home/Controller/UserController.class.php</code>；</li><li>确保文件的命名和调用大小写一致，是由于在类<code>Unix</code>系统上面，对大小写是敏感的（而<code>ThinkPHP</code>在调试模式下面，即使在<code>Windows</code>平台也会严格检查大小写）；</li><li>类名和文件名一致（包括上面说的大小写一致），例如 <code>UserController</code>类的文件命名是<code>UserController.class.php</code>，<code>InfoModel</code>类的文件名是<code>InfoModel.class.php</code>， 并且不同的类库的类命名有一定的规范；</li><li>函数、配置文件等其他类库文件之外的一般是以.php为后缀（第三方引入的不做要求）；</li><li>函数的命名使用小写字母和下划线的方式，例如 <code>get_client_ip</code> ；</li><li>类内方法的命名使用驼峰法，并且首字母小写或者使用下划线 <code>_</code>，例如 <code>getUserName</code>，<code>_parseType</code>，下划线开头的方法属于私有方法；</li><li>类内属性的命名使用驼峰法，并且首字母小写或者使用下划线 <code>_</code>，例如 <code>tableName</code>、<code>_instance</code>，下划线开头的属性属于私有属性；</li><li>以双下划线<code>__</code>打头的函数或方法作为魔法方法，例如 <code>__call</code> 和 <code>__autoload</code>；</li><li>常量必须大写字母和下划线命名，例如 <code>HAS_ONE</code> 和 <code>MANY_TO_MANY</code>；</li><li>配置参数以大写字母和下划线命名，例如 <code>HTML_CACHE_ON</code>；</li><li>语言变量以大写字母和下划线命名，例如 <code>MY_LANG</code>，以下划线打头的语言变量通常用于系统语言变量，例如 <code>_CLASS_NOT_EXIST_</code>；</li><li>ThinkPHP的模板文件默认是以 <code>.html</code> 为后缀（可以通过配置修改）；</li><li>数据表和字段采用小写加下划线方式命名，并注意字段名不要以下划线开头，例如 <code>think_user</code> 表和 <code>user_name</code> 字段是正确写法，类似 <code>_username</code> 这样的数据表字段可能会被过滤。</li></ul></li></ol><h3 id="0x02-代码片段"><a href="#0x02-代码片段" class="headerlink" title="0x02 代码片段"></a>0x02 代码片段</h3><ol><li><p>【强制】代码使用4个空格符而不是「Tab 键」进行缩进（这里可以在<code>PhpStorm</code>的配置中设置）。</p></li><li><p>【强制】每个 <code>namespace</code> 命名空间声明语句和 <code>use</code> 声明语句块后面，必须插入一个空白行。</p></li><li><p>【强制】类的开始花括号 <code>{</code> 必须写在函数声明后自成一行，结束花括号 <code>}</code> 也必须写在函数主体后自成一行。</p></li><li><p>【强制】方法的开始花括号 <code>{</code> 必须写在函数声明后自成一行，结束花括号 <code>}</code> 也必须写在函数主体后自成一行。</p></li><li><p>【强制】类的属性和方法必须添加访问修饰符 <code>private</code>、<code>protected</code> 以及 <code>public</code>，<code>abstract</code> 以及 <code>final</code>必须声明在访问修饰符之前，而 <code>static</code> 必须声明在访问修饰符之后。</p></li><li><p>【强制】控制结构的关键字后必须要有一个空格符，而调用方法或函数时则一定不可有。</p></li><li><p>【强制】控制结构的开始花括号 <code>{</code> 必须写在声明的同一行，而结束花括号 <code>}</code> 必须写在主体后自成一行。</p></li><li><p>【强制】控制结构的开始左括号后和结束右括号前，都 <em><strong>一定不可</strong></em> 有空格符。</p></li><li><p>【推荐】单行注释无比使用 <code>//</code>来进行标注，和下一行代码对齐</p></li><li><p>【推荐】多行注释，可以使用 <code>/**/</code> 来做注释开头和结尾</p></li><li><p>【推荐】简单的接口不需要些注释，不要写过多的注释，复杂的逻辑注释注意准确性和时效性，如果注释已经失效，记得更新日志。否则删掉。</p></li><li><p>前端的 <code>JS</code> 文件和 <code>HTML</code> 文件上线时需要删除注释内容。前端不适宜写过多的注释内容，以备留下安全隐患。</p></li><li><p>【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。<br>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> two = <span class="number">2L</span>;</span><br><span class="line"><span class="keyword">float</span> three = <span class="number">3F</span>;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br></pre></td></tr></table></figure><p>说明： 增加 sb 这个变量，如果需要对齐，则给 a、 b、 c 都要增加几个空格，在变量比较多的情况下，是非常累赘的事情</p></li></ol><h5 id="正确示例如下"><a href="#正确示例如下" class="headerlink" title="正确示例如下"></a>正确示例如下</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Vendor</span>\<span class="title">Package</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">FooInterface</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">BarClass</span> <span class="title">as</span> <span class="title">Bar</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">OtherVendor</span>\<span class="title">OtherPackage</span>\<span class="title">BazClass</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">Bar</span> <span class="keyword">implements</span> <span class="title">FooInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sampleFunction</span><span class="params">($a, $b = null)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($a === $b) &#123;</span><br><span class="line">            bar();</span><br><span class="line">        &#125; <span class="keyword">elseif</span> ($a &gt; $b) &#123;</span><br><span class="line">            $foo-&gt;bar($arg1);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BazClass::bar($arg2, $arg3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 方法的内容</span></span><br><span class="line">        $argc = <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x02-开发守则"><a href="#0x02-开发守则" class="headerlink" title="0x02 开发守则"></a>0x02 开发守则</h3><ol><li><p>开发过程中保持和产品、测试的实时沟通，切勿<code>独立</code>开发，有了新的 <code>idea</code>，要记得及时和产品沟通。每一个确定的需求都要保证开发，测试和产品是清楚无误的。</p></li><li><p>在开始新的迭代的时候，再三沟通，再三沟通，再三沟通好要迭代的内容。</p></li><li><p>下笔之前，多思考。<code>THINK MORE, CODE LESS</code></p></li><li><p>每个函数不超过 <code>50</code> 行，非强制性，但绝对不可以超过 <code>150</code> 行，开发过程中应当避免每个方法过长，适时解构，不要让代码耦合性过强。</p></li><li><p>无论是<code>laravel</code> 或者<code>ThinkPHP</code>哪一个框架，<code>Controller</code>中的<code>func</code> 不要太复杂。复杂逻辑写在相对应的<code>Service</code>或者<code>Logic</code>中。</p></li><li><p><code>Controller</code>中不允许直接调用<code>Model</code></p></li><li><p>在每次的上线时维护好上线文档。一次小上线也要记录好本次上线的内容。</p></li><li><p>不要盲目的拷贝，粘贴。要知道拷贝粘贴节约的时间没有多少。把方法解耦，提取公共方法。这样才是长久之计。</p></li><li><p>对自己的代码要负责，要有强烈的羞耻心。</p></li><li><p>多记录日志，对每一个步骤流程都做日志流程记录，尤其是订单流程。这样出现问题排查起来很方便。</p></li><li><p>不断思考，不断前进。</p></li><li><p>请尽量使用 <code>teambition</code> 合作, 约束自己</p></li><li><p>多自我学习, 没工作内容的时候才是成长的好机会</p></li><li><p>多交流</p></li><li><p><code>SVN commit</code> 有目的的时候, 尽量填写 <code>msg</code>, 不要改改就提交</p></li><li><p>复制的代码一定要改注释, 保持注释的正确性</p></li><li><p>写死数据进行测试是可以的, 但是测试完了要去掉(如果没用)</p></li><li><p>阅读下其他盆友的代码, 熟悉流程, 不能只知道自己的小块, 至少要知道个大概流程吧.</p></li><li><p>注意<code>api</code>的兼容性，<code>response</code>结构不要删减；注意数据类型的一致性</p></li><li><p>接口完成后如果可以请录入<code>postman</code>，并告知客户端盆友改动项</p></li><li><p>注意如果<code>apivN</code>改了, 也要考虑下<code>apiM</code>的情况, 比如说<code>api1</code>不再支持微信资料的覆盖, 这种改变, <code>api</code>也是肯定不能支持的, 都要改掉!; 而如果是<code>api1</code>加了某个字段, <code>api</code>不需要用到, 那可以不加.</p></li><li><p>个人感觉不要用一样的命名, 我刚才搜索一个方法, <code>controller</code>, <code>logic</code>, <code>model</code>里全叫一个名字; 实例化后的变量名也不容易作为搜索条件区分, 一搜就悲剧了. 大家注意<code>controller</code>里是给用户访问的入口, <code>logic</code>里是集合的操作, <code>model</code>里是对数据库的操作, 以此来定名字.</p></li></ol><h3 id="0x31-数据库设计"><a href="#0x31-数据库设计" class="headerlink" title="0x31 数据库设计"></a>0x31 数据库设计</h3><h5 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h5><ol><li><p>【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，所以字段名称需要慎重考虑。说明：<code>MySQL</code>在<code>Windows</code>下不区分大小写，但在<code>Linux</code>下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。正例：<code>aliyun_admin</code>，<code>rdc_config</code>，<code>level3_name</code> 反例：<code>AliyunAdmin</code>，<code>rdcConfig</code>，<code>level_3_name</code> </p></li><li><p>【强制】表名字段名不使用英文与拼音的复合表达式，符合表达习惯。禁用保留字，如<code>desc</code>、<code>date</code>、<code>range、match、delayed</code>等，请参考MySQL官方保留字。</p></li><li><p>【强制】主键索引名为<code>pk_</code>字段名；唯一索引名为<code>uk_</code>字段名；普通索引名则为<code>idx_</code>字段名。 说明：<code>pk_</code> 即<code>primary key</code>；<code>uk_</code> 即 <code>unique key</code>；<code>idx_</code> 即<code>index</code>的简称。 </p></li></ol><h5 id="表-字段规则"><a href="#表-字段规则" class="headerlink" title="表/字段规则"></a>表/字段规则</h5><ol><li><p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。 说明：以学生和成绩的关系为例，学生表中的<code>student_id</code>是主键，那么成绩表中的<code>student_id</code>则为外键。如果更新学生表中的<code>student_id</code>，同时触发成绩表中的<code>student_id</code>更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。 </p></li><li><p>【强制】所有的字符存储与表示，均以<code>utf-8</code>编码，注意字符统计函数的区别。 </p></li><li><p>【强制】如果存储的字符串长度几乎相等，使用<code>char</code>定长字符串类型。 </p></li><li><p>【强制】<code>varchar</code>是可变长字符串，不预先分配存储空间，长度不要超过 2000，如果存储长度大于此值，定义字段类型为<code>text</code>，独立出来一张表，用主键来对应，避免影响其它字段索引效率。 </p></li><li><p>【推荐】表必备三字段：<code>id, createon, updateon</code>。 说明：其中id必为主键，类型为<code>bigint unsigned</code>、单表时自增、步长为1。<code>createon, updateon</code>的类型均为<code>datetime</code>类型。</p></li><li><p>【推荐】所有字段都应该有默认值，不应该存在值为<code>NULL</code>的列，<code>NULL</code>值在统计中会造成很多麻烦。 </p></li><li><p>【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：<br>  1）不是频繁修改的字段。<br>  2）不是<code>varchar</code>超长字段，更不能是<code>text</code>字段。 正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。 </p></li><li><p>【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。 </p></li></ol><h5 id="索引规则"><a href="#索引规则" class="headerlink" title="索引规则"></a>索引规则</h5><ol><li><p>【强制】勿认为一个查询就需要建一个索引，也不要胡乱认为索引会消耗空间、严重拖慢更新和新增速度，而是应该业务需求考虑索引的必要程度。</p></li><li><p>【强制】对于有限的几个值的列不需要建索引。 </p></li><li><p>【强制】经常出现在<code>where</code>条件和<code>order by</code>子句中的列一定要建立索引。</p></li><li><p>【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。<br> 说明：不要以为唯一索引影响了<code>insert</code>速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。 </p></li><li><p>【强制】在<code>varchar</code>字段上建立索引时，必须指定索引长度，一般来说 8 位即可，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。 </p></li><li><p>【推荐】 <code>SQL</code>性能优化的目标：至少要达到 <code>range</code> 级别，要求是<code>ref</code>级别，如果可以是<code>consts</code>最好。<br> 说明：<br>  1）<code>consts</code> 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。<br>  2）<code>ref</code> 指的是使用普通的索引（<code>normal index</code>）。<br>  3）<code>range</code> 对索引进行范围检索。 反例：<code>explain</code>表的结果，<code>type=index</code>，索引物理文件全扫描，速度非常慢，这个<code>index</code>级别比较<code>range</code>还低，与全表扫描是小巫见大巫。 </p></li></ol><h5 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h5><ol><li><p>【强制】不要使用<code>count(列名)</code>或<code>count(常量)</code>来替代<code>count(*)</code>，<code>count(*)</code>是<code>SQL92</code>定义的标准统计行数的语法，跟数据库无关，跟<code>NULL</code>和非<code>NULL</code>无关。 说明：<code>count(*)</code>会统计值为<code>NULL</code>的行，而<code>count(列名)</code>不会统计此列为<code>NULL</code>值的行。 </p></li><li><p>【强制】<code>order by</code>排序的时候如果是根据创建时间来排序，不要使用<code>createon</code>列，直接用<code>order by id</code> 或者<code>order by id desc</code>。说明：通过主键来排序大幅提高性能。</p></li><li><p>【强制】 在代码中写分页查询逻辑时，若<code>count</code>为0应直接返回，避免执行后面的分页语句。 </p></li><li><p>【强制】<code>where</code>条件中如果字段是字符类型，代码中的条件值必须加上引号，避免索引失效。 </p></li><li><p>【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。 说明：1）增加查询分析器解析成本；2）无用字段增加网络消耗，尤其是text类型的字段。 </p></li><li><p>【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。 </p></li><li><p>【强制】 除临时表外程序中禁止使用<code>TRUNCATE TABLE</code> 。说明：<code>TRUNCATE TABLE</code> 在功能上与不带 <code>WHERE</code> 子句的 <code>DELETE</code> 语句相同，极有可能造成事故。 </p></li><li><p>【推荐】<code>in</code>操作能避免则避免，若实在避免不了，需要仔细评估<code>in</code>后边的集合元素数量，控制在1000个之内。 </p></li><li><p>【推荐】不要写一个大而全的数据更新接口。不管是不是自己的目标更新字段，都进行<code>update table set c1=value1,c2=value2,c3=value3;</code>这是不对的。执行<code>SQL</code>时，不要更新无改动的字段，一是易出错；二是效率低；三是增加<code>binlog</code>存储。 </p></li><li><p>【推荐】利用延迟关联或者子查询优化超多分页场景。 说明：<code>MySQL</code>并不是跳过<code>offset</code>行，而是取<code>offset+N</code>行，然后返回放弃前<code>offset</code>行，返回<code>N</code>行，那当<code>offset</code>特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行<code>SQL</code>改写。 正例：先快速定位需要获取的<code>id</code>段，然后再关联： <code>SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</code></p></li><li><p>【推荐】建组合索引的时候，区分度最高的在最左边。 正例：如果<code>where a=? and b=?</code>，如果<code>a</code>列的几乎接近于唯一值，那么只需要单建<code>idx_a</code>索引即可。 说明：存在非等号和等号混合时，在建索引时，请把等号条件的列前置。如：<code>where c&gt;? and d=?</code> 那么即使<code>c</code>的区分度更高，也必须把d放在索引的最前列，即索引<code>idx_d_c</code>。 </p></li><li><p>【推荐】超过三个表禁止<code>join</code>。需要<code>join</code>的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。 说明：即使双表<code>join</code>也要注意表索引、<code>SQL</code>性能。 </p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;因为之前都没有很严格的代码规范，所以这周开始制定代码规范，大致从五部分来做。&lt;br&gt;【强制】严格遵守 PSR 规范，详尽的 PSR 规范可以点击链接访问&lt;a href=&quot;#&quot;&gt;URL 链接&lt;/a&gt;(&lt;a href=&quot;https://psr.phphub.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://psr.phphub.org/&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>svn 自动打包</title>
    <link href="https://wang-zc.github.io/2018/08/19/svn-%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85/"/>
    <id>https://wang-zc.github.io/2018/08/19/svn-自动打包/</id>
    <published>2018-08-19T08:22:07.000Z</published>
    <updated>2019-01-02T01:28:13.920Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>找了个时间写了一个 SVN 自动寻找某人打包的工具</p><p>最近是比较痛苦的一段时间，git 和 svn 一起运行。</p><p>然后这里面每次 svn 打包的时候都会少上文件，花了一会儿，写了一个 svn 自动打包的工具。</p></blockquote><a id="more"></a><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">fwrite(STDOUT, <span class="string">"Please enter your working copt path[ep: /www/htdocs/xxx ]"</span>);</span><br><span class="line">$path = trim(fgets(STDIN));</span><br><span class="line"></span><br><span class="line">fwrite(STDOUT, <span class="string">"Please enter your svn version for last make package [ep: 16600]:"</span>);</span><br><span class="line">$lastVersion = trim(fgets(STDIN));</span><br><span class="line"></span><br><span class="line">fwrite(STDOUT, <span class="string">"Please enter your svn name [ep: xx.zhang]:"</span>);</span><br><span class="line">$name = trim(fgets(STDIN));</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\n Path is :&#123;$path&#125;\n"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\n Version is :&#123;$lastVersion&#125;\n"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\n Name is :&#123;$name&#125;\n"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\n"</span>;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">' 3...'</span> . <span class="string">"\n"</span>;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">' 2...'</span> . <span class="string">"\n"</span>;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">' 1...'</span> . <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"-------------------------------------------------------------\n"</span>;</span><br><span class="line">exec(<span class="string">"svn info &#123;$path&#125;"</span>, $info);</span><br><span class="line"></span><br><span class="line">$revision = $info[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">empty</span>($revision)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Please Check Your Input Path? \n"</span>;</span><br><span class="line">    <span class="keyword">die</span>;</span><br><span class="line">&#125;</span><br><span class="line">$localPath = str_replace(<span class="string">'Working Copy Root Path: '</span>, <span class="string">''</span>, $info[<span class="number">1</span>]);</span><br><span class="line">$svnUrl    = str_replace(<span class="string">'URL: '</span>, <span class="string">''</span>, $info[<span class="number">2</span>]);</span><br><span class="line">preg_match_all(<span class="string">'/\d&#123;4,6&#125;/'</span>, $revision, $match);</span><br><span class="line">$version = $match[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">exec(<span class="string">'svn diff -r '</span> . $lastVersion . <span class="string">':'</span> . $version . <span class="string">' --summarize '</span> . $svnUrl, $svn);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">empty</span>($svn)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"SVN Error...Can't to make package!\n"</span>;</span><br><span class="line">    <span class="keyword">die</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Ready to collect svn update diff files....\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">$filePath = <span class="keyword">array</span>();</span><br><span class="line"><span class="keyword">foreach</span> ($svn <span class="keyword">as</span> $value) &#123;</span><br><span class="line">    $fileStatus  = substr($value, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    $svnFilePath = str_replace($fileStatus . <span class="string">'       '</span>, <span class="string">''</span>, $value);</span><br><span class="line">    $svnLog      = <span class="keyword">array</span>();</span><br><span class="line">    exec(<span class="string">'svn log -r '</span> . $lastVersion . <span class="string">':'</span> . $version . <span class="string">' '</span> . $svnFilePath . <span class="string">' | grep '</span> . $name, $svnLog);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>($svnLog)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    $changePath = str_replace($fileStatus . <span class="string">'       '</span> . $svnUrl, $localPath, $value);</span><br><span class="line">    $filePath[] = $changePath;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">empty</span>($filePath)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Can't Find Update File\n"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $count = count($filePath);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Find &#123;$count&#125; File To Update!\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mkdir</span></span><br><span class="line">    $date        = date(<span class="string">"Y-m-d"</span>);</span><br><span class="line">    $packagePath = $localPath . <span class="string">'/svn_package/'</span> . $date . <span class="string">'/'</span>;</span><br><span class="line">    <span class="keyword">if</span> (is_dir($packagePath)) &#123;</span><br><span class="line">        exec(<span class="string">'rm -rf '</span> . $packagePath . <span class="string">"*"</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Find a Exist Package FilePath\n"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mkdir($packagePath, <span class="number">0777</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> ($filePath <span class="keyword">as</span> $path) &#123;</span><br><span class="line">        $targetFile = str_replace($localPath . <span class="string">'/'</span>, $packagePath, $path);</span><br><span class="line">        $dirName    = dirname($targetFile);</span><br><span class="line">        <span class="keyword">if</span> (!is_dir($dirName)) &#123;</span><br><span class="line">            exec(<span class="string">'mkdir -p '</span> . $dirName);</span><br><span class="line">        &#125;</span><br><span class="line">        exec(<span class="string">'cp '</span> . $path . <span class="string">' '</span> . $targetFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Finish....\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;找了个时间写了一个 SVN 自动寻找某人打包的工具&lt;/p&gt;
&lt;p&gt;最近是比较痛苦的一段时间，git 和 svn 一起运行。&lt;/p&gt;
&lt;p&gt;然后这里面每次 svn 打包的时候都会少上文件，花了一会儿，写了一个 svn 自动打包的工具。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="svn" scheme="https://wang-zc.github.io/tags/svn/"/>
    
  </entry>
  
  <entry>
    <title>Gitlab 迁移</title>
    <link href="https://wang-zc.github.io/2018/08/19/Gitlab-%E8%BF%81%E7%A7%BB/"/>
    <id>https://wang-zc.github.io/2018/08/19/Gitlab-迁移/</id>
    <published>2018-08-19T08:17:09.000Z</published>
    <updated>2019-01-02T01:30:51.409Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Gitlab 是一个优秀的产品，现在已经升级到了 11.6.0 的版本了。</p></blockquote><a id="more"></a><p>之前原来组建的<code>docker</code>里的<code>Gitlab</code>打算迁移出来到一台新机器上了，新机器的硬盘也大。</p><p>这次迁移还是费了一阵功夫的。</p><p>发现自己的<code>Gitlab</code>的版本是<code>10.1.1</code>的老版本，最新的版本是<code>11.1.4</code>这个版本。</p><p>在一开始准备升级的时候提示我升级不成功，需要先升级到<code>10.8.x</code>才能升级成功，好吧，先升级到了<code>10.8</code>之后然后准备安装<code>11</code>的版本。</p><p>在一阵等待之后终于安装成功了，因为虚拟机迁移的问题，内部的端口需要重新打开配置，后来发现新机器的 <code>HTTPS</code> 正常访问，但是我之前用了 <code>ssh-key</code>方式，一直不通很难受。</p><p>一开始发现22端口始终是空闲的，其实早该想到 ssh 端口在哪里被用到了，可是愚蠢的我开始去看防火墙，看了下防火墙的配置，发现22端口是打开的，返回来又查，查不到占用。后来看端口转发设置是否有问题，发现端口转发也没问题。奇了怪了，后来问了下大哥，发现 ssh 端口是 16390 端口。。。。。。</p><p>于是改了进去 Gitlab 的端口配置，终于生效了。</p><p>可是因为虚拟机转发到了一台新主机上，发现端口变了。老机器不认这个 Host 了</p><p>GG….</p><p>查了一下如何解决之后打开本地的 Know_host 文件把之前对老机器的指纹删掉。_</p><p>后续自动发布的时候发现自己之前设置的 hooks 钩子也不生效了。</p><p>hhh</p><p>别提多烦了，初步确认应该是权限的问题，后来登录了新机器发现果然是权限问题。</p><p>同理，删了旧机器的指纹，然后给了权限。</p><p>搞定。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Gitlab 是一个优秀的产品，现在已经升级到了 11.6.0 的版本了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Gitlab" scheme="https://wang-zc.github.io/tags/Gitlab/"/>
    
  </entry>
  
  <entry>
    <title>SVN 迁移到 Gitlab</title>
    <link href="https://wang-zc.github.io/2018/08/06/SVN-%E8%BF%81%E7%A7%BB%E5%88%B0-Gitlab/"/>
    <id>https://wang-zc.github.io/2018/08/06/SVN-迁移到-Gitlab/</id>
    <published>2018-08-06T01:46:27.000Z</published>
    <updated>2019-01-02T01:29:01.560Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>自己搭建了 Gitlab 也有一段时间了，看了一下准备把一些项目陆续的迁移到 Gitlab 中。</p><p>之前迁移了一次 CM，但是过程没有记录下来。</p><p>这次记录一下过程</p><p>参考一篇文章<a href="https://blog.csdn.net/Hello_Mr_Cc/article/details/72742503" target="_blank" rel="noopener">CSDN Blog</a></p><p>还有一篇<a href="https://www.lovelucy.info/codebase-from-svn-to-git-migration-keep-commit-history.html" target="_blank" rel="noopener">Blog</a></p></blockquote><a id="more"></a><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>按照顺序执行，先把 svn 中的 author 导出成 user.txt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/www/htdocs/xxx » svn <span class="built_in">log</span> ^/ --xml | grep -P <span class="string">"^&lt;author"</span> | sort -u | perl -pe <span class="string">'s/&lt;author&gt;(.*?)&lt;\/author&gt;/$1 = /'</span> &gt; users.txt</span><br><span class="line">usage: grep [-abcDEFGHhIiJLlmnOoqRSsUVvwxZ] [-A num] [-B num] [-C[num]]</span><br><span class="line">    [-e pattern] [-f file] [--binary-files=value] [--color=when]</span><br><span class="line">    [--context[=num]] [--directories=action] [--label] [--line-buffered]</span><br><span class="line">    [--null] [pattern] [file ...]</span><br><span class="line">svn: E000032: Write error: Broken pipe</span><br></pre></td></tr></table></figure><p>但是在执行的时候报错了，提示<code>Write error: Broken pipe</code>，看了网上的一些东西，描述是，在命令的执行中，如果是<code>xxx|xxx</code>这种，上一个命令的输出，给到了下一个命令的输入，如果上一个输出有问题，那么会提示错误信息。</p><p>后来去尝试不断的拆分命令，很快就定位到了 <code>grep -P</code> 这里，grep 是没有 -P 这个选项的。看了下 man page，没找到 P 选项的含义，所以这里去除了 -P 就 OK 了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn <span class="built_in">log</span> ^/ --xml | grep <span class="string">"^&lt;author"</span> | sort -u | perl -pe <span class="string">'s/&lt;author&gt;(.*?)&lt;\/author&gt;/$1 = /'</span></span><br></pre></td></tr></table></figure><p>得到的 user.txt 是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qingping.xxx=xxx&lt;xxx@xx.cn&gt;</span><br></pre></td></tr></table></figure></p><p>这里把 Gitlab 中的 author 对应填入进去。</p><h3 id="获取-SVN-的数据到本地"><a href="#获取-SVN-的数据到本地" class="headerlink" title="获取 SVN 的数据到本地"></a>获取 SVN 的数据到本地</h3><p>通过 git svn clone 命令把 SVN 仓库导入到 Git 中，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git svn <span class="built_in">clone</span> svn://xxx.xx@svn.xx.cn:16/openapi/trunk/openapi.xx.xx --no-metadata --authors-file=user.txt /www/htdocs/openapi</span><br></pre></td></tr></table></figure><p>通过以上命令就会在目标文件夹中生成一个 git 项目<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------</span><br><span class="line">/www/htdocs/openapi(branch:master) » git branch -a</span><br><span class="line">* master</span><br><span class="line">  remotes/git-svn</span><br><span class="line">------------------------------------------------------------</span><br></pre></td></tr></table></figure></p><p>但是这里生成了一个本地的 master 分支，和一个 git-svn 的 remote，我总是看这个 git-svn 不顺眼，如何才能删掉呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/www/htdocs/openapi(branch:master) » git remote rm remotes/git-svn</span><br><span class="line">error: Could not remove config section <span class="string">'remote.remotes/git-svn'</span></span><br></pre></td></tr></table></figure><p>发现这里有些奇怪，这里感觉有些奇怪，但是也没有</p><p>借鉴了博客里面的东西，使用<code>git clone</code>删除了里面原有的 git-svn remote.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;自己搭建了 Gitlab 也有一段时间了，看了一下准备把一些项目陆续的迁移到 Gitlab 中。&lt;/p&gt;
&lt;p&gt;之前迁移了一次 CM，但是过程没有记录下来。&lt;/p&gt;
&lt;p&gt;这次记录一下过程&lt;/p&gt;
&lt;p&gt;参考一篇文章&lt;a href=&quot;https://blog.csdn.net/Hello_Mr_Cc/article/details/72742503&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSDN Blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还有一篇&lt;a href=&quot;https://www.lovelucy.info/codebase-from-svn-to-git-migration-keep-commit-history.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Blog&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL 索引探索</title>
    <link href="https://wang-zc.github.io/2018/05/07/MySQL-%E7%B4%A2%E5%BC%95%E6%8E%A2%E7%B4%A2/"/>
    <id>https://wang-zc.github.io/2018/05/07/MySQL-索引探索/</id>
    <published>2018-05-07T02:30:08.000Z</published>
    <updated>2019-01-02T01:31:15.960Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>关于索引，你想知道的事情</p></blockquote><a id="more"></a><h3 id="索引是什么？"><a href="#索引是什么？" class="headerlink" title="索引是什么？"></a>索引是什么？</h3><h4 id="索引的解释"><a href="#索引的解释" class="headerlink" title="索引的解释"></a>索引的解释</h4><blockquote><p><a href="https://zh.wikipedia.org/wiki/数据库索引" target="_blank" rel="noopener">数据库索引</a>，是数据库管理系统中一个排序的数据结构，以协助快速查询，更新数据库表中数据。</p></blockquote><ul><li><p>值得注意的是：SQL 标准并没有为数据库用户提供任何在数据库系统中控制创建和维护索引的防范，由于索引是冗余的数据结构，因此索引对保证正确性来说并不是必须的；但是索引对事务的高效处理十分重要，对完整性约束的有效实施也很重要；如果没有索引的话，MySQL进行全表扫描会对资源进行极大的浪费.</p></li><li><p><strong>如果不恰当的使用索引的话，只会增加无效的数据维护，耗费资源，同时查询效率仍然得不到提高。</strong></p></li><li><p>那么索引究竟是什么呢？<strong>索引是一种数据结构，一个索引是存储的表中一个特定列或者某几个特定列的值数据结构</strong>，索引是在列上创建的。</p></li></ul><h4 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h4><blockquote><p>有两种基本的索引类型<br><strong>顺序索引</strong>：基于值的顺序排序<br><strong>散列索引</strong>：基于将值平均分布在若干散列桶中，一个值所属的散列通是有一个函数决定的，该函数被称为<em>散列函数</em></p></blockquote><h6 id="顺序索引"><a href="#顺序索引" class="headerlink" title="顺序索引"></a>顺序索引</h6><p>顺序索引中，根据包含记录是否按照搜索码制定的顺序排序可以分为<strong>聚集索引和非聚集索引</strong></p><ul><li>被索引文件中的记录自身也可以按照某种排序顺序存储，一个文件可以有多个索引，分别预计不同的搜索码，如果包含记录的文件按照某个搜索码指定的顺序排序，那么改搜索码对应的索引称为<em>聚集索引</em>，也称为主索引(Primary Index)。</li><li>搜索码指定的顺序于文件中记录的物理顺序不同的索引被称为<strong>非聚集索引</strong>或者<strong>辅助索引</strong>。</li><li>非聚集索引和聚集索引的区别在于，通过聚集索引可以查到需要查找的数据，而通过非聚集索引可以查到记录对应的主键值, 再使用主键的值通过聚集索引查找到需要的数据</li><li>关于数据库中 Key，Primary Key，Unique Key 与 index 的不同可以参见这篇<a href="https://blog.csdn.net/nanamasuda/article/details/52543177" target="_blank" rel="noopener">文章</a></li><li>关于顺序索引，一般如果没有明确表示的话指的就是 B+Tree 索引</li></ul><h6 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h6><ul><li>哈希索引(hash index)基于哈希表实现，只有精确匹配索引所有咧的查询才有效；对于每一行数据，存储引擎都会对所有的索引计算一个哈希码，哈希吗是一个较小的值，并且不同键值计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</li></ul><blockquote><p><em>聚簇索引和非聚簇索引并不是单独的索引类型，而是一种数据存储方式</em> [高性能 MySQL]</p></blockquote><h4 id="索引的优点和缺点"><a href="#索引的优点和缺点" class="headerlink" title="索引的优点和缺点"></a>索引的优点和缺点</h4><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ul><li>索引大大减少减少了服务器需要扫描的数据量</li><li>索引可以帮助服务器避免排序和临时表</li><li>索引可以将随机 I/O 变为顺序 I/O</li></ul><h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><blockquote><p>索引的缺点主要是针对不合理索引而言的，对于开发者而言，索引维护所耗费的资源和索引所提供的快速查询能力节省的时间资源两者进行取舍。</p></blockquote><ul><li>创建和维护索引都需要耗费时间，而且随着数据量的增加而增加。</li><li>每个索引还需要耗费额外的物理空间资源。</li><li>当对表中的数据进行 CURD 操作的时候，索引也需要对应的动态维护，增加数据维护成本。</li></ul><h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><blockquote><p>MySQL 存储索引的时候一般我们没有明确之处其余结构就是指的是 B-Tree 数据结构存储索引。<a href="https://blog.csdn.net/linglongwunv/article/details/20066823" target="_blank" rel="noopener">参考资料</a></p></blockquote><blockquote><p>卫星数据：指的是索引元素所指向的数据记录，比如数据库的某一行。</p></blockquote><h4 id="磁盘-I-O"><a href="#磁盘-I-O" class="headerlink" title="磁盘 I/O"></a>磁盘 I/O</h4><ul><li>动态查询树主要有：二叉查找树，平衡二叉查找树，红黑树，B-Tree/B+Tree/B*Tree</li><li>前三者是典型的二叉查找树结构，其查找的时间复杂度O(log2N)与树的深度相关，那么降低树的深度自然对查找效率是有所提高的；还有一个实际问题：就是大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了），这样导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下，那么如何减少树的深度，一个基本的想法就是：采用多叉树结构（由于树节点元素数量是有限的，自然该节点的子树数量也就是有限的）。</li><li>关于硬盘(外存储器)的解读,磁盘获取数据由三部分时间组成:查找时间(代价最高),等待时间,传输时间.</li><li>磁盘读取数据是以盘块(block)为基本单位的。位于同一盘块中的所有数据都能被一次性全部读取出来。而磁盘IO代价主要花费在查找时间Ts上。因此我们应该尽量将相关信息存放在同一盘块，同一磁道中。或者至少放在同一柱面或相邻柱面上，以求在读/写信息时尽量减少磁头来回移动的次数，避免过多的查找时间Ts。</li><li>当我们利用索引查询的时候,显然不可能把整个索引全部加载到内存中,只能逐一加载每一个磁盘页,这里的磁盘页对应这索引树的节点.</li><li>在使用树结构查询的时候如果使用二叉树,那么磁盘的 IO 次数最坏情况下等于索引树的高度.此时索引树的高度就对查询资源至关重要.</li></ul><h4 id="B-Tree-Wiki"><a href="#B-Tree-Wiki" class="headerlink" title="B-Tree Wiki"></a>B-Tree <a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener">Wiki</a></h4><p><strong>什么是 B-Tree？</strong>一个 m 阶的 B 树有以下几个特征。</p><ol><li>根节点至少有两个子节点</li><li>每个中间节点都包含 K-1个元素和 K 个子节点，其中 m/2&lt;=k&lt;=m</li><li>每一个叶子节点都包含 K-1个元素，其中 m/2&lt;=k&lt;=m</li><li>所有的叶子节点都位于同一层</li><li>每个非终端节点中包含有 n 个关键词信息(n，P0，K1，P1，K2….Kn，Pn)<br> a. 其中 n 的取值范围是ceil(m/2)-1&lt;=n&lt;=m-1<br> b. Ki为关键字,且关键字按照顺序排序(K(i-1)&lt;Ki)<br> c. Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。[<strong>每个节点中的元素从小到大排列，节点当中 K-1个元素正好是 K 个孩子包含元素的值域划分</strong>]<img src="/2018/05/07/MySQL-索引探索/B-Tree.png"></li></ol><blockquote><p>模拟查找文件29的过程：</p></blockquote><blockquote><p> (1) 根据根结点指针找到文件目录的根磁盘块1，将其中的信息导入内存。【磁盘IO操作1次】</p></blockquote><blockquote><p> (2) 此时内存中有两个文件名17，35和三个存储其他磁盘页面地址的数据。根据算法我们发现17&lt;29&lt;35，因此我们找到指针p2。</p></blockquote><blockquote><p>(3) 根据p2指针，我们定位到磁盘块3，并将其中的信息导入内存。【磁盘IO操作2次】</p></blockquote><blockquote><p>(4) 此时内存中有两个文件名26，30和三个存储其他磁盘页面地址的数据。根据算法我们发现26&lt;29&lt;30，因此我们找到指针p2。</p></blockquote><blockquote><p>(5) 根据p2指针，我们定位到磁盘块8，并将其中的信息导入内存。【磁盘IO操作3次】</p></blockquote><blockquote><p>(6) 此时内存中有两个文件名28，29。根据算法我们查找到文件29，并定位了该文件内存的磁盘地址。</p></blockquote><blockquote><p>分析上面的过程，发现需要3次磁盘IO操作和3次内存查找操作。关于内存中的文件名查找，由于是一个有序表结构，可以利用折半查找提高效率。至于3次磁盘IO操作时影响整个B-tree查找效率的决定因素。</p></blockquote><blockquote><p>当然，如果我们使用平衡二叉树的磁盘存储结构来进行查找，磁盘IO操作最少4次，最多5次。而且文件越多，B-tree比平衡二叉树所用的磁盘IO操作次数将越少，效率也越高。</p></blockquote><img src="/2018/05/07/MySQL-索引探索/1525599028356.png"><p>B 树中每个节点都具有<strong>卫星数据</strong></p><h6 id="节点的插入"><a href="#节点的插入" class="headerlink" title="节点的插入"></a>节点的插入</h6><blockquote><p>插入（insert）操作：插入一个元素时，首先在B-tree中是否存在，如果不存在，即在叶子结点处结束，然后在叶子结点中插入该新的元素，注意：如果叶子结点空间足够，这里需要向右移动该叶子结点中大于新插入关键字的元素，如果空间满了以致没有足够的空间去添加新的元素，则将该结点进行“分裂”，将一半数量的关键字元素分裂到新的其相邻右结点中，中间关键字元素上移到父结点中（当然，如果父结点空间满了，也同样需要“分裂”操作），而且当结点中关键元素向右移动了，相关的指针也需要向右移。如果在根结点插入新元素，空间满了，则进行分裂操作，这样原来的根结点中的中间关键字元素向上移动到新的根结点中，因此导致树的高度增加一层。</p></blockquote><p>例:自顶向下查找4的节点位置，发现4应当插入到节点元素3，5之间</p><img src="/2018/05/07/MySQL-索引探索/1525597344961.png"><p>节点3，5已经是两元素节点，无法再增加。父亲节点 2， 6 也是两元素节点，也无法再增加。根节点9是单元素节点，可以升级为两元素节点。于是拆分节点3，5与节点2，6，让根节点9升级为两元素节点4，9。节点6独立为根节点的第二个孩子</p><img src="/2018/05/07/MySQL-索引探索/1525597368111.png"><h6 id="节点的删除操作"><a href="#节点的删除操作" class="headerlink" title="节点的删除操作"></a>节点的删除操作</h6><blockquote><p>删除(delete)操作：首先查找B-tree中需删除的元素,如果该元素在B-tree中存在，则将该元素在其结点中进行删除，如果删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素到父节点中，然后是移动之后的情况；如果没有，直接删除后，移动之后的情况.。</p></blockquote><blockquote><p>删除元素，移动相应元素之后，如果某结点中元素数目小于ceil(m/2)-1，则需要看其某相邻兄弟结点是否丰满（结点中元素个数大于ceil(m/2)-1），如果丰满，则向父节点借一个元素来满足条件；如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于ceil(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点，以此来满足条件。那咱们通过下面实例来详细了解吧。</p></blockquote><p>例:删除11节点</p><img src="/2018/05/07/MySQL-索引探索/1525597390731.png"><p>删除11后，节点12只有一个孩子，不符合B树规范。因此找出12,13,15三个节点的中位数13，取代节点12，而节点12自身下移成为第一个孩子。（这个过程称为左旋）</p><img src="/2018/05/07/MySQL-索引探索/1525597423876.png"><h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h4><blockquote><p>B+Tree 是对于 B-Tree 的一种变体，有着比 B-Tree 更高的查询效率。</p></blockquote><p><strong>一个 m 阶的 B 树有着如下特点</strong></p><ol><li>有 K 个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</li><li>所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li><li>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</li></ol><img src="/2018/05/07/MySQL-索引探索/1525598880919.png"><p>根节点的最大元素等荣誉整个树的最大元素,叶子节点包含了全量元素信息,并且每一个叶子节点都带有指向下一个节点的指针,形成了一个有序链表.</p><img src="/2018/05/07/MySQL-索引探索/1525598986414.png"><p>在 B+Tree 树中,只有叶子节点保存卫星数据.</p><img src="/2018/05/07/MySQL-索引探索/1525599206701.png"><p>需要补充的是，在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。</p><p>由于 B+Tree 树的中间节点没有卫星数据，所以同样大小的磁盘也(1~4K)可以容纳更多的元素，意味着查询的 IO 次数越少。</p><p>另外，B+Tree 的查询必须最终查询到叶子节点，和 B-Tree 不同，查询性能最稳定，而且在范围查询中，比起只能以来繁琐的中序遍历的 B 树，更有效率。</p><p>综合来看，B+Tree 对比 B-Tree 有三大优势:</p><ol><li>单一节点存储更多的元素，使得查询的IO次数更少。</li><li>所有查询都要查找到叶子节点，查询性能稳定。</li><li>所有叶子节点形成有序链表，便于范围查询。</li></ol><h4 id="哈希索引-1"><a href="#哈希索引-1" class="headerlink" title="哈希索引"></a>哈希索引</h4><blockquote><p>关于哈希索引，目前 MySQL 中只有 Memory 和 NDB 两种引擎支持，详细了解可以参考这篇文章<a href="http://homeway.me/2015/09/13/mysql-hash-index/" target="_blank" rel="noopener">MySQL索引之哈希索引</a>，本文不在赘述。</p></blockquote><h3 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h3><blockquote><p>理解了索引的数据结构之后我们就理解了索引在创建和使用上的一些方法(以下所描述的索引均指的是 B-Tree 索引)。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> People (</span><br><span class="line">    last_name   <span class="built_in">varchar</span>(<span class="number">50</span>)     <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    first_name  <span class="built_in">varchar</span>(<span class="number">50</span>)     <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    dob         <span class="built_in">date</span>            <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    gendar      enum(<span class="string">'m'</span>,<span class="string">'f'</span>)   <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">key</span>(last_name, first_name, dob)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p></blockquote><ul><li>使用 B-Tree 索引的查询类型适用于下列集中情况</li></ul><ol><li><p>全值匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from People where last_name = &apos;Allen&apos; and first_name = &apos;Cuba&apos; and dob = &apos;1999-01-01&apos;;</span><br></pre></td></tr></table></figure></li><li><p>匹配最左前缀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from People where last_name = &apos;Allen&apos;;</span><br></pre></td></tr></table></figure></li><li><p>匹配列前缀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from People where last_name like &apos;A%&apos;;</span><br></pre></td></tr></table></figure></li><li><p>匹配范围值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from People where last_name &gt; &apos;Allen&apos; and last_name &lt; &apos;Bob&apos;;</span><br></pre></td></tr></table></figure></li><li><p>精确匹配某一列并范围匹配另外一列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from People where last_name = &apos;Allen&apos; and last_name like &apos;B%&apos;;</span><br></pre></td></tr></table></figure></li><li><p>只访问索引的查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select  last_name, </span><br><span class="line">        first_name, </span><br><span class="line">        dob</span><br><span class="line">from People </span><br><span class="line">where   last_name = &apos;Allen&apos; </span><br><span class="line">    and first_name = &apos;Cuba&apos; </span><br><span class="line">    and dob = &apos;1999-01-01&apos;;</span><br></pre></td></tr></table></figure></li></ol><ul><li>关于使用索引的一些限制</li></ul><ol><li><p>如果不是按照索引的最左列开始查找，则无法使用索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from People where first_name = &apos;Allen&apos;;</span><br></pre></td></tr></table></figure></li><li><p>不能跳过索引中的列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from People where last_name = &apos;Allen&apos; and dob = &apos;1999-01-01&apos;;</span><br></pre></td></tr></table></figure></li><li><p>如果查询中有某个列的范围查询，则其右边的所有咧都无法使用索引优化查询</p><pre><code>select * from People where last_name = &apos;Allen&apos; and first_name like &apos;J%&apos; and dob = &apos;1999-01-01&apos;;</code></pre><h5 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h5></li></ol><blockquote><p><a href="https://tech.meituan.com/mysql-index.html" target="_blank" rel="noopener">参考资料</a></p></blockquote><blockquote><ol><li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li></ol></blockquote><blockquote><ol start="2"><li>使用独立的列</li></ol></blockquote><blockquote><ol start="3"><li>多列索引：MySQL 从5.0之后的更新版本引入了一种叫<strong>索引合并</strong>的<a href="https://dev.mysql.com/doc/refman/5.6/en/index-merge-optimization.html" target="_blank" rel="noopener">策略</a>，关于这项策略可以参考<a href="http://www.cnblogs.com/digdeep/p/4975977.html" target="_blank" rel="noopener">MySQL 优化之 index merge</a></li></ol></blockquote><blockquote><ol start="4"><li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li></ol></blockquote><blockquote><ol start="5"><li>尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录</li><li>索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);</li><li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li></ol></blockquote><hr><p>一些有价值的参考资料</p><ul><li><a href="http://www.freeoa.net/osuport/db/mysql-index-using-study-note_2827.html" target="_blank" rel="noopener">http://www.freeoa.net/osuport/db/mysql-index-using-study-note_2827.html</a></li><li><a href="https://blog.csdn.net/alexdamiao/article/details/51934917" target="_blank" rel="noopener">https://blog.csdn.net/alexdamiao/article/details/51934917</a></li><li><a href="https://zhuanlan.zhihu.com/p/23624390" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23624390</a></li><li><a href="https://www.cnblogs.com/morvenhuang/archive/2009/03/30/1425534.html" target="_blank" rel="noopener">https://www.cnblogs.com/morvenhuang/archive/2009/03/30/1425534.html</a></li><li><a href="http://www.cnblogs.com/digdeep/p/4975977.html" target="_blank" rel="noopener">http://www.cnblogs.com/digdeep/p/4975977.html</a></li><li><a href="https://tech.meituan.com/mysql-index.html" target="_blank" rel="noopener">https://tech.meituan.com/mysql-index.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;关于索引，你想知道的事情&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://wang-zc.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://wang-zc.github.io/2018/05/07/hello-world/"/>
    <id>https://wang-zc.github.io/2018/05/07/hello-world/</id>
    <published>2018-05-07T02:05:58.676Z</published>
    <updated>2018-05-07T02:05:58.676Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>High Availability PHP System</title>
    <link href="https://wang-zc.github.io/2017/07/07/High-Availability-PHP-System/"/>
    <id>https://wang-zc.github.io/2017/07/07/High-Availability-PHP-System/</id>
    <published>2017-07-07T15:41:14.000Z</published>
    <updated>2018-05-07T15:44:44.163Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>自从去北京参加完 Devlink 的 PHP 开发者大会回来一直没有和小伙伴分享得到的收获,这次准备了一个 KeyNote 来讲述</p></blockquote><img src="/2017/07/07/High-Availability-PHP-System/高可用的PHP.001.jpeg"><img src="/2017/07/07/High-Availability-PHP-System/高可用的PHP.002.jpeg"><img src="/2017/07/07/High-Availability-PHP-System/高可用的PHP.003.jpeg"><img src="/2017/07/07/High-Availability-PHP-System/高可用的PHP.004.jpeg"><img src="/2017/07/07/High-Availability-PHP-System/高可用的PHP.005.jpeg"><img src="/2017/07/07/High-Availability-PHP-System/高可用的PHP.006.jpeg"><img src="/2017/07/07/High-Availability-PHP-System/高可用的PHP.007.jpeg"><img src="/2017/07/07/High-Availability-PHP-System/高可用的PHP.008.jpeg"><img src="/2017/07/07/High-Availability-PHP-System/高可用的PHP.009.jpeg"><img src="/2017/07/07/High-Availability-PHP-System/高可用的PHP.010.jpeg"><img src="/2017/07/07/High-Availability-PHP-System/高可用的PHP.011.jpeg"><img src="/2017/07/07/High-Availability-PHP-System/高可用的PHP.012.jpeg">]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;自从去北京参加完 Devlink 的 PHP 开发者大会回来一直没有和小伙伴分享得到的收获,这次准备了一个 KeyNote 来讲述&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;/2017/07/07/High-Availability-
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://wang-zc.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>艺龙搬砖项目复盘</title>
    <link href="https://wang-zc.github.io/2017/04/17/%E8%89%BA%E9%BE%99%E6%90%AC%E7%A0%96%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/"/>
    <id>https://wang-zc.github.io/2017/04/17/艺龙搬砖项目复盘/</id>
    <published>2017-04-17T15:46:36.000Z</published>
    <updated>2018-05-07T15:49:00.666Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>艺龙的搬砖项目可以说是接受挑战比较大的项目了,做完之后来了一次复盘</p></blockquote><img src="/2017/04/17/艺龙搬砖项目复盘/艺龙搬砖复盘.001.jpeg"><img src="/2017/04/17/艺龙搬砖项目复盘/艺龙搬砖复盘.002.jpeg"><img src="/2017/04/17/艺龙搬砖项目复盘/艺龙搬砖复盘.003.jpeg"><img src="/2017/04/17/艺龙搬砖项目复盘/艺龙搬砖复盘.004.jpeg"><img src="/2017/04/17/艺龙搬砖项目复盘/艺龙搬砖复盘.005.jpeg"><img src="/2017/04/17/艺龙搬砖项目复盘/艺龙搬砖复盘.006.jpeg"><img src="/2017/04/17/艺龙搬砖项目复盘/艺龙搬砖复盘.007.jpeg"><img src="/2017/04/17/艺龙搬砖项目复盘/艺龙搬砖复盘.008.jpeg"><img src="/2017/04/17/艺龙搬砖项目复盘/艺龙搬砖复盘.009.jpeg"><img src="/2017/04/17/艺龙搬砖项目复盘/艺龙搬砖复盘.010.jpeg"><img src="/2017/04/17/艺龙搬砖项目复盘/艺龙搬砖复盘.011.jpeg"><img src="/2017/04/17/艺龙搬砖项目复盘/艺龙搬砖复盘.012.jpeg"><img src="/2017/04/17/艺龙搬砖项目复盘/艺龙搬砖复盘.013.jpeg"><img src="/2017/04/17/艺龙搬砖项目复盘/艺龙搬砖复盘.014.jpeg">]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;艺龙的搬砖项目可以说是接受挑战比较大的项目了,做完之后来了一次复盘&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;/2017/04/17/艺龙搬砖项目复盘/艺龙搬砖复盘.001.jpeg&quot;&gt;
&lt;img src=&quot;/2017/04/17/艺
      
    
    </summary>
    
    
      <category term="项目成长" scheme="https://wang-zc.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>华衫讲孙子兵法读后感</title>
    <link href="https://wang-zc.github.io/2016/12/05/%E5%8D%8E%E8%A1%AB%E8%AE%B2%E5%AD%99%E5%AD%90%E5%85%B5%E6%B3%95%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    <id>https://wang-zc.github.io/2016/12/05/华衫讲孙子兵法读后感/</id>
    <published>2016-12-05T15:36:08.000Z</published>
    <updated>2018-05-07T15:39:36.615Z</updated>
    
    <content type="html"><![CDATA[<p>今天读完了《华衫讲透孙子兵法》，这本书对我而言读起来还是比较费劲的，一些概念理解起来比较难，其中掺杂着一些注解，在最一开始去理解文言文的意思，经常出错，需要不断的去查古文字典来校对，但是读到后面结合着华杉讲大白话文慢慢的啃下来。读完最大的感触是，哇，这本书，今后十年都值得我反复去读。</p><p>言归正传，这本书一共十三章</p><ul><li>计篇</li><li>作战</li><li>谋攻</li><li>军行</li><li>兵势</li><li>虚实</li><li>军争</li><li>九变</li><li>行军</li><li>地形</li><li>九地</li><li>火攻</li><li>用间<br>如果时间紧的话，可以仔细查阅下第一章《计篇》，孙子兵法最精髓的文字都在这一章了。我个人在读书的时候也是会经常性的翻回第一章，因为后面的很多内容都是对第一章的解读，孙子兵法自春秋战国起至今已经两千七百多年的历史了，被各个朝代君王或将领解读的更是数不胜数，短短几天我肯定不会悟出什么大道理哈哈哈，否则我就是圣人了（虽然我一直很崇拜王阳明…）只有一些切身的体会写出来共享一下，权作纪念吧。</li></ul><blockquote><p>“兵者，国之大事，死生之道，存亡之道，不可不察也”</p></blockquote><p>这句话是计篇的第一句话，也说出了孙子的价值观，孙子兵法研究的不是战之法，其实是不战之法，这一直是我的错误理解，之前一说孙子兵法，总和三十六计联系起来，受到了很多误导，孙子兵法讲的通篇都是讲堂堂正正之道，“五事七计”，道、天、地、将、法，关乎国计民生，生死存亡。又怎么会是明修栈道、暗度陈仓的阴谋诡计呢（笑…</p><p>道为民，为民愿，说个大白话就是广大人民的根本利益，要师出有名，正义不正义这种事情需要这场战争结束了几十年一百年之后才会盖棺定论，所以要想在道上胜出就要靠宣传机器，国家的宣传机器甚至比战争机器还要重要，什么狐狸叫，鱼藏刀都是常用的手段，老百姓信啥，就给他搞啥，这样就能集合众心众力，再套一句大白话（老乡，跟着红军有地分啊）就明白啥意思了。<br>天为军事气象学，阴阳为气势，寒暑为时令。还涉及到了“势”..比较玄..</p><p>地为地形，散、轻、争、交、衢、重、圮、围、死九种地名</p><p>将者，智、信、仁、勇、严也，这一条涉及到了选将任能，一些管理的知识，我没有太理解其中很多的话语是否有更深层次的解读，也和我的本身经历有关，没有过管理的经历～<br>法，也为管理，想想也是，两军交战就是那么一下子刺激，其余绝大多数时间都是在军营中操练士卒，如何制订军法，如何管理部下，都是大学问，要么刘邦问韩信说，我能带多少兵？韩信说：“主公，十万兵，不能更多了”。刘邦问：“你呢？”，韩信说：“多多益善”。管理的学问就在此处。</p><p>在孙子兵法中，有一点是多处体现的 ：“胜兵先胜而后求战，败兵先战而后求胜”，这句话简直是….精彩绝伦！要让自己不可战胜，顺便打一场稳赢的仗，最好能不打，直接招降算了。而且所谓胜利不是指的是消灭敌人就叫胜利了，关键是自己变得强了还是弱了，如果杀敌一千，自损八百，很难说是不是胜利。我也没办法做很多的解读，处于只可意会不能言传的状态…囧</p><p>知己知彼，百战不殆。这句话流传甚广，大家的重点很容易想到知彼上去，这一点在兵法中也有体现，就是最后一章《用间》，但是真正重要的其实是知己啊，“不知彼而知己，一胜一负；不知彼，不知己，每战必败”，知晓自己的优势和劣势，扬长避短，让敌人无法分清你的虚实，调动敌人而不被敌人调动，兵法云：故善战者，致人而不致于人。</p><p>最后说说心，“以治待乱，以静待哗，此治心者也”，这里有很深的感悟，因为最近自己深处的环境不是特别安稳，有一种隐而未发的动荡感，总感觉工作和生活都比较不在节奏上，看到何氏注解的那一段的时候心有悸动。原注如下：</p><blockquote><p>吾之治足以待乱，吾之静足以待哗，前有百万之敌，而吾视之，则如遇小寇。亚夫之遇寇也，坚卧不起；栾箴之临敌也，好以整，又好以暇。夫审此二人，蕴以何术哉？盖其心智之所有素，养之有余也。</p></blockquote><p>海纳百川，有容乃大，壁立千仞，无欲则刚。治自己的心，是一切的根本。</p><p>但是读的时候也有很多地方不理解，甚至不认同，兵法一书，也绝不可能面面具到，把所有的人生大道理都给你讲的透透的，要不然还要那么多文人注解作何用，一本周易永流传了。但是读兵法带给人的感受是读其它书籍全然未有过的，兵法讲的是计，讲的是胸怀天下，登高望远，现在的我们虽然不可能把孙子叫回来让他老人家给你解释一下，但是通过看兵法，稍加体会亦能受益无穷。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天读完了《华衫讲透孙子兵法》，这本书对我而言读起来还是比较费劲的，一些概念理解起来比较难，其中掺杂着一些注解，在最一开始去理解文言文的意思，经常出错，需要不断的去查古文字典来校对，但是读到后面结合着华杉讲大白话文慢慢的啃下来。读完最大的感触是，哇，这本书，今后十年都值得我
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://wang-zc.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>支付战争</title>
    <link href="https://wang-zc.github.io/2016/11/20/%E6%94%AF%E4%BB%98%E6%88%98%E4%BA%89/"/>
    <id>https://wang-zc.github.io/2016/11/20/支付战争/</id>
    <published>2016-11-20T15:33:16.000Z</published>
    <updated>2018-05-07T15:39:35.815Z</updated>
    
    <content type="html"><![CDATA[<p>周六和朋友打羽毛球打得肉疼不已…趁着周天下雨的功夫把《支付战争》读完了，埃里克写的很好，读起来酣畅淋漓，仿佛自己就在世纪初的PayPal公司和他们一起经历这些起起伏伏。创业这个事儿真是不容易。</p><p>1999年，那个时候马云和他的十八罗汉在杭州建立阿里巴巴，在太平洋的另一边有一群疯狂而有充满激情的人开始了他们的创业之路，彼得·蒂尔和马克斯·列夫琴一起组建了一家公司立志于解决支付问题，我想大概从那时开始创业公司就有了这种调性，就像埃里克在书中说的那样“混乱的办公室，热情洋溢不知道谁是谁的同事们，这是一群心底的狂人，欢迎来到创业公司”。混乱之中蕴含着无尽的想象力和可能性，这是在CBD的格子间里绝对不会感受到的。就像很多的电影中描绘的那样，这家年轻充满活力的公司走上了漫长的统治世界之路。</p><p>但是在小的公司也会有对手存在，除非你马上小的关门了，几个月后PayPal迎来了他的对手们，dotBank和X.com，似乎大家意识到支付领域的美味，都想进来分一杯羹。在同对手不断的竞争中，PayPal也对自己的业务进行了明确的定位，专注于拍卖领域，想尽一切办法拓展新用户，有用户才有未来嘛。此时的PayPal无疑是整个发展阶段最有吸引力的时候，在这个阶段，紧张刺激的竞争，新行业的急先锋，充满希望的伟大愿景使得大量人才纷涌而至，这些激情洋溢的年轻人成就了日后名震世界的PayPal黑帮…不过创业公司都是最烧钱的公司，尤其是像PayPal这样立足于新兴行业需要教育用户的公司无疑更是烧的厉害，要想走的更远就需要尽快消灭对手，壮大自己，在这种强敌环伺的情况下PayPal要想走下去就不可避免的选择了消灭对手的另外一种方式：合并。PayPal和X.com进行了合并，成功的甩开了其他的竞争对手，成为行业内的领先者。但是每一次合并都是对公司文化的冲击和考验，X.com有着其完全不同的文化氛围（从他们的工程师喜欢用Windows就知道了。。）PayPal在这次合并过程中占据弱势，尤其是在马斯克任职CEO之后，有着“钢铁侠”之称的埃隆·马斯克从来都不是好惹的人，在公司的整合之中，PayPal的品牌危机、产品危机、客服危机不断爆发，支付业务所依赖的巨头eBay也开始反击，2000年的上半年对PayPal来说充满恶意。</p><p>在接下来的业务转型中，PayPal开始艰难的从一个免费的互联网服务变成一个成功的付费服务，产品的艰难转型，用户的谩骂，财政赤字的上涨，诈骗团伙的虎视眈眈令人绝望。马斯克领导下的PayPal不可避免的走向深渊，而长久以来的文化交锋也日益激烈，PayPal诞生后最激烈的罢免就在这样的环境下产生了，马斯克下台，蒂尔重新执掌公司，到这里不禁判断出，对PayPal而言，蒂尔才是他们的精神领袖，而马斯克不是，但是对X.com的人来说又恰好相反，公司文化这种东西真是妙不可言。事实上蒂尔真的给人惊喜，在蒂尔执掌公司之后，PayPal全力削减成本，账户升级高达95%，诈骗损失被遏制住，说是力挽狂澜也丝毫不为过。</p><p>但是PayPal自始至终都有一个强大的对手，PayPal的大多数业务都依赖于拍卖平台eBay，而当eBay开始发力做支付时，来自于垄断者和重量级平台的威胁让人喘不过气来。孙子兵法有句话：昔之善战者，先为不可胜，以待敌之可胜。在这样的情况下，最大化的利用自己的优势，等待eBay自己露出马脚，然后用尽全力主动出击才有一线生机，当面对这样一个对手的时候，怎么重视都不为过。但是面对这样一个对手，结局也很简单，要么创新业务，脱离依赖，要么被平台收购结束持久战。在经历了各种波折的IPO之后，eBay以15亿美元收购PayPal，在新一步的公司整合中，蒂尔离职，PayPal黑帮各自离职创业。如今的PayPal也已经成为支付业的巨头，难以撼动。</p><p>在读这本书的过程中，穿插着很多条线，而我对其中的两条线特别感兴趣，一条是技术发展，一条是公司文化。两条线又相互交缠在一起。技术在PayPal的发展中是至关重要的一环，早期通过工程师在eBay页面上作嵌入标记开展了PayPal在拍卖支付业务，在获取用户的过程中退出的网络买手机器人计划让PayPal在最初的竞争中占据了先发优势。在和X.com的整合过程中，技术冲突是公司文化冲突的主战场，（X.com的工程师喜欢在Windows平台上工作，而马克斯·列夫琴领导的PayPal团队在Unix平台上工作，这不亚于宗教战争啊同志们！！）工程团队的混乱导致公司无法向前推进，因为在互联网创业公司，技术绝对是根基的存在，没有牢固的技术架构，业务模型无法扩大和发展。统一平台，统一管理，是PayPal走下去必须解决的问题，在发展过程中，马克斯着力于使用技术手段遏制诈骗损失，推出了大名鼎鼎的“列夫琴测试”和“伊戈尔”扫描程序，相信如今所有的人都或多或少的使用接触过这项技术。2000年推出的验证码，被沿用至今，一项伟大的发明。作为一名工程人员，最大的幸福也莫过于此吧。。。而在后期的发展中，工程师们总是表现最明显的一员，IPO时八点五十就到公司了。。啧啧真可怕。。 ：）</p><p>读完之后对马克斯·列夫琴充满好奇和敬佩。</p><p>希望成为这样的人</p><p>ps：还有好多好多的支线…天太冷了，不想写了…干脆把提纲贴出哈哈哈</p><p>想想下一本书看啥呢。。。</p><img src="/2016/11/20/支付战争/pic1.jpg"><img src="/2016/11/20/支付战争/pic2.jpg"><img src="/2016/11/20/支付战争/pic3.jpg">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;周六和朋友打羽毛球打得肉疼不已…趁着周天下雨的功夫把《支付战争》读完了，埃里克写的很好，读起来酣畅淋漓，仿佛自己就在世纪初的PayPal公司和他们一起经历这些起起伏伏。创业这个事儿真是不容易。&lt;/p&gt;
&lt;p&gt;1999年，那个时候马云和他的十八罗汉在杭州建立阿里巴巴，在太平洋
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://wang-zc.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>精益创业实战</title>
    <link href="https://wang-zc.github.io/2016/11/07/%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A%E5%AE%9E%E6%88%98/"/>
    <id>https://wang-zc.github.io/2016/11/07/精益创业实战/</id>
    <published>2016-11-07T15:26:47.000Z</published>
    <updated>2018-05-07T15:52:18.171Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这周某个时候和卢大哥讨论起了软件测试的问题，很巧的是我们有一些不同的看法，这个时候大哥给给我递了一本书，年轻人多看书，多看报，少吃零食早睡觉，一脸不信的我接过了书趁着周末这两天窝在北邮的自习室里读完了这本《精益创业实战》，一本好书，值得多读几遍。</p></blockquote><blockquote><p>本书的作者是Ash Maurya，以下简称老A..写作者的话嗯..严肃了……</p></blockquote><p>－－－－－－－－－－－－－－－－－－</p><p>目录是很吸引人的地方，打个比喻，你和一个人相亲，绝大多数情况下，估计会先看看这个人的照片，如果还感兴趣的话听听别人的评价，和读书是一样一样滴，看看目录，读读序言，心里大致对这本书有个模糊的认知，接下来就是带着疑问和思考去读书啦。</p><p>身处一家互联网创业公司，而且还是在中关村这片地儿，早上卖煎饼果子的大爷都能和你掰扯两句商业模式，时间久了总会或多或少的了解到一些创业的知识，然后便肃然起敬。我敬佩创业的人，在我看来创业者们是一群实干家，是一群心底里想做点事儿的人，做的好坏成败暂且搁置，有这份勇气就值得敬佩。</p><p>这本书按照目录走，全书分为四部分</p><p>－ 总章</p><p>－ 把A计划写下来</p><p>－ 找到计划中风险最高的部分</p><p>－ 系统的测试计划</p><p>老A在阐述自己方法的同时拿自己创办的公司 CloudFire 举例，一步一步的向读者展示他对于精益创业方法论的认知和在创业过程中的实践。我个人最感兴趣的章节是在对系统的测试中对于用户的访谈这一片段，针对问题作用户访谈，针对解决方案作用户访谈，针对MVP作用户访谈。读起来真是大开眼界，因为日常工作是研发为主，几乎没有和用户打过交道，所以读起来对这几个章节格外感兴趣，读出了和人沟通的无限可能性哈哈哈哈…但是读这本书的时候令我困惑的地方是“渠道”和“控制风险”，内联和外联，亲力亲为与自动化，在读完全书回过头去试图做出解答的时候也没有得出自己满意的答案，看来还是修炼不够啊，好好修炼去吧。</p><p>把A计划写下来，老A是这么说的，什么是A计划呢，通俗来说大家记得用来嘲笑程序员的一句话嘛“我有一个好点子，就差一个写代码的了”，这里面的“好点子”就指的是A计划，就像是创业者的一次灵光，产品经理失眠整晚碰到清晨的第一缕阳光…嗯，反正就是这种东西，大家体会一下….但是A计划和青春期的小伙子一样靠不住，大多数A计划都迈着无比沉重的步伐走向各自的八宝山..为了留住这些不靠谱的电子，老A给大家想了一个方法：精益画布。这也是贯穿整本书的灵魂所在，整本书就是在不断的完善它，证伪它，完善它。做好你的精益画布，你的A计划也就写下来了。看下图，精益画布长这样…<br><img src="/2016/11/07/精益创业实战/note.png"><br>在接触到精益画布之后我遇到了一个没有认识过的概念“早期接触者”，各位产品经理们不要笑…在下真是第一次接触这块东西，你们想笑的还在后面呢…囧…早期接纳者在我看来应该是被问题困扰最深的那拨人，已经快要忍不住了，啥产品出来以后都抱着死马能当活马医的心态用一用，只要能解决问题，缓解一下都成，让我想起了地方台那些卖药广告的群演老大爷们（我抱着试一试的心态买了这个药，腰也不疼了，腿也不酸了，也能下地干活了…）但是早期接纳者也有一个问题是，TA可能会和你的用户有很大的不一样，这意味着你的产品会遭受到一定程度上的误导?但是先不要想那么远啦，八字还没有一撇呢，精益画布很有效的一点是能落在实处，你的产品创造，你的商业思维，你的营销策略都可以从这一张画布上发散开来，而且以此为基础，你会不断的迭代优化，最起码你心里有底在，我这个东西是干嘛的，卖给谁，咋赚钱，咋发展，咋跑路。。。blabla。。。如果你不会看的话，老A还在书里贴心地介绍了一套产品数据的指标“海盗指标组”。</p><img src="/2016/11/07/精益创业实战/pic.png"><p>找出计划中风险最高的部分，说实话我对这部分不是特别明白，有一句我觉得应该是这部分的点睛之笔：构建产品的本质就是控制风险。我只能浅浅的理解一下这句话的意思，并没有领悟到老A想告诉的其它含义😅 。在精益画布的帮助下我尝试去解读这句话的意思，在你的产品模式中，最难的应该是独特卖点这一个地方，你要告诉你的用户，来买我的服务吧，你在别家买不到的。每一个非垄断行业里都想一个热火朝天的大卖场，老板们在台后面不断的叫喊着，来啊～来啊～，看看我啊～，使出浑身解数，这个暖萌，那个高冷…咳咳…向一个喜欢二次元的宅男宣传户外我觉得这就是最大的风险，在确认风险的时候首先你要证伪，这一点着实让我大吃一惊，证伪这一点确实是之前没有考虑过的事情，如果跳过这一步的话就是努力的向着死胡同奔跑，所以毫无疑问这一点非常重要，那么如何证伪呢？在控制风险这一章里，定性验证，定量核实是老A提出的方法，关于这一点我理解的奥义在于小步快跑，不断纠正方向，在你的产品服务没有大卖特卖之前，市场不知道你的存在，这个时候如果你想知道市场的反馈那就抓住一切可以学习的机会快速学习，先做个小Demo拿着先上，找几个用户聊一聊，尽快修正，这样的话无论是正面反馈还是负面反馈都会让你做出快速的响应，否则死都不知道怎么死的。。。</p><p>老A花了大量的篇幅来讲系统的测试计划这一章，而这一章也着实重要，系统的测试指的是用高效的方法和最小的成本来获取反馈，从反馈中提取精华，快速迭代。这也是我最感兴趣的一点，在和用户的沟通中，提取出他们真正的需求，福特先生有过一句很出名的话：如果你问用户要什么，他们会说要一匹更快的马。从这句话中不难看出，如果提炼用户需求，搞清楚用户的世界是一个很考验人能力的工作。面对用户之前，一定一定要做到一点，了解自己的问题。连自己都没搞定，怎么去搞定用户呢，其次哈哈哈哈，最好玩的地方是在和用户交流的过程中，探索用户的价值观…要命啦，这一点我觉得有点玄学的特点，但是也并不难，因为人们会很愿意和陌生人吐露自己的真实想法，和熟人反而更难。了解用户存在的问题，不要引导用户的回答，一步一步的引诱着他吐露自己纯洁或者猥琐的内心世界… </p><p>在做用户访谈的时候（ 尤其是早期确定早期接纳者的阶段 ）放弃那些没什么共鸣的人群，同时还有一点值得警惕的是放弃那些不遵守商业规则和契约的人，这些人给你带来的负面影响远远大于正面影响，放弃那些屌丝老板们。针对问题作用户访谈的时候注意用户对问题的描述和你对问题的理解是否存在偏差，存在于什么地方，为什么会存在这样的偏差，不断的拷问自己找到最终的问题所在。在针对解决方案作用户访谈的时候展示自己的解决方案，诱导用户产生兴趣，（ 问题是由两方面引起的，一是痛苦，二是欲望。老A说的太精辟了.. ）在和用户的交流中关注用户的反应，这在价格验证的时候是一个很重要的依据。</p><p>在成功的造出了1.0版本之后就进入了不断的学习环节，通过市场反应不断调节产品，使得产品和市场的匹配程度越来越高，同时给创业者更严峻的考验是活下去，前段时间有句话很冷，但是又很火那就是“Winter is coming.”那么这段时间大家都是穿上了秋衣秋裤挤一挤艰难过冬，在没有暖气还有雾霾的日子里，创业者们要努力的让自己的公司活下去，活到下一个春天来临，大浪淘沙啊。。。</p><p>读完这本书之后我发现了几处我常犯的错误，虽然我不是创业者，只是程序猿（ 你看，我就犯了一个错误 ）。。。</p><ul><li><p>过早的优化，在日常工作中，经常不断的优化代码，心心念念的想着优化业务逻辑，君不见Teambition里的todo list还有一长串呢。一定不要提早优化，在上线初期过早的优化代码和下雨前擦车一样傻。</p></li><li><p>是注意资源的浪费，在开发的某些时候会碰到一些奇奇怪怪的问题，比如网络问题，比如一些硬件玄学问题。。但是有时候执拗起来又拽着问题不放，不经意间就造成了对人力成本的极大浪费。这样非常不好。</p></li><li><p>是理想化追求，想文中开头提到的自动化测试和单元测试，因为之前开发过程中并没有做到单元测试，而且也并非是TDD开发，所以在开发过程中我并没有参与到测试这一环中，都是由专门负责测试任务的同事进行测试工作。但是在接触到的很多文章和讲座里多提到了开发参与测试的重要性，我仍然对这一点持有疑惑，但是在正确的时间做正确的事情，这一点我深信不疑。</p></li></ul><p>关于这本书还有好多问题没有得出结论，大多都是和用户，和产品相关的问题，看来需要补一补这方面知识了。。。</p><blockquote><p>期待下一次在读这本书会有新收获。</p></blockquote><p>本书后来做了一次 KeyNote 和办公室的小伙伴分享</p><img src="/2016/11/07/精益创业实战/读书笔记－精益创业实战.001.jpeg"><img src="/2016/11/07/精益创业实战/读书笔记－精益创业实战.002.jpeg"><img src="/2016/11/07/精益创业实战/读书笔记－精益创业实战.003.jpeg"><img src="/2016/11/07/精益创业实战/读书笔记－精益创业实战.004.jpeg"><img src="/2016/11/07/精益创业实战/读书笔记－精益创业实战.005.jpeg"><img src="/2016/11/07/精益创业实战/读书笔记－精益创业实战.006.jpeg"><img src="/2016/11/07/精益创业实战/读书笔记－精益创业实战.007.jpeg"><img src="/2016/11/07/精益创业实战/读书笔记－精益创业实战.008.jpeg"><img src="/2016/11/07/精益创业实战/读书笔记－精益创业实战.009.jpeg"><img src="/2016/11/07/精益创业实战/读书笔记－精益创业实战.010.jpeg"><img src="/2016/11/07/精益创业实战/读书笔记－精益创业实战.011.jpeg"><img src="/2016/11/07/精益创业实战/读书笔记－精益创业实战.012.jpeg"><img src="/2016/11/07/精益创业实战/读书笔记－精益创业实战.013.jpeg"><img src="/2016/11/07/精益创业实战/读书笔记－精益创业实战.014.jpeg"><img src="/2016/11/07/精益创业实战/读书笔记－精益创业实战.015.jpeg"><img src="/2016/11/07/精益创业实战/读书笔记－精益创业实战.016.jpeg"><img src="/2016/11/07/精益创业实战/读书笔记－精益创业实战.017.jpeg"><img src="/2016/11/07/精益创业实战/读书笔记－精益创业实战.018.jpeg"><img src="/2016/11/07/精益创业实战/读书笔记－精益创业实战.019.jpeg"><img src="/2016/11/07/精益创业实战/读书笔记－精益创业实战.020.jpeg"><img src="/2016/11/07/精益创业实战/读书笔记－精益创业实战.021.jpeg"><img src="/2016/11/07/精益创业实战/读书笔记－精益创业实战.022.jpeg"><img src="/2016/11/07/精益创业实战/读书笔记－精益创业实战.023.jpeg">]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这周某个时候和卢大哥讨论起了软件测试的问题，很巧的是我们有一些不同的看法，这个时候大哥给给我递了一本书，年轻人多看书，多看报，少吃零食早睡觉，一脸不信的我接过了书趁着周末这两天窝在北邮的自习室里读完了这本《精益创业实战》，一本好书，值得多读几遍。&lt;
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://wang-zc.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>人际互动的秘密</title>
    <link href="https://wang-zc.github.io/2016/09/02/%E4%BA%BA%E9%99%85%E4%BA%92%E5%8A%A8%E7%9A%84%E7%A7%98%E5%AF%86/"/>
    <id>https://wang-zc.github.io/2016/09/02/人际互动的秘密/</id>
    <published>2016-09-02T15:20:30.000Z</published>
    <updated>2018-05-07T15:39:37.670Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每个人都是孤独的，都生活在独立的世界中，孤独的出生，孤独的死亡。纵然哪些欢声笑语的人也有一个孤单的心灵，因为地球本就是孤独的，远处只有二向箔在默默地注视着你.</p></blockquote><p>前一段时间正好赶上李松蔚老师讲心理学的Live，我就屁颠屁颠的买了一期，听完很多收获，下面主要是整理了一下李松蔚老师的过程，其中混杂着自己的感触，算是一篇Live笔记了，下面整理了李老师讲述的几个要点供参考…</p><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>授权是互动过程的一部分。互动是双方或者多方的关系，老话说的是一个巴掌拍不响就是这个理儿。互动一定是一个相互依存的关系，不能割裂。<br>说到互动，这里有有一个很基础的观点，授权。互动和授权的关系很像是数理逻辑的充分必要条件这种依赖关系，又有点像是Venn图的数学关系（这方面见仁见智了…）。<br>举个例子，当一个女生讲，“我被这个渣男毁掉了一生”。看起来是在这个女生和渣男的交往过程中，渣男参与进来毁掉了女生的一生。但是这里浮现出了“授权”的概念，这里的逻辑是这样的，在交往过程中，这个女生授权这个渣男毁掉了她的一生，她选择相信这个渣男毁掉了你的一生…<br>在人际交往中，只要一个人做的事情或者一些事物对你产生了影响，这里面一定有你的授权。比如说当你打开这个微信，看这篇文章，就是你在授权它影响你。是因为你的授权，你的所作所为，所以这篇文章才会对你产生影响。<br>互动在授权的基础上可以拆分成下面着两个进程</p><ol><li>他做了一些事情</li><li>你授权他的行为对你产生影响<br>互动需要对方的授权，是一个相互配合的事情。<br>现在社会上有一些相对狭隘的想法，就忽略了这一点，在互动的过程一方感觉自己的话是有魔力的，可以带动另一方的情绪，自己的某种话语魔力（活着人格魅力或者什么肢体动作乱七八糟的鸟东西），导致对方受到了某种影响，这种魔力有好多个名字，掌控感，领导力，leadership诸如此类，但是这样会陷入一个很尴尬的地位，完全忽略了另一方的配合，忽略了和你沟通的对象的存在了，我们把授权的概念拉到这个场景下解释一下其实是由于对方配合你，才让你认为自己产生某种魔力。才让你产生这种虚妄的感觉。（可以想象两个极端场景［1］大哥给小弟讲心灵鸡汤［2］阿谀奉承 ）<br> 在互动中有两条规则是存在的，这两条规则李松蔚老师称之为元规则。</li></ol><ul><li>你在人际互动中可以做任何事 （没有束缚，没有规则）</li><li>你不能控制这件事的结果（无法预测）<br>  举一个最当下的例子：我可以在这篇文章里写任何东西，美好的，肮脏的，哲学的，数理的等等等等任何事情，包括犯法的，乱伦的事情，都是可以的。法律和道德是社会后来加的基本规则，我们在互动中可以做任何事情。但是我无法控制我做完之后产生的后果，触犯了法律，违背了社会公德，会遭受到国家机器的惩罚，世俗人民的谴责（谩骂）或者写了一篇好文章第二天发现自己成为名人了?…被读者骂等等等等。<br>当我发现我写了一篇文章被读者骂的很惨，心里觉得十分气愤，这个时候套用授权的概念是我授权让别人的文字对我产生了影响。所有的互动中肯定会有授权的存在，你的所做所为都是因为你授权这件事情，这个人，这些事物影响到了你。</li></ul><h3 id="不可知论"><a href="#不可知论" class="headerlink" title="不可知论"></a>不可知论</h3><p>我们只能感知自己的情绪。任何除你之外的其他人，其他事都是不可知的，我们唯一能确定的有且仅有我们自己的感受。当别人的情绪对你产生影响的时候本质上来讲其实是一个不可知的事物给你带来了你自己可以确定的对你的影响。<br>举个例子：某一天因为公司业绩达到了目标，CEO在公司内部发表了激情洋溢的演说，但是现场的人员反馈没有CEO预想的热烈，零星点点几片掌声（没办法，研发就是这个鸟样子。。。囧。。），然后呢CEO觉得不太开心。这个月没奖金发了！<br><strong>拆分一下</strong></p><ol><li>这个例子里面CEO的讲话对员工产生的影响是无法预测的（你永远都不知道别人在想什么）</li><li>员工表现不是特别积极，CEO在心里会根据这些反馈得出一个消极的结论（@warn:这里是CEO授权让这些反馈影响到了他自己）从而产生了一个挫败的感觉，CEO不知道员工是不是喜欢他的演讲，但是CEO心里猜想员工可能不喜欢他的演讲，从而产生了挫败的情绪</li><li>员工的感觉是不可知的，但是CEO的挫败情绪是我们确定一定以及肯定可知的！<br><strong>拆分结束</strong><br>我们顺利的从不可知回到了可知，归结起来尝试这样去理解：别人的想法和状态是不可知的，不可信的，那是别人的事情，但是在这些别人的情绪反馈里我们产生了自己的可能性推论，虽然我们无法验证这种可能性，但是我们授权这种可能性对我们自己产生影响。</li></ol><h3 id="课题分离"><a href="#课题分离" class="headerlink" title="课题分离"></a>课题分离</h3><p>我们只能处理自己的情绪。在一段人际关系中，基于上面的不可知论，我们永远无法知道别人的感受，永远只能处理自己的感受课题，因为只有我们自己的感受是我们真正能感受到的，真正能把握的。<br>举个例子，我做了一件事情让别人不舒服了，那我是否需要处理别人的不舒服? 不需要。因为你不知道他是不是真的不舒服，就算他明白的告诉你你让他不舒服了，也只是你选择相信了你的选择而已（见第一节）。别人的情绪让别人去处理，你无法处理，你能处理的只是你自己的情绪，你自己的可知感受。<br>那这样的话是不是™就可以不负责任了呢？不是的，处理自己的感受，别人的感受让别人处理，这是一条元规则，参考组成世界的普朗克常数，我让别人不舒服了并不会直接推导出我要去处理别人的不舒服，这里跳过了一环，你让别人不舒服了，你自己感觉很内疚，你去处理别人的不舒服其实是在解决你的内疚，不是处理别人的不舒服，在重申一遍，别人的情绪只能让别人去处理。<br>做一道习题，一个女生说，我妈妈不喜欢我染头发，我不染了。这里的逻辑有问题吗？<br>Of course，这个女生说我妈妈不喜欢我染头发，我不染了，但是中间欠缺了一环就是这个女生自己的感受，她妈妈不喜欢她染头发，对她产生了某种影戏那个，她感到害怕之类的情绪，因为她的这些情绪，所以她选择了不染头发。我们做出一些决定并不是因为别人的原因，而是因为要抚平我们自己的情绪，课题分离的原则体现在我们只能处理我们自己的情绪，即使我们是因为别人的某种反应做出了一些调整，但是这个调整的原因实际上是我们对于别人的某种反应得出来的某种反应或者某种映像作出的调整。</p><h3 id="一个完整的人际反射"><a href="#一个完整的人际反射" class="headerlink" title="一个完整的人际反射"></a>一个完整的人际反射</h3><ul><li>对方做了什么</li><li>对方做的事情对我来说意味着什么</li><li>我做什么，来应对我的情绪<br>当两个人的反射拼接到一起就形成了一个循环的互动链条，这里可以参考下计算机科学里面的TCP握手协议.</li></ul><p>感兴趣的可以点击查看原文看下李松蔚老师的<a href="https://mp.weixin.qq.com/s?__biz=MzA4NTI3NTkyNQ==&amp;mid=2654002622&amp;idx=1&amp;sn=bfc18f40b042628b63a986622746066c&amp;scene=4&amp;uin=MjkzODM0MzEwMQ%3D%3D&amp;key=7b81aac53bd2393d55de75a46b6ec27932fe634f88d1b794ce2bfe102c634e7d1e55939fc884a1031a0091a8f8a872bb" target="_blank" rel="noopener">文章</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;每个人都是孤独的，都生活在独立的世界中，孤独的出生，孤独的死亡。纵然哪些欢声笑语的人也有一个孤单的心灵，因为地球本就是孤独的，远处只有二向箔在默默地注视着你.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前一段时间正好赶上李松蔚老师讲心理学的Live
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://wang-zc.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
